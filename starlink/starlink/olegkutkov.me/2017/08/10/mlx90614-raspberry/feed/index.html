<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>
	Comments on: Connecting MLX90614 infrared thermometer to the Raspberry PI	</title>
	<atom:link href="https://olegkutkov.me/2017/08/10/mlx90614-raspberry/feed/" rel="self" type="application/rss+xml" />
	<link>https://olegkutkov.me/2017/08/10/mlx90614-raspberry/</link>
	<description>Programming, electronics and diy projects</description>
	<lastBuildDate>Wed, 06 Mar 2024 01:36:03 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.5.3</generator>
	<item>
		<title>
		By: Robert O		</title>
		<link>https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-2270</link>

		<dc:creator><![CDATA[Robert O]]></dc:creator>
		<pubDate>Wed, 06 Mar 2024 01:36:03 +0000</pubDate>
		<guid isPermaLink="false">http://olegkutkov.me/?p=25#comment-2270</guid>

					<description><![CDATA[Really helped me with my project. Thank you]]></description>
			<content:encoded><![CDATA[<p>Really helped me with my project. Thank you</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Oleg Kutkov		</title>
		<link>https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1419</link>

		<dc:creator><![CDATA[Oleg Kutkov]]></dc:creator>
		<pubDate>Mon, 06 Feb 2023 20:00:13 +0000</pubDate>
		<guid isPermaLink="false">http://olegkutkov.me/?p=25#comment-1419</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1418&quot;&gt;Team&lt;/a&gt;.

The whole article is about using MLX90614 with Raspberry Pi]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1418">Team</a>.</p>
<p>The whole article is about using MLX90614 with Raspberry Pi</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Team		</title>
		<link>https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1418</link>

		<dc:creator><![CDATA[Team]]></dc:creator>
		<pubDate>Mon, 06 Feb 2023 19:49:33 +0000</pubDate>
		<guid isPermaLink="false">http://olegkutkov.me/?p=25#comment-1418</guid>

					<description><![CDATA[Is the MLX90614 compatible with the Raspberry Pi?]]></description>
			<content:encoded><![CDATA[<p>Is the MLX90614 compatible with the Raspberry Pi?</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Oleg Kutkov		</title>
		<link>https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1355</link>

		<dc:creator><![CDATA[Oleg Kutkov]]></dc:creator>
		<pubDate>Sat, 16 Jul 2022 23:53:19 +0000</pubDate>
		<guid isPermaLink="false">http://olegkutkov.me/?p=25#comment-1355</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1354&quot;&gt;Stephen Petersen&lt;/a&gt;.

The sensor is mounted on the box with Raspberry PI and other electronics inside.
It just tightly sits in a hole and is secured with sealant.
&lt;img src=&quot;https://olegkutkov.me/wp-content/uploads/2022/07/xdcJzU3isRM.jpg&quot; alt=&quot;&quot; /&gt;]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1354">Stephen Petersen</a>.</p>
<p>The sensor is mounted on the box with Raspberry PI and other electronics inside.<br />
It just tightly sits in a hole and is secured with sealant.<br />
<img src="https://olegkutkov.me/wp-content/uploads/2022/07/xdcJzU3isRM.jpg" alt="" /></p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Stephen Petersen		</title>
		<link>https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1354</link>

		<dc:creator><![CDATA[Stephen Petersen]]></dc:creator>
		<pubDate>Sat, 16 Jul 2022 23:47:46 +0000</pubDate>
		<guid isPermaLink="false">http://olegkutkov.me/?p=25#comment-1354</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1353&quot;&gt;Oleg Kutkov&lt;/a&gt;.

Thanks for the very quick response. Are you using a cable gland or something similar?]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1353">Oleg Kutkov</a>.</p>
<p>Thanks for the very quick response. Are you using a cable gland or something similar?</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Oleg Kutkov		</title>
		<link>https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1353</link>

		<dc:creator><![CDATA[Oleg Kutkov]]></dc:creator>
		<pubDate>Sat, 16 Jul 2022 23:46:21 +0000</pubDate>
		<guid isPermaLink="false">http://olegkutkov.me/?p=25#comment-1353</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1352&quot;&gt;Stephen Petersen&lt;/a&gt;.

Hello. That&#039;s correct.
I&#039;m using my MLX sensor outdoor without any cover on the top. It&#039;s waterproof. Sure, bottom contacts are hidden inside a box, but the top panel window is exposed to the open sky.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1352">Stephen Petersen</a>.</p>
<p>Hello. That&#8217;s correct.<br />
I&#8217;m using my MLX sensor outdoor without any cover on the top. It&#8217;s waterproof. Sure, bottom contacts are hidden inside a box, but the top panel window is exposed to the open sky.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Stephen Petersen		</title>
		<link>https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1352</link>

		<dc:creator><![CDATA[Stephen Petersen]]></dc:creator>
		<pubDate>Sat, 16 Jul 2022 23:42:09 +0000</pubDate>
		<guid isPermaLink="false">http://olegkutkov.me/?p=25#comment-1352</guid>

					<description><![CDATA[I read somewhere that for the sensor to be accurate, you have to expose it to the sky without anything like a plastic dome to cover it. If that is correct, how do you do that? TIA!!]]></description>
			<content:encoded><![CDATA[<p>I read somewhere that for the sensor to be accurate, you have to expose it to the sky without anything like a plastic dome to cover it. If that is correct, how do you do that? TIA!!</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Oleg Kutkov		</title>
		<link>https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1312</link>

		<dc:creator><![CDATA[Oleg Kutkov]]></dc:creator>
		<pubDate>Thu, 09 Jun 2022 19:25:23 +0000</pubDate>
		<guid isPermaLink="false">http://olegkutkov.me/?p=25#comment-1312</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1311&quot;&gt;farm2440&lt;/a&gt;.

Thank you for your comment. Fixed!]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1311">farm2440</a>.</p>
<p>Thank you for your comment. Fixed!</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: farm2440		</title>
		<link>https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1311</link>

		<dc:creator><![CDATA[farm2440]]></dc:creator>
		<pubDate>Thu, 09 Jun 2022 19:16:46 +0000</pubDate>
		<guid isPermaLink="false">http://olegkutkov.me/?p=25#comment-1311</guid>

					<description><![CDATA[VSS – power supply (3.3 or 5 volts).  : Watch out!!! This is wrong! VSS is ground and VDD is positive power supply.]]></description>
			<content:encoded><![CDATA[<p>VSS – power supply (3.3 or 5 volts).  : Watch out!!! This is wrong! VSS is ground and VDD is positive power supply.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Kulwant Singh		</title>
		<link>https://olegkutkov.me/2017/08/10/mlx90614-raspberry/#comment-1099</link>

		<dc:creator><![CDATA[Kulwant Singh]]></dc:creator>
		<pubDate>Sat, 04 Dec 2021 00:29:08 +0000</pubDate>
		<guid isPermaLink="false">http://olegkutkov.me/?p=25#comment-1099</guid>

					<description><![CDATA[Hi Oleg! 
I&#039;m hoping you are still reading this and can help me with an issue I&#039;m having with setting emissivity on 90614DCC sensor.

I&#039;m following the steps in MLX90614-Changing-Emissivity-Unlocking-Key-Application-Note-Melexis section 6.2. I&#039;m able to read and write to the EEPROM locations as specified except for the very first step which is to &quot;Enter EEPROM address 0x0F unlock key&quot;. 
I have tried reading from 0x60 (as listed in opcode column) but this address doesn&#039;t exist so there&#039;s an error. Also tried writing 0x0F to 0x60 but that didn&#039;t work either. 
If I skip this step and follow the rest of the steps as following, new values written are not saved. I read old values back:
-Write 0x0000 to 0x24 (Erase emissivity)
- write new emissivity to 0x24
- read back emissivity (Reads old value, not new)
- write 0x0000 to 0x2F (Erase )
- write new value to 0x2F
- read 0x2F (returns old value, not new)

I&#039;m wondering if there is an error in the datasheet section 6.2.1  &quot;Enter EEPROM address 0x0F unlock key&quot; or whether I am doing something wrong.

Any ideas to try out are appreciated.

Code:
from time import sleep
import smbus

class MLX90614():

&lt;code&gt;# RAM offsets with 16-bit data, MSB first
# Raw data IR channel 1
MLX90614_RAWIR1 = 0x04
# Raw data IR channel 2
MLX90614_RAWIR2 = 0x05
# Ambient temperature
MLX90614_TA = 0x06
# Object 1 temperature
MLX90614_TOBJ1 = 0x07
# Object 2 temperature
MLX90614_TOBJ2 = 0x08

# EEPROM offsets with 16-bit data, MSB first
# Object temperature max register
MLX90614_TOMAX = 0x20
# Object temperature min register
MLX90614_TOMIN = 0x21
# PWM configuration register
MLX90614_PWMCTRL = 0x22
# Ambient temperature register
MLX90614_TARANGE = 0x23
# Emissivity correction register
MLX90614_EMISS = 0x24
# Configuration register
MLX90614_CONFIG = 0x25
# Slave address register
MLX90614_ADDR = 0x2E
#EEPROM Unlock key
MLX90614_UNLOCK_KEY = 0x2F
# 1 ID register (read-only)
MLX90614_ID1 = 0x3C
# 2 ID register (read-only)
MLX90614_ID2 = 0x3D
# 3 ID register (read-only)
MLX90614_ID3 = 0x3E
# 4 ID register (read-only)
MLX90614_ID4 = 0x3F

comm_retries = 5
comm_sleep_amount = 0.1

def __init__(self, bus_num = 1, address=0x5A):
    self.address = address
    self.bus = smbus.SMBus(bus=bus_num)

def read_reg(self, reg_addr):
    err = None
    for i in range(self.comm_retries):
        try:
            return self.bus.read_word_data(self.address, reg_addr)
        except IOError as e:
            err = e
            # &quot;Rate limiting&quot; - sleeping to prevent problems with sensor
            # when requesting data too quickly
            sleep(self.comm_sleep_amount)
    # By this time, we made a couple requests and the sensor didn&#039;t respond
    # (judging by the fact we haven&#039;t returned from this function yet)
    # So let&#039;s just re-raise the last IOError we got
    raise err

def write_reg(self, reg_addr, data):
    err = None
    for i in range(self.comm_retries):
        try:
            return self.bus.write_word_data(self.address, reg_addr, data)
        except IOError as e:
            err = e
            # &quot;Rate limiting&quot; - sleeping to prevent problems with sensor
            # when requesting data too quickly
            sleep(self.comm_sleep_amount)
    # By this time, we made a couple requests and the sensor didn&#039;t respond
    # (judging by the fact we haven&#039;t returned from this function yet)
    # So let&#039;s just re-raise the last IOError we got
    raise err

def read_temp(self, reg):
    data = self.read_reg(reg)
    temp = (data * 0.02) - 273.15
    return temp

def get_ambient(self):
    return self.read_temp(self.MLX90614_TA)

def get_object_1(self):
    return self.read_temp(self.MLX90614_TOBJ1)

def get_object_2(self):
    return self.read_temp(self.MLX90614_TOBJ2)

def get_emmissivity(self):
    return self.read_reg(self.MLX90614_EMISS)

def get_unlock0F(self):
    return self.read_reg(self.MLX90614_UNLOCK_KEY)

def set_unlock0F(self, data):
    return self.write_reg(self.MLX90614_UNLOCK_KEY, data)

def set_emmissivity(self, data):
    #self.read_reg(self.MLX90614_UNLOCK_KEY)
    self.write_reg(self.MLX90614_EMISS, 0x0000)
    return self.write_reg(self.MLX90614_EMISS, data)
&lt;/code&gt;

if &lt;strong&gt;name&lt;/strong&gt; == &quot;&lt;strong&gt;main&lt;/strong&gt;&quot;:

&lt;code&gt;#bus = smbus.SMBus()
IRTemp = MLX90614(1)

print(&quot;TO Max: &quot;, IRTemp.read_temp(IRTemp.MLX90614_TOMAX))
print(&quot;TO Min: &quot;, IRTemp.read_temp(IRTemp.MLX90614_TOMIN))
print(&quot;Ambient Temperature (deg. C): &quot;, IRTemp.get_ambient())
print(&quot;Object Temperature (deg. C): &quot;, IRTemp.get_object_1())

emissOld = IRTemp.get_emmissivity()
print(&quot;Old Emmissivity: &quot;, emissOld)
print(&quot;unlock 0x60 read: &quot;, IRTemp.read_reg(0x0F))
print(IRTemp.write_reg(0x60, 0x0F))
unlockOld = IRTemp.get_unlock0F()
print(&quot;unlock Old: &quot;, unlockOld)
#calculate emmissivity
#Treal = float(input(&quot;Real object Temp:&quot;))
#Areal = float(input(&quot;Real ambient Temp:&quot;))
Treal = 25.4
Areal = 28.9
Tsens = IRTemp.get_object_1()
Asens = IRTemp.get_ambient()

emiss = ((Tsens+273.15)**4 - (Asens+273.15)**4)/((Treal+273.15)**4 - (Areal+273.15)**4)
emissReg = round((2**16)*emiss - 1)
emisshex = hex(emissReg)

print(f&quot;calculated emmiss:{emiss}, reg value: {emissReg}, hex:{emisshex}&quot;)
unlockNew = round(emissOld*unlockOld/emissReg)

print(&quot;New Emmissivity: &quot;, emissReg)
print(&quot;New Unlock: &quot;, unlockNew)
print(&quot;unlock 0x60 read: &quot;, IRTemp.read_reg(0x0F))

IRTemp.set_emmissivity(emissReg)
print(&quot;Read Emmissivity: &quot;, IRTemp.get_emmissivity())
IRTemp.set_unlock0F(0x0000)
IRTemp.set_unlock0F(unlockNew)
print(&quot;Read Unlock: &quot;, IRTemp.get_unlock0F())
&lt;/code&gt;]]></description>
			<content:encoded><![CDATA[<p>Hi Oleg!<br />
I&#8217;m hoping you are still reading this and can help me with an issue I&#8217;m having with setting emissivity on 90614DCC sensor.</p>
<p>I&#8217;m following the steps in MLX90614-Changing-Emissivity-Unlocking-Key-Application-Note-Melexis section 6.2. I&#8217;m able to read and write to the EEPROM locations as specified except for the very first step which is to &#8220;Enter EEPROM address 0x0F unlock key&#8221;.<br />
I have tried reading from 0x60 (as listed in opcode column) but this address doesn&#8217;t exist so there&#8217;s an error. Also tried writing 0x0F to 0x60 but that didn&#8217;t work either.<br />
If I skip this step and follow the rest of the steps as following, new values written are not saved. I read old values back:<br />
-Write 0x0000 to 0x24 (Erase emissivity)<br />
&#8211; write new emissivity to 0x24<br />
&#8211; read back emissivity (Reads old value, not new)<br />
&#8211; write 0x0000 to 0x2F (Erase )<br />
&#8211; write new value to 0x2F<br />
&#8211; read 0x2F (returns old value, not new)</p>
<p>I&#8217;m wondering if there is an error in the datasheet section 6.2.1  &#8220;Enter EEPROM address 0x0F unlock key&#8221; or whether I am doing something wrong.</p>
<p>Any ideas to try out are appreciated.</p>
<p>Code:<br />
from time import sleep<br />
import smbus</p>
<p>class MLX90614():</p>
<p><code># RAM offsets with 16-bit data, MSB first<br />
# Raw data IR channel 1<br />
MLX90614_RAWIR1 = 0x04<br />
# Raw data IR channel 2<br />
MLX90614_RAWIR2 = 0x05<br />
# Ambient temperature<br />
MLX90614_TA = 0x06<br />
# Object 1 temperature<br />
MLX90614_TOBJ1 = 0x07<br />
# Object 2 temperature<br />
MLX90614_TOBJ2 = 0x08</p>
<p># EEPROM offsets with 16-bit data, MSB first<br />
# Object temperature max register<br />
MLX90614_TOMAX = 0x20<br />
# Object temperature min register<br />
MLX90614_TOMIN = 0x21<br />
# PWM configuration register<br />
MLX90614_PWMCTRL = 0x22<br />
# Ambient temperature register<br />
MLX90614_TARANGE = 0x23<br />
# Emissivity correction register<br />
MLX90614_EMISS = 0x24<br />
# Configuration register<br />
MLX90614_CONFIG = 0x25<br />
# Slave address register<br />
MLX90614_ADDR = 0x2E<br />
#EEPROM Unlock key<br />
MLX90614_UNLOCK_KEY = 0x2F<br />
# 1 ID register (read-only)<br />
MLX90614_ID1 = 0x3C<br />
# 2 ID register (read-only)<br />
MLX90614_ID2 = 0x3D<br />
# 3 ID register (read-only)<br />
MLX90614_ID3 = 0x3E<br />
# 4 ID register (read-only)<br />
MLX90614_ID4 = 0x3F</p>
<p>comm_retries = 5<br />
comm_sleep_amount = 0.1</p>
<p>def __init__(self, bus_num = 1, address=0x5A):<br />
    self.address = address<br />
    self.bus = smbus.SMBus(bus=bus_num)</p>
<p>def read_reg(self, reg_addr):<br />
    err = None<br />
    for i in range(self.comm_retries):<br />
        try:<br />
            return self.bus.read_word_data(self.address, reg_addr)<br />
        except IOError as e:<br />
            err = e<br />
            # "Rate limiting" - sleeping to prevent problems with sensor<br />
            # when requesting data too quickly<br />
            sleep(self.comm_sleep_amount)<br />
    # By this time, we made a couple requests and the sensor didn't respond<br />
    # (judging by the fact we haven't returned from this function yet)<br />
    # So let's just re-raise the last IOError we got<br />
    raise err</p>
<p>def write_reg(self, reg_addr, data):<br />
    err = None<br />
    for i in range(self.comm_retries):<br />
        try:<br />
            return self.bus.write_word_data(self.address, reg_addr, data)<br />
        except IOError as e:<br />
            err = e<br />
            # "Rate limiting" - sleeping to prevent problems with sensor<br />
            # when requesting data too quickly<br />
            sleep(self.comm_sleep_amount)<br />
    # By this time, we made a couple requests and the sensor didn't respond<br />
    # (judging by the fact we haven't returned from this function yet)<br />
    # So let's just re-raise the last IOError we got<br />
    raise err</p>
<p>def read_temp(self, reg):<br />
    data = self.read_reg(reg)<br />
    temp = (data * 0.02) - 273.15<br />
    return temp</p>
<p>def get_ambient(self):<br />
    return self.read_temp(self.MLX90614_TA)</p>
<p>def get_object_1(self):<br />
    return self.read_temp(self.MLX90614_TOBJ1)</p>
<p>def get_object_2(self):<br />
    return self.read_temp(self.MLX90614_TOBJ2)</p>
<p>def get_emmissivity(self):<br />
    return self.read_reg(self.MLX90614_EMISS)</p>
<p>def get_unlock0F(self):<br />
    return self.read_reg(self.MLX90614_UNLOCK_KEY)</p>
<p>def set_unlock0F(self, data):<br />
    return self.write_reg(self.MLX90614_UNLOCK_KEY, data)</p>
<p>def set_emmissivity(self, data):<br />
    #self.read_reg(self.MLX90614_UNLOCK_KEY)<br />
    self.write_reg(self.MLX90614_EMISS, 0x0000)<br />
    return self.write_reg(self.MLX90614_EMISS, data)<br />
</code></p>
<p>if <strong>name</strong> == &#8220;<strong>main</strong>&#8220;:</p>
<p><code>#bus = smbus.SMBus()<br />
IRTemp = MLX90614(1)</p>
<p>print("TO Max: ", IRTemp.read_temp(IRTemp.MLX90614_TOMAX))<br />
print("TO Min: ", IRTemp.read_temp(IRTemp.MLX90614_TOMIN))<br />
print("Ambient Temperature (deg. C): ", IRTemp.get_ambient())<br />
print("Object Temperature (deg. C): ", IRTemp.get_object_1())</p>
<p>emissOld = IRTemp.get_emmissivity()<br />
print("Old Emmissivity: ", emissOld)<br />
print("unlock 0x60 read: ", IRTemp.read_reg(0x0F))<br />
print(IRTemp.write_reg(0x60, 0x0F))<br />
unlockOld = IRTemp.get_unlock0F()<br />
print("unlock Old: ", unlockOld)<br />
#calculate emmissivity<br />
#Treal = float(input("Real object Temp:"))<br />
#Areal = float(input("Real ambient Temp:"))<br />
Treal = 25.4<br />
Areal = 28.9<br />
Tsens = IRTemp.get_object_1()<br />
Asens = IRTemp.get_ambient()</p>
<p>emiss = ((Tsens+273.15)**4 - (Asens+273.15)**4)/((Treal+273.15)**4 - (Areal+273.15)**4)<br />
emissReg = round((2**16)*emiss - 1)<br />
emisshex = hex(emissReg)</p>
<p>print(f"calculated emmiss:{emiss}, reg value: {emissReg}, hex:{emisshex}")<br />
unlockNew = round(emissOld*unlockOld/emissReg)</p>
<p>print("New Emmissivity: ", emissReg)<br />
print("New Unlock: ", unlockNew)<br />
print("unlock 0x60 read: ", IRTemp.read_reg(0x0F))</p>
<p>IRTemp.set_emmissivity(emissReg)<br />
print("Read Emmissivity: ", IRTemp.get_emmissivity())<br />
IRTemp.set_unlock0F(0x0000)<br />
IRTemp.set_unlock0F(unlockNew)<br />
print("Read Unlock: ", IRTemp.get_unlock0F())<br />
</code></p>
]]></content:encoded>
		
			</item>
	</channel>
</rss>
