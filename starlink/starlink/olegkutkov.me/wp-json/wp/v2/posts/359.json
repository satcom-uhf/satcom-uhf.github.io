{"id":359,"date":"2018-03-14T16:24:01","date_gmt":"2018-03-14T13:24:01","guid":{"rendered":"http:\/\/olegkutkov.me\/?p=359"},"modified":"2021-02-05T16:13:04","modified_gmt":"2021-02-05T14:13:04","slug":"simple-linux-character-device-driver","status":"publish","type":"post","link":"https:\/\/olegkutkov.me\/2018\/03\/14\/simple-linux-character-device-driver\/","title":{"rendered":"Simple Linux character device driver"},"content":{"rendered":"<p><img loading=\"lazy\" decoding=\"async\" class=\"alignleft wp-image-360 size-thumbnail\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/03\/linux_chardev_logo-150x150.png\" alt=\"\" width=\"150\" height=\"150\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/03\/linux_chardev_logo-150x150.png 150w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/03\/linux_chardev_logo.png 300w\" sizes=\"(max-width: 150px) 100vw, 150px\" \/>A character device is one of the simplest ways to communicate with a module in the Linux kernel.<br \/>\nThese devices are presented as special files in a <em>\/dev<\/em> directory and support direct reading and writing of any data, byte by byte, like a stream. Actually, most of the pseudo-devices in <em>\/dev<\/em> are character devices: serial ports, modems, sound, and video adapters, keyboards, some custom I\/O interfaces. Userspace programs can easily open, read, write, and custom control requests with such device files.<br \/>\nHere I am describing how to write a simple Linux kernel module which can create one or multiple character device.<\/p>\n<p><!--more--><\/p>\n<h2>Introducing to character devices.<\/h2>\n<p>Detection of the device type in <em>\/dev<\/em> directory is pretty simple.<\/p>\n<pre class=\"prettyprint\">$ ls -l \/dev\/ttyS0\ncrw-rw---- 1 root dialout 4, 64 Mar 11 16:52 \/dev\/ttyS0<\/pre>\n<p>Symbol <strong>C, <\/strong>in the beginning, means that this device is a character device.<br \/>\nAlso, you can find here two strange numbers: <strong>4<\/strong> and <strong>64<\/strong>. This is a Major and Minor number of this device.<br \/>\nInside the Linux kernel, every device is identified not by a symbolic name but by a unique number &#8211; the device&#8217;s major number. This number assigning by the kernel during device registration. Every device driver can support multiple &#8220;sub-devices&#8221;. For example, a serial port adapter may contain two hardware ports. Both of these ports are handled by the same driver, and they share one Major number. But inside this driver, each of these ports is also identified by the unique number, and this is a device Minor number.<\/p>\n<pre class=\"prettyprint\">crw-rw---- 1 root dialout 4, 64 Mar 11 16:52 \/dev\/ttyS0\ncrw-rw---- 1 root dialout 4, 65 Mar 11 16:52 \/dev\/ttyS1\ncrw-rw---- 1 root dialout 4, 66 Mar 11 16:52 \/dev\/ttyS2<\/pre>\n<p>One Major number <strong>4<\/strong> for every ttySX device and different (<strong>64<\/strong>&#8211;<strong>65<\/strong>) Minor numbers.<br \/>\nThe driver&#8217;s code assigns minor numbers, and the developer of this driver may select any suitable values.<\/p>\n<p>As this device acts like a file &#8211; programs can do almost everything except seeking. Every file operation on this object commands the driver to do something inside the Linux kernel and start reading some data from the hardware.<\/p>\n<p>At the end of this article, you can find a complete example of the character device driver, but first, let&#8217;s discuss how it works.<\/p>\n<p>The diagram below shows how the userspace program interacts with the IBM PC serial port using the character device.<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/03\/serail_driver_read.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-368 size-full\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/03\/serail_driver_read.png\" alt=\"\" width=\"665\" height=\"608\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/03\/serail_driver_read.png 665w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/03\/serail_driver_read-300x274.png 300w\" sizes=\"(max-width: 665px) 100vw, 665px\" \/><\/a>The virtual filesystem is an abstraction layer on top of a more concrete file system. A VFS aims to allow client applications to access different types of concrete file systems uniformly.<\/p>\n<h2>File operations<\/h2>\n<p>In special device files, VFS is responsible for calling I\/O functions set by the device driver.<br \/>\nTo set this function special kernel structure is used.<br \/>\n<!--?prettify linenums=true?--><\/p>\n<pre class=\"prettyprint\">    struct file_operations {\n       struct module *owner;\n       loff_t (*llseek) (struct file *, loff_t, int);\n       ssize_t (*read) (struct file *, char *, size_t, loff_t *);\n       ssize_t (*write) (struct file *, const char *, size_t, loff_t *);\n       int (*readdir) (struct file *, void *, filldir_t);\n       unsigned int (*poll) (struct file *, struct poll_table_struct *);\n       int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);\n       int (*mmap) (struct file *, struct vm_area_struct *);\n       int (*open) (struct inode *, struct file *);\n       int (*flush) (struct file *);\n       int (*release) (struct inode *, struct file *);\n       int (*fsync) (struct file *, struct dentry *, int datasync);\n       int (*fasync) (int, struct file *, int);\n       int (*lock) (struct file *, int, struct file_lock *);\n         ssize_t (*readv) (struct file *, const struct iovec *, unsigned long,\n          loff_t *);\n         ssize_t (*writev) (struct file *, const struct iovec *, unsigned long,\n          loff_t *);\n    };<\/pre>\n<p>Some operations are not implemented by a driver. For example, a driver that handles a video card won&#8217;t need to read from a directory structure. The corresponding entries in the <strong><span class=\"TYPE\">file_operations<\/span><\/strong> structure should be set to <tt class=\"VARNAME\">NULL<\/tt>.<\/p>\n<p>In a C99 way, initialization is simple.<\/p>\n<pre class=\"prettyprint\">    struct file_operations fops = {\n       .read = device_read,\n       .write = device_write,\n       .open = device_open,\n       .release = device_release\n    };<\/pre>\n<p>Initialized <strong>file_operation<\/strong>s can be assigned to the character device during device registration.<\/p>\n<h2>Registration of the character device<\/h2>\n<p>The registration procedure consists of several simple steps.<br \/>\nFirst, you need to decide how many minor devices you need. This is a constant which typically depends on your hardware (if you are writing a driver for real hardware).<br \/>\nMinor numbers are convenient to use as part of the device name. For example,\/dev\/mychardev0 with a Minor 0 \/dev\/mychardev2 with a Minor 2.<\/p>\n<p>The first step is an allocation and registration of the range of char device numbers using <em>alloc_chrdev_region<\/em>.<\/p>\n<pre class=\"prettyprint\">int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);<\/pre>\n<p>Where <em>dev<\/em> is output parameter for first assigned number, <em>baseminor<\/em> is first of the requested range of minor numbers (e.g., 0), <em>count<\/em> is a number of minor numbers required, and <em>name<\/em> &#8211; the associated device&#8217;s name driver.<\/p>\n<p>The major number will be chosen dynamically and returned (along with the first minor number) in dev.<br \/>\nThe function returns zero or a negative error code.<\/p>\n<p>To get generated Major number, we can use <strong>MAJOR()<\/strong> macros.<\/p>\n<pre class=\"prettyprint\">int dev_major = MAJOR(dev);<\/pre>\n<p>Now it&#8217;s time to initialize a new character device and set file_operations with <em>cdev_init<\/em>.<\/p>\n<pre class=\"prettyprint\">void cdev_init(struct cdev *cdev, const struct file_operations *fops);<\/pre>\n<p><em>struct cdev<\/em> represents a character device and is allocated by this function.<\/p>\n<p>Now add the device to the system.<\/p>\n<pre class=\"prettyprint\">int cdev_add(struct cdev *p, dev_t dev, unsigned count);<\/pre>\n<p>Finally &#8211; create a device file node and register it with sysfs.<\/p>\n<pre class=\"prettyprint\">struct device * device_create(struct class *class, struct device *parent, dev_t devt, const char *fmt, ...);<\/pre>\n<p>Now all together.<br \/>\nThis code creates 2 character devices with names <em>\/dev\/mychardev0<\/em> and <em>\/dev\/mychardev1<\/em><\/p>\n<pre class=\"prettyprint\">#include &lt;linux\/cdev.h&gt;\n#include &lt;linux\/device.h&gt;\n#include &lt;linux\/kernel.h&gt;\n#include &lt;linux\/fs.h&gt;\n\n\/\/ max Minor devices\n#define MAX_DEV 2\n\n\/\/ initialize file_operations\nstatic const struct file_operations mychardev_fops = {\n    .owner      = THIS_MODULE,\n    .open       = mychardev_open,\n    .release    = mychardev_release,\n    .unlocked_ioctl = mychardev_ioctl,\n    .read       = mychardev_read,\n    .write       = mychardev_write\n};\n\n\/\/ device data holder, this structure may be extended to hold additional data\nstruct mychar_device_data {\n    struct cdev cdev;\n};\n\n\/\/ global storage for device Major number\nstatic int dev_major = 0;\n\n\/\/ sysfs class structure\nstatic struct class *mychardev_class = NULL;\n\n\/\/ array of mychar_device_data for\nstatic struct mychar_device_data mychardev_data[MAX_DEV];\n\nvoid mychardev_init(void)\n{\n    int err, i;\n    dev_t dev;\n\n    \/\/ allocate chardev region and assign Major number\n    err = alloc_chrdev_region(&amp;dev, 0, MAX_DEV, \"mychardev\");\n\n    dev_major = MAJOR(dev);\n\n    \/\/ create sysfs class\n    mychardev_class = class_create(THIS_MODULE, \"mychardev\");\n\n    \/\/ Create necessary number of the devices\n    for (i = 0; i &lt; MAX_DEV; i++) {\n        \/\/ init new device\n        cdev_init(&amp;mychardev_data[i].cdev, &amp;mychardev_fops);\n        mychardev_data[i].cdev.owner = THIS_MODULE;\n\n        \/\/ add device to the system where \"i\" is a Minor number of the new device\n        cdev_add(&amp;mychardev_data[i].cdev, MKDEV(dev_major, i), 1);\n\n        \/\/ create device node \/dev\/mychardev-x where \"x\" is \"i\", equal to the Minor number\n        device_create(mychardev_class, NULL, MKDEV(dev_major, i), NULL, \"mychardev-%d\", i);\n    }\n}<\/pre>\n<p>You can find a few new things in this example. The creation of the sysfs class is a necessary part of the device node creation.<br \/>\nFunction class_create(THIS_MODULE, &#8220;mychardev&#8221;) creates sysfs class with paths for each character devices:<\/p>\n<pre class=\"prettyprint\">$ tree \/sys\/devices\/virtual\/mychardev\/\n\/sys\/devices\/virtual\/mychardev\/\n\u251c\u2500\u2500 mychardev-0\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 dev\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 power\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 async\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 autosuspend_delay_ms\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 control\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 runtime_active_kids\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 runtime_active_time\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 runtime_enabled\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 runtime_status\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 runtime_suspended_time\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 runtime_usage\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 subsystem -&gt; ..\/..\/..\/..\/class\/mychardev\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 uevent\n\u2514\u2500\u2500 mychardev-1\n    \u251c\u2500\u2500 dev\n    \u251c\u2500\u2500 power\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 async\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 autosuspend_delay_ms\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 control\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 runtime_active_kids\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 runtime_active_time\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 runtime_enabled\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 runtime_status\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 runtime_suspended_time\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 runtime_usage\n    \u251c\u2500\u2500 subsystem -&gt; ..\/..\/..\/..\/class\/mychardev\n    \u2514\u2500\u2500 uevent<\/pre>\n<p><strong>Sysfs<\/strong> can be used as an additional way to interact with userspace. Setting up some driver params, for example.<br \/>\nAnother useful thing &#8211; configure <strong>UDEV<\/strong> variables to set up correct permissions to the character device.<br \/>\nThis can be done by setting uevent callback to sysfs class.<\/p>\n<pre class=\"prettyprint\">static int mychardev_uevent(struct device *dev, struct kobj_uevent_env *env)\n{\n    add_uevent_var(env, \"DEVMODE=%#o\", 0666);\n    return 0;\n}\n\n...\n\nmychardev_class = class_create(THIS_MODULE, \"mychardev\");\nmychardev_class-&gt;dev_uevent = mychardev_uevent;<\/pre>\n<p>Now we got &#8220;<em>rw-rw-rw-<\/em>&#8221; permissions on each mychardev.<\/p>\n<pre class=\"prettyprint\">$ ls -l \/dev\/mychardev-*\ncrw-rw-rw- 1 root root 246, 0 Mar 14 12:24 \/dev\/mychardev-0\ncrw-rw-rw- 1 root root 246, 1 Mar 14 12:24 \/dev\/mychardev-1\n<\/pre>\n<p>Every user can read and write.<\/p>\n<p>When a character device is no longer required it must be properly destroyed.<\/p>\n<pre class=\"prettyprint\">void mychardev_destroy(void)\n{\n    int i;\n\n    for (i = 0; i &lt; MAX_DEV; i++) {\n        device_destroy(mychardev_class, MKDEV(dev_major, i));\n    }\n\n    class_unregister(mychardev_class);\n    class_destroy(mychardev_class);\n\n    unregister_chrdev_region(MKDEV(dev_major, 0), MINORMASK);\n}<\/pre>\n<h2>Device I\/O functions<\/h2>\n<p>To interact with your device file, we need to set a few functions to the <strong>struct file_operations.<\/strong><\/p>\n<pre class=\"prettyprint\">static int mychardev_open(struct inode *inode, struct file *file)\n{\n    printk(\"MYCHARDEV: Device open\\n\");\n    return 0;\n}\n\nstatic int mychardev_release(struct inode *inode, struct file *file)\n{\n    printk(\"MYCHARDEV: Device close\\n\");\n    return 0;\n}\n\nstatic long mychardev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n    printk(\"MYCHARDEV: Device ioctl\\n\");\n    return 0;\n}\n\nstatic ssize_t mychardev_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\n{\n    printk(\"MYCHARDEV: Device read\\n\");\n    return 0;\n}\n\nstatic ssize_t mychardev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)\n{\n    printk(\"MYCHARDEV: Device write\\n\");\n    return 0;\n}<\/pre>\n<p>Now we can handle I\/O requests.<br \/>\nIf build and load the kernel module with this code and then run &#8220;<em>cat \/dev\/mychardev-0<\/em>&#8221; these messages will be printed in dmesg:<\/p>\n<pre class=\"prettyprint\">$ cat \/dev\/mychardev-0 \n\n$ sudo tail -n3 \/var\/log\/messages\nMar 14 12:52:46 oleg-lab kernel: [244801.849652] MYCHARDEV: Device open\nMar 14 12:52:46 oleg-lab kernel: [244801.849665] MYCHARDEV: Device read\nMar 14 12:52:46 oleg-lab kernel: [244801.849672] MYCHARDEV: Device close\n<\/pre>\n<p>It&#8217;s working.<\/p>\n<p>To transfer some real data within <code>read<\/code>\/<code>write<\/code> requests, we need to use special kernel functionality.<br \/>\nIt&#8217;s very dangerous or even impossible to do simple memory copying using *buf pointers.<br \/>\nSafe way is to use <strong>copy_to_user()<\/strong> and <strong>copy_from_user()<\/strong><\/p>\n<pre class=\"prettyprint\">#include &lt;linux\/uaccess.h&gt;\n\nunsigned long copy_to_user(void __user *to, const void *from, unsigned long n);\nunsigned long copy_from_user(void *to, const void __user *from, unsigned long n);\n<\/pre>\n<p>These functions perform additional checks of the permissions and memory regions before actual data access.<\/p>\n<p>Let&#8217;s modify our <strong>mychardev_read().<\/strong><\/p>\n<pre class=\"prettyprint\">static ssize_t mychardev_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\n{\n    uint8_t *data = \"Hello from the kernel world!\\n\";\n    size_t datalen = strlen(data);\n\n    if (count &gt; datalen) {\n        count = datalen;\n    }\n\n    if (copy_to_user(buf, data, count)) {\n        return -EFAULT;\n    }\n\n    return count;\n}\n\n<\/pre>\n<p>It&#8217;s always important to check how many bytes users want to read. If this size exceeds the prepared data&#8217;s actual size &#8211; the user can read the kernel stack what can be a hole in the system security.<\/p>\n<p>Now let&#8217;s try to read 29 bytes from our character device.<\/p>\n<pre class=\"prettyprint\">$ head -c29 \/dev\/mychardev-1 \nHello from the kernel world!\n<\/pre>\n<p>Of course, we can send to the user space not only strings but any other raw data structures.<\/p>\n<p>Now <strong>mychardev_write().<\/strong><\/p>\n<pre class=\"prettyprint\">static ssize_t mychardev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)\n{\n    size_t maxdatalen = 30, ncopied;\n    uint8_t databuf[maxdatalen];\n\n    if (count &lt; maxdatalen) {\n        maxdatalen = count;\n    }\n\n    ncopied = copy_from_user(databuf, buf, maxdatalen);\n\n    if (ncopied == 0) {\n        printk(\"Copied %zd bytes from the user\\n\", maxdatalen);\n    } else {\n        printk(\"Could't copy %zd bytes from the user\\n\", ncopied);\n    }\n\n    databuf[maxdatalen] = 0;\n\n    printk(\"Data from the user: %s\\n\", databuf);\n\n    return count;\n}\n<\/pre>\n<p>It&#8217;s also very important to verify how many bytes sending users and how many bytes we can accept.<\/p>\n<p>Function copy_from_user returns the number of bytes that could not be copied. On success, this will be zero.<br \/>\nIf some data could not be copied, this function will pad the copied data to the requested size using zero bytes.<\/p>\n<p>Test:<\/p>\n<pre class=\"prettyprint\">$ echo \"Hello from the user\" &gt; \/dev\/mychardev-1\n\n$ sudo tail -n5 \/var\/log\/messages\nMar 14 15:57:14 oleg-lab kernel: [255870.547447] MYCHARDEV: Device open\nMar 14 15:57:14 oleg-lab kernel: [255870.547466] Copied 20 bytes from the user\nMar 14 15:57:14 oleg-lab kernel: [255870.547468] Data from the user: Hello from the user\nMar 14 15:57:14 oleg-lab kernel: [255870.547468] \nMar 14 15:57:14 oleg-lab kernel: [255870.547472] MYCHARDEV: Device close\n\n<\/pre>\n<p>You may ask how to identify which device (mychardev-0 or mychardev-1) is used in a specific I\/O process?<br \/>\nSince our Minor numbers are the same as device names we can get <code>Minor number<\/code> from the file inode using <strong>struct file<\/strong>.<\/p>\n<pre class=\"prettyprint\">MINOR(file-&gt;f_path.dentry-&gt;d_inode-&gt;i_rdev)\n<\/pre>\n<p>Let&#8217;s print this value in the <strong>read<\/strong> and <strong>write<\/strong> functions and see what happens.<\/p>\n<pre class=\"prettyprint\">...\nprintk(\"Reading device: %d\\n\", MINOR(file-&gt;f_path.dentry-&gt;d_inode-&gt;i_rdev));\n\n...\nprintk(\"Writing device: %d\\n\", MINOR(file-&gt;f_path.dentry-&gt;d_inode-&gt;i_rdev));<\/pre>\n<p>Result:<\/p>\n<pre class=\"prettyprint\">$ echo \"Hello from the user\" &gt; \/dev\/mychardev-0\n\ndmesg\nMar 14 16:02:08 oleg-lab kernel: [256164.495609] Writing device: 0\n\n\n$ echo \"Hello from the user\" &gt; \/dev\/mychardev-1\n\ndmesg\nMar 14 16:02:08 oleg-lab kernel: [256164.495609] Writing device: 1<\/pre>\n<p>Few notes about ioctl.<\/p>\n<pre class=\"prettyprint\">static long mychardev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)<\/pre>\n<p>This utility function is used to pass some CMD as the number and some optional data as ARG.<\/p>\n<p>You need to define some magic numbers used as CMD (and probably as ARG) somewhere in a separate header file, shared between driver code and user application code.<\/p>\n<p>All implementation of the ioctl function is a simple switch case routine where you do something depending on the sent CMD.<\/p>\n<p>Now <strong>a complete example<\/strong> of the Linux kernel module, which implements everything that we were discussed here.<\/p>\n<pre class=\"prettyprint\">#include &lt;linux\/init.h&gt;\n#include &lt;linux\/module.h&gt;\n#include &lt;linux\/cdev.h&gt;\n#include &lt;linux\/device.h&gt;\n#include &lt;linux\/kernel.h&gt;\n#include &lt;linux\/uaccess.h&gt;\n#include &lt;linux\/fs.h&gt;\n\n#define MAX_DEV 2\n\nstatic int mychardev_open(struct inode *inode, struct file *file);\nstatic int mychardev_release(struct inode *inode, struct file *file);\nstatic long mychardev_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\nstatic ssize_t mychardev_read(struct file *file, char __user *buf, size_t count, loff_t *offset);\nstatic ssize_t mychardev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset);\n\nstatic const struct file_operations mychardev_fops = {\n    .owner      = THIS_MODULE,\n    .open       = mychardev_open,\n    .release    = mychardev_release,\n    .unlocked_ioctl = mychardev_ioctl,\n    .read       = mychardev_read,\n    .write       = mychardev_write\n};\n\nstruct mychar_device_data {\n    struct cdev cdev;\n};\n\nstatic int dev_major = 0;\nstatic struct class *mychardev_class = NULL;\nstatic struct mychar_device_data mychardev_data[MAX_DEV];\n\nstatic int mychardev_uevent(struct device *dev, struct kobj_uevent_env *env)\n{\n    add_uevent_var(env, \"DEVMODE=%#o\", 0666);\n    return 0;\n}\n\nstatic int __init mychardev_init(void)\n{\n    int err, i;\n    dev_t dev;\n\n    err = alloc_chrdev_region(&amp;dev, 0, MAX_DEV, \"mychardev\");\n\n    dev_major = MAJOR(dev);\n\n    mychardev_class = class_create(THIS_MODULE, \"mychardev\");\n    mychardev_class-&gt;dev_uevent = mychardev_uevent;\n\n    for (i = 0; i &lt; MAX_DEV; i++) {\n        cdev_init(&amp;mychardev_data[i].cdev, &amp;mychardev_fops);\n        mychardev_data[i].cdev.owner = THIS_MODULE;\n\n        cdev_add(&amp;mychardev_data[i].cdev, MKDEV(dev_major, i), 1);\n\n        device_create(mychardev_class, NULL, MKDEV(dev_major, i), NULL, \"mychardev-%d\", i);\n    }\n\n    return 0;\n}\n\nstatic void __exit mychardev_exit(void)\n{\n    int i;\n\n    for (i = 0; i &lt; MAX_DEV; i++) {\n        device_destroy(mychardev_class, MKDEV(dev_major, i));\n    }\n\n    class_unregister(mychardev_class);\n    class_destroy(mychardev_class);\n\n    unregister_chrdev_region(MKDEV(dev_major, 0), MINORMASK);\n}\n\nstatic int mychardev_open(struct inode *inode, struct file *file)\n{\n    printk(\"MYCHARDEV: Device open\\n\");\n    return 0;\n}\n\nstatic int mychardev_release(struct inode *inode, struct file *file)\n{\n    printk(\"MYCHARDEV: Device close\\n\");\n    return 0;\n}\n\nstatic long mychardev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n    printk(\"MYCHARDEV: Device ioctl\\n\");\n    return 0;\n}\n\nstatic ssize_t mychardev_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\n{\n    uint8_t *data = \"Hello from the kernel world!\\n\";\n    size_t datalen = strlen(data);\n\n    printk(\"Reading device: %d\\n\", MINOR(file-&gt;f_path.dentry-&gt;d_inode-&gt;i_rdev));\n\n    if (count &gt; datalen) {\n        count = datalen;\n    }\n\n    if (copy_to_user(buf, data, count)) {\n        return -EFAULT;\n    }\n\n    return count;\n}\n\nstatic ssize_t mychardev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)\n{\n    size_t maxdatalen = 30, ncopied;\n    uint8_t databuf[maxdatalen];\n\n    printk(\"Writing device: %d\\n\", MINOR(file-&gt;f_path.dentry-&gt;d_inode-&gt;i_rdev));\n\n    if (count &lt; maxdatalen) {\n        maxdatalen = count;\n    }\n\n    ncopied = copy_from_user(databuf, buf, maxdatalen);\n\n    if (ncopied == 0) {\n        printk(\"Copied %zd bytes from the user\\n\", maxdatalen);\n    } else {\n        printk(\"Could't copy %zd bytes from the user\\n\", ncopied);\n    }\n\n    databuf[maxdatalen] = 0;\n\n    printk(\"Data from the user: %s\\n\", databuf);\n\n    return count;\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Oleg Kutkov &lt;elenbert@gmail.com&gt;\");\n\nmodule_init(mychardev_init);\nmodule_exit(mychardev_exit);\n<\/pre>\n<p>And <strong>Makefile<\/strong> to build this code.<\/p>\n<pre class=\"prettyprint\">BINARY     := mychardev\nKERNEL      := \/lib\/modules\/$(shell uname -r)\/build\nARCH        := x86\nC_FLAGS     := -Wall\nKMOD_DIR    := $(shell pwd)\nTARGET_PATH := \/lib\/modules\/$(shell uname -r)\/kernel\/drivers\/char\n\nOBJECTS := main.o\n\nccflags-y += $(C_FLAGS)\n\nobj-m += $(BINARY).o\n\n$(BINARY)-y := $(OBJECTS)\n\n$(BINARY).ko:\n    make -C $(KERNEL) M=$(KMOD_DIR) modules\n\ninstall:\n    cp $(BINARY).ko $(TARGET_PATH)\n    depmod -a\n\nuninstall:\n    rm $(TARGET_PATH)\/$(BINARY).ko\n    depmod -a\n\nclean:\n    make -C $(KERNEL) M=$(KMOD_DIR) clean<\/pre>\n<p>Module building and loading<\/p>\n<pre class=\"prettyprint\">make &amp;&amp; sudo insmod mychardev.ko<\/pre>\n<p>You should find two new devices: \/dev\/mychardev-0 and \/dev\/mychardev-1, and repeat all experiments from this article.<\/p>\n<p>I hope this material will be helpful.<br \/>\nThis code can be used as a basic pattern in some more complex driver project.<\/p>\n<p>Thanks for reading!<\/p>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n","protected":false},"excerpt":{"rendered":"<p>A character device is one of the simplest ways to communicate with a module in the Linux kernel. These devices are presented as special files in a \/dev directory and support direct reading and writing of any data, byte by byte, like a stream. Actually, most of the pseudo-devices in \/dev are character devices: serial [&hellip;]<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[25],"tags":[38,41,39,40,27],"_links":{"self":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/359"}],"collection":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/comments?post=359"}],"version-history":[{"count":26,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/359\/revisions"}],"predecessor-version":[{"id":1754,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/359\/revisions\/1754"}],"wp:attachment":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/media?parent=359"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/categories?post=359"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/tags?post=359"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}