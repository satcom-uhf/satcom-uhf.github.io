{"id":1104,"date":"2020-02-10T03:28:46","date_gmt":"2020-02-10T00:28:46","guid":{"rendered":"https:\/\/olegkutkov.me\/?p=1104"},"modified":"2021-02-06T01:56:41","modified_gmt":"2021-02-05T23:56:41","slug":"linux-block-device-driver","status":"publish","type":"post","link":"https:\/\/olegkutkov.me\/2020\/02\/10\/linux-block-device-driver\/","title":{"rendered":"Linux block device driver"},"content":{"rendered":"<p><img loading=\"lazy\" decoding=\"async\" class=\"alignleft size-full wp-image-1105\" src=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2020\/01\/blk_dev_icon.png\" alt=\"\" width=\"150\" height=\"130\" \/> My <a href=\"https:\/\/olegkutkov.me\/2018\/03\/14\/simple-linux-character-device-driver\/\">article<\/a> about character devices is quite popular, so I decided to write something about another big class of devices in Linux &#8211; block devices.<br \/>\nThis type of device is used to access various storage hardware types &#8211; hard disks, SSD, etc.<br \/>\nHere I want to describe blk-mq based devices in modern (&gt;= 5.0) Linux kernels and a previous type of device for a bit older but still actual kernels.<\/p>\n<p><!--more--><\/p>\n<h3>Block devices vs. Character devices<\/h3>\n<p>Character devices are typically called streams. It&#8217;s really a stream of bytes. We can read bytes one by one or by chunks, but we can&#8217;t do &#8216;seek&#8217; on the data and access random position in a stream. Data is not buffered. Access is almost real-time. Examples of character devices: serial ports and parallel ports, sound cards, pseudo-devices like <em>\/dev\/random<\/em>.<\/p>\n<p>Block devices are always buffering data i\/o and support random access. You can seek any position and read (or write) any portion of the data. This is the actual representation of the storage devices\u2014examples of block devices: disks (mostly), USB cameras, etc.<br \/>\nAdditionally, the I\/O process of the block device may be managed by some scheduler to optimize system load and data access time.<\/p>\n<p>Please note that this is not a strict rule. Also, it&#8217;s not common for all operating systems. FreeBSD doesn&#8217;t use block devices at all, for example. In Linux, it&#8217;s possible to use a block device as a character device using a special <a href=\"https:\/\/en.wikipedia.org\/wiki\/Raw_device\">RAW driver<\/a>, but it&#8217;s now deprecated.<\/p>\n<h3>Single queue and multi-queue<\/h3>\n<p>Originally Linux block devices were designed for the HDD with spinning discs and moving heads. Such hardware cannot support parallel access to the different chunks of data on separate disc sectors. Some scheduler is required, and the device supports only a single queue for <code>read<\/code> and <code>write<\/code> requests. This is the Linux kernel block device framework.<\/p>\n<p>Modern SSD devices support fast random access and may serve multiple I\/O requests. For such a purpose, the kernel supports a new framework &#8211; blk-mq with multiple queues.<\/p>\n<p>You get more information about blk-mq <a href=\"https:\/\/yarondar.wordpress.com\/2018\/07\/29\/have-you-tried-blk-mq\/\">in this nice article<\/a>.<\/p>\n<p><a href=\"https:\/\/arxiv.org\/pdf\/1504.07481.pdf\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-1113 size-full\" src=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2020\/02\/blk_vs_blk-mq.png\" alt=\"\" width=\"695\" height=\"788\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2020\/02\/blk_vs_blk-mq.png 695w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2020\/02\/blk_vs_blk-mq-265x300.png 265w\" sizes=\"(max-width: 695px) 100vw, 695px\" \/><\/a><a href=\"https:\/\/arxiv.org\/pdf\/1504.07481.pdf\">Image source: https:\/\/arxiv.org\/pdf\/1504.07481.pdf<\/a><\/p>\n<p>This framework was introduced in Linux kernel versions 4.x, but since version 5.0 blk-mq is default and the old framework was removed. All drivers should be rewritten.<br \/>\nOf course, blk-mq supports single queue mode, so there are no compatibility problems.<\/p>\n<p>My machine is equipped with SSD and running Linux kernel version 5.3.0, so I will focus mostly on blk-mq. I will provide some examples for the legacy framework.<\/p>\n<h3>Basic structures<\/h3>\n<h6><strong>struct gendisk<\/strong><\/h6>\n<p>Introduced in kernel 2.4, <strong>gendisk<\/strong> structure is at the core of the block subsystem.<br \/>\nThis structure represents a disk device and holds all necessary information like device name, queues, user, and system data.<\/p>\n<p>Here is <strong>gendisk<\/strong> structure from the 5.3 kernels. As you can see, this structure is quite clear and well-documented.<\/p>\n<pre class=\"prettyprint\">struct gendisk {\n    \/* major, first_minor and minors are input parameters only,\n     * don't use directly.  Use disk_devt() and disk_max_parts().\n     *\/\n    int major;          \/* major number of driver *\/\n    int first_minor;\n    int minors;                     \/* maximum number of minors, =1 for\n                                         * disks that can't be partitioned. *\/\n\n    char disk_name[DISK_NAME_LEN];  \/* name of major driver *\/\n    char *(*devnode)(struct gendisk *gd, umode_t *mode);\n\n    unsigned short events;      \/* supported events *\/\n    unsigned short event_flags; \/* flags related to event processing *\/\n\n    \/* Array of pointers to partitions indexed by partno.\n     * Protected with matching bdev lock but stat and other\n     * non-critical accesses use RCU.  Always access through\n     * helpers.\n     *\/\n    struct disk_part_tbl __rcu *part_tbl;\n    struct hd_struct part0;\n\n    const struct block_device_operations *fops;\n    struct request_queue *queue;\n    void *private_data;\n\n    int flags;\n    struct rw_semaphore lookup_sem;\n    struct kobject *slave_dir;\n\n    struct timer_rand_state *random;\n    atomic_t sync_io;       \/* RAID *\/\n    struct disk_events *ev;\n#ifdef  CONFIG_BLK_DEV_INTEGRITY\n    struct kobject integrity_kobj;\n#endif \/* CONFIG_BLK_DEV_INTEGRITY *\/\n    int node_id;\n    struct badblocks *bb;\n    struct lockdep_map lockdep_map;\n};<\/pre>\n<p>The kernel provides sets of the function for allocation, deallocation of the <strong>gendisk<\/strong>, and adding\/removing disks. Most important is:<\/p>\n<pre><strong>struct gendisk *alloc_disk(int minors)\u00a0<\/strong> - allocate new gendisk structure, minors is the maximum number of minor numbers (partitions) that this disk can have.\n\n<strong>void add_disk(struct gendisk *disk)\u00a0<\/strong> - add new disk to the system. Please note that gendisk structure must be initialized before adding new disk.\n\n<strong>void set_capacity(struct gendisk *disk, sector_t size)<\/strong>\u00a0 - specify capacity (in sectors) of the new disk;\n\n<strong>void del_gendisk(struct gendisk *gp)\u00a0<\/strong> - delete disk from the system.\n\n<strong>void put_disk(struct gendisk *disk)\u00a0<\/strong> - release memory allocated in alloc_disk(int minors);<\/pre>\n<p>Typical initialization routine of the <strong>gendisk<\/strong> structure is setting disk name, setting flags, initialization I\/O queue, and setting driver private data.<br \/>\nThis procedure is common for all kernel versions. The major difference is queue initialization. It&#8217;s different for blk-mq and older frameworks.<\/p>\n<p>It&#8217;s important to register a new block device with a new major number.<\/p>\n<pre><strong>int register_blkdev(unsigned int major, const char * name)<\/strong> - register a new block device, if major is 0 kernel will try to allocate any unused major number.<\/pre>\n<p><strong>gendisk<\/strong> initialization (actually full disc block device initialization) code for the kernel <strong>versions 4.x<\/strong> (single queue):<\/p>\n<pre class=\"prettyprint\">#include &lt;linux\/genhd.h&gt;\n#include &lt;linux\/blkdev.h&gt;\n\nvoid block_dev_init()\n{\n    spinlock_t *lk;  \/* Main lock for the device *\/\n    struct gendisk *gdisk;\n    int major_number = register_blkdev(0, \"testblk\");\n\n    gdisk = alloc_disk(1);\n\n    if (!gdisk) {\n        return;\n    }\n\n    spin_lock_init(&amp;lk);\n\n    snprintf(gdisk-&gt;disk_name, 8, \"blockdev\");  \/* Block device file name: \"\/dev\/blockdev\" *\/\n\n    gdisk-&gt;flags = GENHD_FL_NO_PART_SCAN;  \/* Kernel won't scan for partitions on the new disk *\/\n    gdisk-&gt;major = major_number;\n    gdisk-&gt;fops = &amp;blockdev_ops;  \/* Block device file operations, see below *\/\n    gdisk-&gt;first_minor = 0;\n\n    gdisk-&gt;queue = blk_init_queue(req_fun, &amp;lk);  \/* Init I\/O queue, see below *\/\n\n    set_capacity(block_device-&gt;gdisk, 1024 * 512);  \/* Set some random capacity, 1024 sectors (with size of 512 bytes) *\/\n\n    add_disk(gdisk);\n}<\/pre>\n<p><strong>gendisk<\/strong> file options are sets functions for the device file operations, like on character devices.<br \/>\nYou should specify open, close, and <strong>ioctl<\/strong> functions. You can do whatever you want in the <code>open<\/code>\/<code>close<\/code> functions. <strong>Some software may use ioctl requests<\/strong> to get disk geometry and some other capabilities. Nowadays, it&#8217;s optional.<\/p>\n<pre class=\"prettyprint\">#include &lt;linux\/fs.h&gt;\n\nint blockdev_open(struct block_device *dev, fmode_t mode)\n{\n    printk(\"Device %s opened\"\\n, dev-&gt;bd_disk-&gt;disk_name);\n    return 0;\n}\n\nvoid blockdev_release(struct gendisk *gdisk, fmode_t mode)\n{\n    printk(\"Device %s closed\"\\n, dev-&gt;bd_disk-&gt;disk_name);\n}\n\nint blockdev_ioctl (struct block_device *dev, fmode_t mode, unsigned cmd, unsigned long arg)\n{\n    return -ENOTTY; \/* ioctl not supported *\/\n}\n\nstatic struct block_device_operations blockdev_ops = {\n    .owner = THIS_MODULE,\n    .open = blockdev_open,\n    .release = blockdev_release,\n    .ioctl = blockdev_ioctl\n};<\/pre>\n<p>In this example, only one flag is used &#8211; GENHD_FL_NO_PART_SCAN. This flag forbids the kernel to scan for partitions on the new block devices. Sure our example block device can&#8217;t serve any partitions like real hardware.<br \/>\nYou can check this Linux kernel header file to get more info about available flags: <em><strong>include\/linux\/genhd.h<\/strong><\/em><\/p>\n<p>Function <strong>blk_init_queue<\/strong> is used to initialize a single I\/O queue for the device.<br \/>\nThis function is quite simple to use. Only two arguments are required:<\/p>\n<pre><strong>struct request_queue * blk_init_queue (request_fn_proc * rfn, spinlock_t * lock);<\/strong><\/pre>\n<p><strong>request_fn_proc<\/strong> is a function to be called to process requests that have been placed in the queue.<\/p>\n<p>Here is a declaration of this function:<\/p>\n<pre><strong>void request_fn_proc(struct request_queue *q);<\/strong><\/pre>\n<p>Only one argument with an actual request to process.<\/p>\n<p>Using <code>request_queue<\/code> we can fetch requests from the queue, check the direction (READ or WRITE) of the new request, and get data buffer to transfer.<\/p>\n<p>An elementary example of the <strong>request_fn_proc<\/strong>:<\/p>\n<pre class=\"prettyprint\">static void block_request(struct request_queue *q)\n{\n    int direction;\n    int err = -EIO;\n    u8 *data;\n    struct request *req = blk_fetch_request(q); \/* get one top request from the queue *\/\n\n    while (req) {\n        if (__blk_end_request_cur(req, err)) {  \/* check for the end *\/\n            break;\n        }\n\n        \/* Data processing *\/\n\n        direction = rq_data_dir(req);\n\n        if (direction == WRITE) {\n            printk(\"Writing data to the block device\\n\");\n        } else {\n            printk(\"Reading data from the block devicen\\n\");\n        }\n\n        data = bio_data(req-&gt;bio); \/* Data buffer to perform I\/O operations *\/\n\n        \/* *\/\n\n        req = blk_fetch_request(q); \/* get next request from the queue *\/\n    }\n}<\/pre>\n<p>Please note that with real hardware, we really need to deal with sectors, current positions, etc.<br \/>\nFor this purpose we can use functions like this: <strong>blk_rq_pos(req)<\/strong>, <strong>blk_rq_cur_sectors(req)<\/strong>, <strong>blk_rq_cur_bytes(req)<\/strong> and so on.<br \/>\nPlease check this Linux kernel header file to find more functions: <em><strong>include\/linux\/blkdev.h<\/strong><\/em><br \/>\nThis code is well commented.<\/p>\n<h4>blk-mq and kernels &gt;= 5.0<\/h4>\n<p>Now it&#8217;s time to switch to the blk-mq framework.<br \/>\nYou can use the previous example almost as-is. Only one thing is changing here &#8211; queue initialization.<\/p>\n<p>With blk-mq we need to use more complex <strong>blk_mq_init_sq_queue<\/strong> function.<\/p>\n<pre><strong>struct request_queue *blk_mq_init_sq_queue(struct blk_mq_tag_set *set,<\/strong>\n<strong>                        const struct blk_mq_ops *ops,<\/strong>\n<strong>                        unsigned int queue_depth,<\/strong>\n<strong>                        unsigned int set_flags);<\/strong><\/pre>\n<p>struct <strong>blk_mq_tag_set<\/strong> is a utility structure to store all params like driver private data, commands size, max queue depth, and so on.<br \/>\nThis structure is initializing inside <strong>blk_mq_init_sq_queue<\/strong> using other params of the function, which we&#8217;ll see later.<\/p>\n<pre class=\"prettyprint\">struct blk_mq_tag_set {\n    \/*\n     * map[] holds ctx -&gt; hctx mappings, one map exists for each type\n     * that the driver wishes to support. There are no restrictions\n     * on maps being of the same size, and it's perfectly legal to\n     * share maps between types.\n     *\/\n    struct blk_mq_queue_map map[HCTX_MAX_TYPES];\n    unsigned int        nr_maps;    \/* nr entries in map[] *\/\n    const struct blk_mq_ops *ops;\n    unsigned int        nr_hw_queues;   \/* nr hw queues across maps *\/\n    unsigned int        queue_depth;    \/* max hw supported *\/\n    unsigned int        reserved_tags;\n    unsigned int        cmd_size;   \/* per-request extra data *\/\n    int         numa_node;\n    unsigned int        timeout;\n    unsigned int        flags;      \/* BLK_MQ_F_* *\/\n    void            *driver_data;\n\n    struct blk_mq_tags  **tags;\n\n    struct mutex        tag_list_lock;\n    struct list_head    tag_list;\n};<\/pre>\n<p>Most of the fields are optional, and you can leave it as-is if you don&#8217;t (or can&#8217;t) really want to set some values.<\/p>\n<p><strong>struct blk_mq_ops<\/strong> it&#8217;s a set of the function pointers. You can find a declaration of this structure in the Linux kernel header: <em><strong>include\/linux\/blk-mq.h<\/strong><\/em><\/p>\n<p>In the simplest cases, drivers must define <strong>queue_rq<\/strong> function to serve I\/O requests. This is equivalent to <strong>request_fn_proc<\/strong> in the example above.<\/p>\n<p>Here is an example of the queue_rq function. Let&#8217;s discover how it works:<\/p>\n<pre class=\"prettyprint\">#include &lt;linux\/blk-mq.h&gt;\n\nint do_request(struct request *rq, unsigned int *nr_bytes)\n{\n    struct bio_vec bvec;\n    struct req_iterator iter;\n    loff_t pos = blk_rq_pos(rq) &lt;&lt; SECTOR_SHIFT; \/* Required position for the Read or Write *\/\n    void* data;\n    unsigned long data_len;\n\n    \/* Iterate over reuquests in the queue *\/    \n    rq_for_each_segment(bvec, rq, iter)\n    {\n        data = page_address(bvec.bv_page) + bvec.bv_offset; \/* Get I\/O data *\/\n        data_len = bvec.bv_len; \/* Length of the data buffer *\/\n\n        if (rq_data_dir(rq) == WRITE) {\n            printk(\"Writing data to the blk-mq device\\n\");\n        } else {\n            printk(\"Reading data from the blk-mq device\\n\");\n        }\n\n        pos += b_len;\n        *nr_bytes += data_len;  \/* Increment amount of the processed bytes. *\/\n    }\n\n    return 0;\n}\n\n\/* Simple example of the blk-mq I\/O function *\/\nblk_status_t queue_rq(struct blk_mq_hw_ctx *hctx, const struct blk_mq_queue_data* bd)\n{   \n    unsigned int nr_bytes = 0;\n    blk_status_t status = BLK_STS_OK;\n    struct request *rq = bd-&gt;rq;  \/* Get one top request *\/\n\n    \/* \n        Start new request procedure.\n        Please note that this function sets a timer for the data transaction. \n        This internal timer is used to measure request processing time and to detect problems with hardware. \n    *\/\n    blk_mq_start_request(rq);\n\n    \/* Serve request *\/     \n    if (do_request(rq, &amp;nr_bytes) != 0) {\n        status = BLK_STS_IOERR;\n    }\n\n    \/* Notify blk-mq about processed bytes *\/\n    if (blk_update_request(rq, status, nr_bytes)) {\n        BUG();\n    }\n\n    \/* End request procedure *\/     \n    __blk_mq_end_request(rq, status);\n     \n    return status;\n}\n\n\/* Set I\/O function *\/\nstatic struct blk_mq_ops mq_ops = {\n    .queue_rq = queue_rq,\n};\n\nvoid block_dev_init()\n{\n    struct blk_mq_tag_set tag_set;\n\n    \/* *\/\n\n    \/* Create new queue with depth 128 and with on flag to enable queues merging. *\/\n    gdisk-&gt;queue = blk_mq_init_sq_queue(&amp;tag_set, &amp;mq_ops, 128, BLK_MQ_F_SHOULD_MERGE);\n\n    \/* *\/\n}\n<\/pre>\n<p>As you can blk-mq code is much complex, you can find some similarities with the example above. You can see additional request start\/stop routines that can help the kernel track request execution time and detect a stuck block device.<\/p>\n<p>In both examples, we are getting data I\/O buffer. In the real driver&#8217;s case, all data from this buffer should be transferred to (or read from) the hardware. You can use additional buffering here if it&#8217;s required and doesn&#8217;t break performance.<br \/>\nIn the virtual block device driver (like our example), you can also use a memory buffer to simulate real hardware. The size of this buffer must be equal to devise capacity, which was set in <strong>set_capacity()<\/strong>;<\/p>\n<p>It&#8217;s safe to use simple <strong>memcpy()<\/strong>. The kernel block device subsystem handles all nuances of copying to the user and copying from the user.<\/p>\n<h3>Under the blk_mq_init_sq_queue()<\/h3>\n<p>Let&#8217;s dig down a little bit to see how <strong>blk_mq_init_sq_queue()<\/strong> is implemented.<\/p>\n<p>This function is simple wrapper for <strong>blk_mq_init_queue()<\/strong> which is used initialized <strong>blk_mq_tag_set<\/strong> as only one argument. Structure <strong>tag_set<\/strong> is initialized at the beginning of the function using arguments.<\/p>\n<pre class=\"prettyprint\">     \/* Initialize passed tag_set *\/\n    memset(set, 0, sizeof(*set));\n    set-&gt;ops = ops;     \/* Set options *\/\n    set-&gt;nr_hw_queues = 1;  \/* Number of the hw queues is 1 *\/\n    set-&gt;nr_maps = 1;   \n    set-&gt;queue_depth = queue_depth; \/* Depth of the queue *\/\n    set-&gt;numa_node = NUMA_NO_NODE;\n    set-&gt;flags = set_flags;     \/* Set options *\/<\/pre>\n<p>The next step is sanity check and initialization of the additional data. The blk_mq_alloc_tag_set does this.<\/p>\n<p>This function is quite long, and I don&#8217;t want to post it here. You can check the source code (kernel version 5.3) <a href=\"https:\/\/elixir.bootlin.com\/linux\/v5.3\/source\/block\/blk-mq.c#L3023\">here<\/a>. As you can see, this function mostly doing parameter checks and memory allocations.<\/p>\n<p>And the final step is the creation of the actual queue using <strong>blk_mq_init_queue(), <\/strong>which requires configured and allocated <strong>tag_set<\/strong>;<br \/>\n<!--?prettify linenums=true?--><\/p>\n<pre class=\"prettyprint\">    struct request_queue *q = blk_mq_init_queue(set);\n    return q;<\/pre>\n<p>This function is a simple wrapper around <a href=\"https:\/\/elixir.bootlin.com\/linux\/v5.3\/source\/block\/blk-core.c#L472\">blk_alloc_queue_node<\/a> and <a href=\"https:\/\/elixir.bootlin.com\/linux\/v5.3\/source\/block\/blk-mq.c#L2841\">blk_mq_init_allocated_queue<\/a> where kernel creates request queues as a linked list, sets io buffers, timers, and locking.<\/p>\n<p>You may notice that <strong>blk_mq_init_sq_queue<\/strong> sets only 1 hardware queue. It&#8217;s because this function is a Single Queue initializer. If your hardware supports multiple queues and you wish to create a multi-queue block device driver, you have to write your own function around <strong>blk_mq_alloc_tag_set<\/strong> and <strong>blk_mq_init_queue<\/strong>.<\/p>\n<h3>blk-mq driver example<\/h3>\n<p>Now it&#8217;s time for a complete example. Here is the source code of the blk-mq driver. You can use it as a reference.<\/p>\n<pre class=\"prettyprint\">#include &lt;linux\/init.h&gt;\n#include &lt;linux\/module.h&gt;\n#include &lt;linux\/slab.h&gt;\n#include &lt;linux\/vmalloc.h&gt;\n#include &lt;linux\/fs.h&gt;\n#include &lt;linux\/genhd.h&gt;\n#include &lt;linux\/blkdev.h&gt;\n#include &lt;linux\/buffer_head.h&gt;\n#include &lt;linux\/blk-mq.h&gt;\n#include &lt;linux\/hdreg.h&gt;\n\n#ifndef SECTOR_SIZE\n#define SECTOR_SIZE 512\n#endif\n\nstatic int dev_major = 0;\n\n\/* Just internal representation of the our block device\n * can hold any useful data *\/\nstruct block_dev {\n    sector_t capacity;\n    u8 *data;   \/* Data buffer to emulate real storage device *\/\n    struct blk_mq_tag_set tag_set;\n    struct request_queue *queue;\n    struct gendisk *gdisk;\n};\n\n\/* Device instance *\/\nstatic struct block_dev *block_device = NULL;\n\nstatic int blockdev_open(struct block_device *dev, fmode_t mode)\n{\n    printk(\"&gt;&gt;&gt; blockdev_open\\n\");\n\n    return 0;\n}\n\nstatic void blockdev_release(struct gendisk *gdisk, fmode_t mode)\n{\n    printk(\"&gt;&gt;&gt; blockdev_release\\n\");\n}\n\nint blockdev_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd, unsigned long arg)\n{\n    printk(\"ioctl cmd 0x%08x\\n\", cmd);\n\n    return -ENOTTY;\n}\n\n\/* Set block device file I\/O *\/\nstatic struct block_device_operations blockdev_ops = {\n    .owner = THIS_MODULE,\n    .open = blockdev_open,\n    .release = blockdev_release,\n    .ioctl = blockdev_ioctl\n};\n\n\/* Serve requests *\/\nstatic int do_request(struct request *rq, unsigned int *nr_bytes)\n{\n    int ret = 0;\n    struct bio_vec bvec;\n    struct req_iterator iter;\n    struct block_dev *dev = rq-&gt;q-&gt;queuedata;\n    loff_t pos = blk_rq_pos(rq) &lt;&lt; SECTOR_SHIFT;\n    loff_t dev_size = (loff_t)(dev-&gt;capacity &lt;&lt; SECTOR_SHIFT);\n\n    printk(KERN_WARNING \"sblkdev: request start from sector %lld  pos = %lld  dev_size = %lld\\n\", blk_rq_pos(rq), pos, dev_size);\n\n    \/* Iterate over all requests segments *\/\n    rq_for_each_segment(bvec, rq, iter)\n    {\n        unsigned long b_len = bvec.bv_len;\n\n        \/* Get pointer to the data *\/\n        void* b_buf = page_address(bvec.bv_page) + bvec.bv_offset;\n\n        \/* Simple check that we are not out of the memory bounds *\/\n        if ((pos + b_len) &gt; dev_size) {\n            b_len = (unsigned long)(dev_size - pos);\n        }\n\n        if (rq_data_dir(rq) == WRITE) {\n            \/* Copy data to the buffer in to required position *\/\n            memcpy(dev-&gt;data + pos, b_buf, b_len);\n        } else {\n            \/* Read data from the buffer's position *\/\n            memcpy(b_buf, dev-&gt;data + pos, b_len);\n        }\n\n        \/* Increment counters *\/\n        pos += b_len;\n        *nr_bytes += b_len;\n    }\n\n    return ret;\n}\n\n\/* queue callback function *\/\nstatic blk_status_t queue_rq(struct blk_mq_hw_ctx *hctx, const struct blk_mq_queue_data* bd)\n{\n    unsigned int nr_bytes = 0;\n    blk_status_t status = BLK_STS_OK;\n    struct request *rq = bd-&gt;rq;\n\n    \/* Start request serving procedure *\/\n    blk_mq_start_request(rq);\n\n    if (do_request(rq, &amp;nr_bytes) != 0) {\n        status = BLK_STS_IOERR;\n    }\n\n    \/* Notify kernel about processed nr_bytes *\/\n    if (blk_update_request(rq, status, nr_bytes)) {\n        \/* Shouldn't fail *\/\n        BUG();\n    }\n\n    \/* Stop request serving procedure *\/\n    __blk_mq_end_request(rq, status);\n\n    return status;\n}\n\nstatic struct blk_mq_ops mq_ops = {\n    .queue_rq = queue_rq,\n};\n\nstatic int __init myblock_driver_init(void)\n{\n    \/* Register new block device and get device major number *\/\n    dev_major = register_blkdev(dev_major, \"testblk\");\n\n    block_device = kmalloc(sizeof (struct block_dev), GFP_KERNEL);\n\n    if (block_device == NULL) {\n        printk(\"Failed to allocate struct block_dev\\n\");\n        unregister_blkdev(dev_major, \"testblk\");\n\n        return -ENOMEM;\n    }\n\n    \/* Set some random capacity of the device *\/\n    block_device-&gt;capacity = (112 * PAGE_SIZE) &gt;&gt; 9; \/* nsectors * SECTOR_SIZE; *\/\n    \/* Allocate corresponding data buffer *\/\n    block_device-&gt;data = kmalloc(block_device-&gt;capacity &lt;&lt; 9, GFP_KERNEL);\n\n    if (block_device-&gt;data == NULL) {\n        printk(\"Failed to allocate device IO buffer\\n\");\n        unregister_blkdev(dev_major, \"testblk\");\n        kfree(block_device);\n\n        return -ENOMEM;\n    }\n\n    printk(\"Initializing queue\\n\");\n\n    block_device-&gt;queue = blk_mq_init_sq_queue(&amp;block_device-&gt;tag_set, &amp;mq_ops, 128, BLK_MQ_F_SHOULD_MERGE);\n\n    if (block_device-&gt;queue == NULL) {\n        printk(\"Failed to allocate device queue\\n\");\n        kfree(block_device-&gt;data);\n\n        unregister_blkdev(dev_major, \"testblk\");\n        kfree(block_device);\n\n        return -ENOMEM;\n    }\n\n    \/* Set driver's structure as user data of the queue *\/\n    block_device-&gt;queue-&gt;queuedata = block_device;\n\n    \/* Allocate new disk *\/\n    block_device-&gt;gdisk = alloc_disk(1);\n\n    \/* Set all required flags and data *\/\n    block_device-&gt;gdisk-&gt;flags = GENHD_FL_NO_PART_SCAN;\n    block_device-&gt;gdisk-&gt;major = dev_major;\n    block_device-&gt;gdisk-&gt;first_minor = 0;\n\n    block_device-&gt;gdisk-&gt;fops = &amp;blockdev_ops;\n    block_device-&gt;gdisk-&gt;queue = block_device-&gt;queue;\n    block_device-&gt;gdisk-&gt;private_data = block_device;\n\n    \/* Set device name as it will be represented in \/dev *\/\n    strncpy(block_device-&gt;gdisk-&gt;disk_name, \"blockdev\\0\", 9);\n\n    printk(\"Adding disk %s\\n\", block_device-&gt;gdisk-&gt;disk_name);\n\n    \/* Set device capacity *\/\n    set_capacity(block_device-&gt;gdisk, block_device-&gt;capacity);\n\n    \/* Notify kernel about new disk device *\/\n    add_disk(block_device-&gt;gdisk);\n\n    return 0;\n}\n\nstatic void __exit myblock_driver_exit(void)\n{\n    \/* Don't forget to cleanup everything *\/\n    if (block_device-&gt;gdisk) {\n        del_gendisk(block_device-&gt;gdisk);\n        put_disk(block_device-&gt;gdisk);\n    }\n\n    if (block_device-&gt;queue) {\n        blk_cleanup_queue(block_device-&gt;queue);\n    }\n\n    kfree(block_device-&gt;data);\n\n    unregister_blkdev(dev_major, \"testblk\");\n    kfree(block_device);\n}\n\nmodule_init(myblock_driver_init);\nmodule_exit(myblock_driver_exit);\nMODULE_LICENSE(\"GPL\");\n<\/pre>\n<p>And simple Makefile:<\/p>\n<pre class=\"prettyprint\">BINARY     := test_blockdev\nKERNEL      := \/lib\/modules\/$(shell uname -r)\/build\nARCH        := x86\nC_FLAGS     := -Wall\nKMOD_DIR    := $(shell pwd)\nTARGET_PATH := \/lib\/modules\/$(shell uname -r)\/kernel\/drivers\/char\n\nOBJECTS := blockdev.o\n\nccflags-y += $(C_FLAGS)\n\nobj-m += $(BINARY).o\n\n$(BINARY)-y := $(OBJECTS)\n\n$(BINARY).ko:\n    make -C $(KERNEL) M=$(KMOD_DIR) modules\n\ninstall:\n    cp $(BINARY).ko $(TARGET_PATH)\n    depmod -a\n\nclean:\n    rm -f *.ko\n    rm -f *.o\n<\/pre>\n<p>After module building and loading, we can test it.<br \/>\nLet&#8217;s try the<strong> fdisk<\/strong> utility.<\/p>\n<pre>$ sudo fdisk \/dev\/blockdev\n\nWelcome to fdisk (util-linux 2.31.1).\nChanges will remain in memory only, until you decide to write them.\nBe careful before using the write command.\n\nDevice does not contain a recognized partition table.\nCreated a new DOS disklabel with disk identifier 0x7c8bee17.\n\nCommand (m for help): o\nCreated a new DOS disklabel with disk identifier <strong>0xd7002c1e<\/strong>.\n\nCommand (m for help): w\nThe partition table has been altered.\nSyncing disks.\n\n$ sudo fdisk \/dev\/blockdev\n\nWelcome to fdisk (util-linux 2.31.1).\nChanges will remain in memory only, until you decide to write them.\nBe careful before using the write command.\n\n\nCommand (m for help): p\nDisk \/dev\/blockdev: 448 KiB, 458752 bytes, 896 sectors\nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical\/physical): 512 bytes \/ 512 bytes\nI\/O size (minimum\/optimal): 512 bytes \/ 512 bytes\nDisklabel type: dos\nDisk identifier: <strong>0xd7002c1e<\/strong><\/pre>\n<p>As you can <strong>fdisk<\/strong> recognizes our block device as a valid disk and successfully creates a new DOS partition table with id <strong>0xd7002c1e<\/strong>.<br \/>\nThis partition table is stored in our driver&#8217;s memory buffer and valid until the driver is unloaded.<\/p>\n<p>Same for the graphical tools<\/p>\n<p><a href=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2020\/02\/disks_blokdev.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-1135\" src=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2020\/02\/disks_blokdev.png\" alt=\"\" width=\"653\" height=\"443\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2020\/02\/disks_blokdev.png 653w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2020\/02\/disks_blokdev-300x204.png 300w\" sizes=\"(max-width: 653px) 100vw, 653px\" \/><\/a><\/p>\n<p>But what happens if we try to format this device and create a new partition? You can try it. Unfortunately, this operation will fail. The problem is that creating the new partitions must create new block device instances like \/dev\/blockdev0, \/dev\/blockdev1, etc.<br \/>\nAll software expects to find such devices, and this is the point of the failure because this example driver didn&#8217;t create any new per-partition devices.<br \/>\nThe driver should handle partitioning operations (which is normally handled by the hardware). Hope to describe this in new interesting material.<\/p>\n<p>Thanks for reading!<\/p>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n","protected":false},"excerpt":{"rendered":"<p>My article about character devices is quite popular, so I decided to write something about another big class of devices in Linux &#8211; block devices. This type of device is used to access various storage hardware types &#8211; hard disks, SSD, etc. Here I want to describe blk-mq based devices in modern (&gt;= 5.0) Linux [&hellip;]<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[76,54],"tags":[89,90,40,27],"_links":{"self":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/1104"}],"collection":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/comments?post=1104"}],"version-history":[{"count":32,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/1104\/revisions"}],"predecessor-version":[{"id":1756,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/1104\/revisions\/1756"}],"wp:attachment":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/media?parent=1104"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/categories?post=1104"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/tags?post=1104"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}