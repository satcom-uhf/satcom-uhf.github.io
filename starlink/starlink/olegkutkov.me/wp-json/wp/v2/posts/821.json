{"id":821,"date":"2019-03-24T04:42:51","date_gmt":"2019-03-24T01:42:51","guid":{"rendered":"http:\/\/olegkutkov.me\/?p=821"},"modified":"2021-02-11T16:15:50","modified_gmt":"2021-02-11T14:15:50","slug":"getting-linux-routing-table-using-netlink","status":"publish","type":"post","link":"https:\/\/olegkutkov.me\/2019\/03\/24\/getting-linux-routing-table-using-netlink\/","title":{"rendered":"Getting Linux routing table using netlink"},"content":{"rendered":"<div class=\"wp-block-image\">\n<figure class=\"alignleft\"><img loading=\"lazy\" decoding=\"async\" width=\"150\" height=\"150\" class=\"wp-image-294\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/Screenshot-02152018-121038-PM-150x150.png\" alt=\"\" \/><\/figure>\n<\/div>\n<p style=\"text-align: left;\">In the <a href=\"http:\/\/olegkutkov.me\/2018\/02\/14\/monitoring-linux-networking-state-using-netlink\/\">previous<\/a> article, we discussed the monitoring of the network interfaces using Netlink. Now it&#8217;s time to do something more complex and interesting.<br \/>\nLet&#8217;s discover how to get and print the system routing table like &#8220;ip route&#8221; command.<\/p>\n<p><!--more--><\/p>\n<p>The routing table is a runtime in-memory data structure that stores the routes (and in some cases, metrics associated with those routes) to particular network destinations. This is very important with TCP\/IP. Using this table network stack decides where and how to put packets for a specified network.<br \/>\nLinux kernel supports multiple routing tables. Beyond the two commonly used routing tables (the local and main routing tables), the kernel supports 252 additional routing tables.<br \/>\nThe multiple routing table system provides a flexible infrastructure on top of which to implement policy routing. By allowing multiple traditional routing tables (keyed primarily to destination address) to be combined with the routing policy database (RPDB) (keyed primarily to source address), the kernel supports a well-known and well-understood interface while simultaneously expanding and extending its routing capabilities.<\/p>\n<p>To get Linux main routing table, we can use commands &#8220;<strong>route -n<\/strong>&#8220;, &#8220;<strong>netstat -rn<\/strong>&#8221; and &#8220;<strong>ip route<\/strong>&#8220;:<\/p>\n<blockquote class=\"wp-block-quote\"><p>$route -n<\/p><\/blockquote>\n<p>The first utility is used the classic <strong>ioctl<\/strong> interface to get information from the kernel. This way is limited and became deprecated now.<br \/>\nInstead of <strong>ioctl<\/strong> &#8220;<strong>ip route<\/strong>&#8221; is based on the Netlink sockets, and now we discover how it works.<\/p>\n<p>Like in the monitor, everything starts with the creation of the Netlink socket and binding. Binding here is essential. This allows us to execute this program as a normal user.<\/p>\n<pre class=\"prettyprint\">struct sockaddr_nl saddr;\n\n\/* Open raw socket for the NETLINK_ROUTE protocol *\/\nint nl_sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n\nif (nl_sock &lt; 0) {\n    perror(\"Failed to open netlink socket\");\n    return -1;\n}\n\nmemset(&amp;saddr, 0, sizeof(saddr));\n\nsaddr.nl_family = AF_NETLINK;\nsaddr.nl_pid = getpid();\n\n\/* Bind current process to the netlink socket *\/\nif (bind(nl_sock, (struct sockaddr *)&amp;saddr, sizeof(saddr)) &lt; 0) {\n    perror(\"Failed to bind to netlink socket\");\n    close(nl_sock);\n    return -1;\n}<\/pre>\n<p>Now it&#8217;s time to send the request to the kernel.<\/p>\n<pre class=\"prettyprint\">\/* Request struct *\/\nstruct {\n    struct nlmsghdr nlh;  \/* Netlink header *\/\n    struct rtmsg rtm;     \/* Payload - route message *\/\n} nl_request;\n\nnl_request.nlh.nlmsg_type = RTM_GETROUTE;  \/* We wish to get routes *\/\nnl_request.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;\nnl_request.nlh.nlmsg_len = sizeof(nl_request);\nnl_request.nlh.nlmsg_seq = time(NULL);\nnl_request.rtm.rtm_family = AF_INET;\n\nssize_t sent = send(sock, &amp;nl_request, sizeof(nl_request), 0);\n\nif (sent &lt; 0) {\n    perror(\"Failed to perfom request\");\n    close(nl_sock);\n    return -1;\n}<\/pre>\n<p>We need to declare a request structure that describes the Netlink packet with a header and some payload &#8211; actual message.<br \/>\nIn the header, we specify what we need with RTM_GETROUTE as a message type that can return the main routing table.<br \/>\nAdditional flags &#8220;NLM_F_REQUEST | NLM_F_DUMP&#8221; telling the kernel that this is a dump request.<br \/>\nAs rtm_family we can specify AF_INET if we want to get the table for IPv4 protocol and AF_INET6 for IPv6.<\/p>\n<p>Getting kernel response is more complex.<br \/>\nWe need to execute vectored reading using already known <strong>recvmsg<\/strong> and struct <strong>iovec<\/strong>.<br \/>\nFor simplification reasons, this code is split into the 3 functions.<\/p>\n<p>On the lowest level is a simple wrapper around <strong>recvmsg<\/strong>, which more robust and can handle &#8220;busy&#8221; states.<\/p>\n<pre class=\"prettyprint\">int rtnl_receive(int fd, struct msghdr *msg, int flags)\n{\n    int len;\n\n    \/* Try to read the message in case of busy or interrupted call *\/\n    do {\n        len = recvmsg(fd, msg, flags);\n    } while (len &lt; 0 &amp;&amp; (errno == EINTR || errno == EAGAIN));\n\n    if (len &lt; 0) {\n        perror(\"Netlink receive failed\");\n        return -errno;\n    }\n\n    if (len == 0) {\n        perror(\"EOF on netlink\");\n        return -ENODATA;\n    }\n\n    return len;\n}<\/pre>\n<p>Receive is called from the rtnl_recvmsg function, which reads the message size first, then allocating buffer using size info and reading the actual response message.<\/p>\n<p>Here struct <strong>iovec<\/strong> is passed from the top-level function get_route_dump_response.<\/p>\n<pre class=\"prettyprint\">int get_route_dump_response(int sock)\n{\n    struct sockaddr_nl nladdr;\n    struct iovec iov;\n    struct msghdr msg = {\n        .msg_name = &amp;nladdr,\n        .msg_namelen = sizeof(nladdr),\n        .msg_iov = &amp;iov,\n        .msg_iovlen = 1,\n    };\n\n    char *buf;\n    int dump_intr = 0;\n\n    \/* Get the message *\/\n    int status = rtnl_recvmsg(sock, &amp;msg, &amp;buf);\n\n    \/* Pointer to the messages head *\/\n    struct nlmsghdr *h = (struct nlmsghdr *)buf;\n    int msglen = status;\n\n    printf(\"Main routing table IPv4\\n\");\n\n    \/* Iterate through all messages in buffer *\/\n    while (NLMSG_OK(h, msglen)) {\n        if (h-&gt;nlmsg_flags &amp; NLM_F_DUMP_INTR) {\n            perror(\"Dump was interrupted\\n\");\n            free(buf);\n            return -1;\n        }\n\n        if (nladdr.nl_pid != 0) {\n            continue;\n        }\n\n        if (h-&gt;nlmsg_type == NLMSG_ERROR) {\n            perror(\"netlink reported error\");\n            free(buf);\n        }\n\n        \/* Decode and print single message *\/\n        print_route(h);\n\n        h = NLMSG_NEXT(h, msglen);\n    }\n\n    free(buf);\n\n    return status;\n}<\/pre>\n<p>Netlink messages can be split into parts, so this function is trying to read all those parts.<br \/>\nAfter successfully receiving the message, we can call the printer function print_route.<\/p>\n<pre class=\"prettyprint\">void parse_rtattr(struct rtattr *tb[], int max, struct rtattr *rta, int len)\n{\n    memset(tb, 0, sizeof(struct rtattr *) * (max + 1));\n\n    while (RTA_OK(rta, len)) {\n        if (rta-&gt;rta_type &lt;= max) {\n            tb[rta-&gt;rta_type] = rta;\n        }\n\n        rta = RTA_NEXT(rta,len);\n    }\n}\n\nstatic inline int rtm_get_table(struct rtmsg *r, struct rtattr **tb)\n{\n    __u32 table = r-&gt;rtm_table;\n\n    if (tb[RTA_TABLE]) {\n        table = *(__u32 *)RTA_DATA(tb[RTA_TABLE]);\n    }\n\n    return table;\n}<\/pre>\n<p>The printer function is using two auxiliary functions for parsing the message. One of these functions is already known from the network monitor.<br \/>\nBoth these functions perform simple iteration on the memory, some conversion of the types, and alignment.<br \/>\nFinally, we ready to print the route.<\/p>\n<pre class=\"prettyprint\">void print_route(struct nlmsghdr* nl_header_answer)\n{\n    struct rtmsg* r = NLMSG_DATA(nl_header_answer);\n    int len = nl_header_answer-&gt;nlmsg_len;\n    struct rtattr* tb[RTA_MAX+1];\n    int table;\n    char buf[256];\n\n    len -= NLMSG_LENGTH(sizeof(*r));\n\n    if (len &lt; 0) {\n        perror(\"Wrong message length\");\n        return;\n    }\n\n    \/* Parse message *\/\n    parse_rtattr(tb, RTA_MAX, RTM_RTA(r), len);\n\n    table = rtm_get_table(r, tb);\n\n    if (r-&gt;rtm_family != AF_INET &amp;&amp; table != RT_TABLE_MAIN) {\n        return;\n    }\n\n    \/* Read destination address from the tb at RTA_DST index *\/\n    if (tb[RTA_DST]) {\n        if ((r-&gt;rtm_dst_len != 24) &amp;&amp; (r-&gt;rtm_dst_len != 16)) {\n            return;\n        }\n        \/* Print readable address using inet_ntop *\/\n        printf(\"%s\/%u \", inet_ntop(r-&gt;rtm_family, RTA_DATA(tb[RTA_DST]), buf, sizeof(buf)), r-&gt;rtm_dst_len);\n\n    } else if (r-&gt;rtm_dst_len) {\n        printf(\"0\/%u \", r-&gt;rtm_dst_len);\n    } else {\n        printf(\"default \");\n    }\n\n    \/* Do the same thing for rest of the fields *\/\n    if (tb[RTA_GATEWAY]) {\n        printf(\"via %s\", inet_ntop(r-&gt;rtm_family, RTA_DATA(tb[RTA_GATEWAY]), buf, sizeof(buf)));\n    }\n\n    if (tb[RTA_OIF]) {\n        char if_nam_buf[IF_NAMESIZE];\n        int ifidx = *(__u32 *)RTA_DATA(tb[RTA_OIF]);\n\n        printf(\" dev %s\", if_indextoname(ifidx, if_nam_buf));\n    }\n\n    if (tb[RTA_SRC]) {\n        printf(\"src %s\", inet_ntop(r-&gt;rtm_family, RTA_DATA(tb[RTA_SRC]), buf, sizeof(buf)));\n    }\n\n    printf(\"\\n\");\n}<\/pre>\n<p>In the beginning, this function performing parsing of the message and some checks.<br \/>\nThen we can easily access different parts of the routing message using array and indices with readable defines.<\/p>\n<p>To get the IPv4 address in a human-readable text form is used standard inet_ntop.<br \/>\nThe network interface is presented as numeric indexes and converted to the readable form (like &#8220;eth0&#8221;) using if_indextoname.<br \/>\nThis function required a pre-allocated buffer with IF_NAMESIZE size.<\/p>\n<p>Now all together:<\/p>\n<pre class=\"prettyprint\">\/*\n *\n *\/\n\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;sys\/types.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;time.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;net\/if.h&gt;\n#include &lt;arpa\/inet.h&gt;\n#include &lt;sys\/socket.h&gt;\n#include &lt;linux\/rtnetlink.h&gt;\n\nint rtnl_receive(int fd, struct msghdr *msg, int flags)\n{\n    int len;\n\n    do { \n        len = recvmsg(fd, msg, flags);\n    } while (len &lt; 0 &amp;&amp; (errno == EINTR || errno == EAGAIN));\n\n    if (len &lt; 0) {\n        perror(\"Netlink receive failed\");\n        return -errno;\n    }\n\n    if (len == 0) { \n        perror(\"EOF on netlink\");\n        return -ENODATA;\n    }\n\n    return len;\n}\n\nstatic int rtnl_recvmsg(int fd, struct msghdr *msg, char **answer)\n{\n    struct iovec *iov = msg-&gt;msg_iov;\n    char *buf;\n    int len;\n\n    iov-&gt;iov_base = NULL;\n    iov-&gt;iov_len = 0;\n\n    len = rtnl_receive(fd, msg, MSG_PEEK | MSG_TRUNC);\n\n    if (len &lt; 0) {\n        return len;\n    }\n\n    buf = malloc(len);\n\n    if (!buf) {\n        perror(\"malloc failed\");\n        return -ENOMEM;\n    }\n\n    iov-&gt;iov_base = buf;\n    iov-&gt;iov_len = len;\n\n    len = rtnl_receive(fd, msg, 0);\n\n    if (len &lt; 0) {\n        free(buf);\n        return len;\n    }\n\n    *answer = buf;\n\n    return len;\n}\n\nvoid parse_rtattr(struct rtattr *tb[], int max, struct rtattr *rta, int len)\n{\n    memset(tb, 0, sizeof(struct rtattr *) * (max + 1));\n\n    while (RTA_OK(rta, len)) {\n        if (rta-&gt;rta_type &lt;= max) {\n            tb[rta-&gt;rta_type] = rta;\n        }\n\n        rta = RTA_NEXT(rta,len);\n    }\n}\n\nstatic inline int rtm_get_table(struct rtmsg *r, struct rtattr **tb)\n{\n    __u32 table = r-&gt;rtm_table;\n\n    if (tb[RTA_TABLE]) {\n        table = *(__u32 *)RTA_DATA(tb[RTA_TABLE]);\n    }\n\n    return table;\n}\n\nvoid print_route(struct nlmsghdr* nl_header_answer)\n{\n    struct rtmsg* r = NLMSG_DATA(nl_header_answer);\n    int len = nl_header_answer-&gt;nlmsg_len;\n    struct rtattr* tb[RTA_MAX+1];\n    int table;\n    char buf[256];\n\n    len -= NLMSG_LENGTH(sizeof(*r));\n\n    if (len &lt; 0) {\n        perror(\"Wrong message length\");\n        return;\n    }\n    \n    parse_rtattr(tb, RTA_MAX, RTM_RTA(r), len);\n\n    table = rtm_get_table(r, tb);\n\n    if (r-&gt;rtm_family != AF_INET &amp;&amp; table != RT_TABLE_MAIN) {\n        return;\n    }\n\n    if (tb[RTA_DST]) {\n        if ((r-&gt;rtm_dst_len != 24) &amp;&amp; (r-&gt;rtm_dst_len != 16)) {\n            return;\n        }\n\n        printf(\"%s\/%u \", inet_ntop(r-&gt;rtm_family, RTA_DATA(tb[RTA_DST]), buf, sizeof(buf)), r-&gt;rtm_dst_len);\n\n    } else if (r-&gt;rtm_dst_len) {\n        printf(\"0\/%u \", r-&gt;rtm_dst_len);\n    } else {\n        printf(\"default \");\n    }\n\n    if (tb[RTA_GATEWAY]) {\n        printf(\"via %s\", inet_ntop(r-&gt;rtm_family, RTA_DATA(tb[RTA_GATEWAY]), buf, sizeof(buf)));\n    }\n\n    if (tb[RTA_OIF]) {\n        char if_nam_buf[IF_NAMESIZE];\n        int ifidx = *(__u32 *)RTA_DATA(tb[RTA_OIF]);\n\n        printf(\" dev %s\", if_indextoname(ifidx, if_nam_buf));\n    }\n\n    if (tb[RTA_SRC]) {\n        printf(\"src %s\", inet_ntop(r-&gt;rtm_family, RTA_DATA(tb[RTA_SRC]), buf, sizeof(buf)));\n    }\n\n    printf(\"\\n\");\n}\n\nint open_netlink()\n{\n    struct sockaddr_nl saddr;\n\n    int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n\n    if (sock &lt; 0) {\n        perror(\"Failed to open netlink socket\");\n        return -1;\n    }\n\n    memset(&amp;saddr, 0, sizeof(saddr));\n\n    saddr.nl_family = AF_NETLINK;\n    saddr.nl_pid = getpid();\n\n    if (bind(sock, (struct sockaddr *)&amp;saddr, sizeof(saddr)) &lt; 0) {\n        perror(\"Failed to bind to netlink socket\");\n        close(sock);\n        return -1;\n    }\n\n    return sock;\n}\n\nint do_route_dump_requst(int sock)\n{\n    struct {\n        struct nlmsghdr nlh;\n        struct rtmsg rtm;\n    } nl_request;\n\n    nl_request.nlh.nlmsg_type = RTM_GETROUTE;\n    nl_request.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;\n    nl_request.nlh.nlmsg_len = sizeof(nl_request);\n    nl_request.nlh.nlmsg_seq = time(NULL);\n    nl_request.rtm.rtm_family = AF_INET;\n\n    return send(sock, &amp;nl_request, sizeof(nl_request), 0);\n}\n\nint get_route_dump_response(int sock)\n{\n    struct sockaddr_nl nladdr;\n    struct iovec iov;\n    struct msghdr msg = {\n        .msg_name = &amp;nladdr,\n        .msg_namelen = sizeof(nladdr),\n        .msg_iov = &amp;iov,\n        .msg_iovlen = 1,\n    };\n\n    char *buf;\n    int dump_intr = 0;\n\n    int status = rtnl_recvmsg(sock, &amp;msg, &amp;buf);\n\n    struct nlmsghdr *h = (struct nlmsghdr *)buf;\n    int msglen = status;\n\n    printf(\"Main routing table IPv4\\n\");\n\n    while (NLMSG_OK(h, msglen)) {\n        if (h-&gt;nlmsg_flags &amp; NLM_F_DUMP_INTR) {\n            fprintf(stderr, \"Dump was interrupted\\n\");\n            free(buf);\n            return -1;\n        }\n\n        if (nladdr.nl_pid != 0) {\n            continue;\n        }\n\n        if (h-&gt;nlmsg_type == NLMSG_ERROR) {\n            perror(\"netlink reported error\");\n            free(buf);\n        }\n\n        print_route(h);\n\n        h = NLMSG_NEXT(h, msglen);\n    }\n\n    free(buf);\n\n    return status;\n}\n\nint main()\n{\n    int nl_sock = open_netlink();\n\n    if (do_route_dump_requst(nl_sock) &lt; 0) {\n        perror(\"Failed to perfom request\");\n        close(nl_sock);\n        return -1;\n    }\n\n    get_route_dump_response(nl_sock);\n\n    close (nl_sock);\n\n    return 0;\n}\n<\/pre>\n<p>Compilation and execution:<\/p>\n<blockquote class=\"wp-block-quote\"><p>$ gcc -g -ggdb routing.c -o routing<br \/>\n$ .\/routing<br \/>\nMain routing table IPv4<br \/>\ndefault via 192.168.8.1 dev eth0<br \/>\n169.254.0.0\/16 dev eth0<br \/>\n192.168.8.0\/24 dev eth0<\/p><\/blockquote>\n<p>That&#8217;s it.<br \/>\nIn the next article, I will show how to delete and add new routes.<\/p>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous article, we discussed the monitoring of the network interfaces using Netlink. Now it&#8217;s time to do something more complex and interesting. Let&#8217;s discover how to get and print the system routing table like &#8220;ip route&#8221; command.<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[76,25,78,54],"tags":[40,27,26,70,71],"_links":{"self":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/821"}],"collection":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/comments?post=821"}],"version-history":[{"count":25,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/821\/revisions"}],"predecessor-version":[{"id":1850,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/821\/revisions\/1850"}],"wp:attachment":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/media?parent=821"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/categories?post=821"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/tags?post=821"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}