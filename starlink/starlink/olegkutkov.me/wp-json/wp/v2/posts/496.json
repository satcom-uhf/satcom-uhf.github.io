{"id":496,"date":"2018-05-16T02:11:04","date_gmt":"2018-05-15T23:11:04","guid":{"rendered":"http:\/\/olegkutkov.me\/?p=496"},"modified":"2021-02-04T14:26:36","modified_gmt":"2021-02-04T12:26:36","slug":"converting-dslr-raw-images-into-scientific-fits-format-part-2-working-with-libraw","status":"publish","type":"post","link":"https:\/\/olegkutkov.me\/2018\/05\/16\/converting-dslr-raw-images-into-scientific-fits-format-part-2-working-with-libraw\/","title":{"rendered":"Converting DSLR RAW images into scientific FITS format. Part 2: working with LIBRAW"},"content":{"rendered":"<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/images_bayer.png\"><img loading=\"lazy\" decoding=\"async\" class=\"alignleft wp-image-515\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/images_bayer.png\" alt=\"\" width=\"239\" height=\"155\" \/><\/a>In the <a href=\"https:\/\/olegkutkov.me\/2017\/11\/02\/converting-dslr-raw-images-scientific-fits-format-part-1-ui\/\">previous<\/a> article, I&#8217;m started to describe my Raw2Fits converter. It was a brief note about GTK user interface development.<br \/>\nNow I want to talk about the LibRaw library. This is a great library for reading RAW files from digital photo cameras (CRW\/CR2, NEF, RAF, DNG, and others).<\/p>\n<p>Take a look at the <a href=\"https:\/\/www.libraw.org\/\">LibRaw<\/a> project web page and official documentation.<\/p>\n<p>I highly recommend using the latest stable release from this site instead of the precompiled version from Linux distros.<\/p>\n<p><!--more--><\/p>\n<h3>Getting and installing the library<\/h3>\n<p>Download and build the latest STABLE version of the LibRaw from the project <a href=\"https:\/\/www.libraw.org\/download\">downloads<\/a> page.<\/p>\n<p>For example, <a href=\"https:\/\/www.libraw.org\/data\/LibRaw-0.18.11.tar.gz\">LibRaw-0.18.11.tar.gz<\/a> as for 15 May 2018.<\/p>\n<pre class=\"prettyprint\"># Download archive\n$ wget https:\/\/www.libraw.org\/data\/LibRaw-0.18.11.tar.gz\n\n# Extract\n$ tar -xvf LibRaw-0.18.11.tar.gz \n\n# Remove downloaded file\n$ rm LibRaw-0.18.11.tar.gz\n\n# Go to extracted directory\n$ cd LibRaw-0.18.11\n\n# Run configure script\n$ .\/configure<\/pre>\n<p>After compilation, this library will be installed in <strong>\/usr\/local\/lib<\/strong>. If you want to use standard <strong>\/usr\/lib<\/strong> configure script as follows:<\/p>\n<pre class=\"prettyprint\">.\/configure --prefix=\/usr<\/pre>\n<p>But don&#8217;t forget to remove some previous\/repository installation of the library!<\/p>\n<p>Now build and install:<\/p>\n<pre class=\"prettyprint\">$ make\n$ sudo make install<\/pre>\n<p>These steps should be done without any errors. If problems check out the error messages and fix your environment, you can lack some required package, for example.<\/p>\n<p>To use LibRaw, add the following parameters to the compiler call (when building your own projects):<\/p>\n<ul>\n<li>Path to include-files: -I\/usr\/local\/include<\/li>\n<li>Path to libraries: -L\/usr\/local\/lib<\/li>\n<li>Library: -lraw (ordinary version) or -lraw_r (thread-safe version).<\/li>\n<\/ul>\n<p>If you configured the library for another path (\/usr\/lib) &#8211; correct these params to your own.<\/p>\n<h3>Library usage<\/h3>\n<p>There are two API&#8217;s available &#8211; C++ and pure C. They are quite similar by concepts and functions\/methods naming. Of course, the C++ version uses objects and methods but C only structs and function calls.<\/p>\n<p>In my project, I&#8217;m using the C version of the API, so we will use this language in the following examples. It is straightforward to switch to the C++ API after learning the basic concept of this library.<\/p>\n<p>Everything we need is available only in one header file, so don&#8217;t forget to include the library at the beginning of your source file.<\/p>\n<pre class=\"prettyprint\">#include &lt;libraw\/libraw.h&gt;<\/pre>\n<p>The library is accessed through <a href=\"https:\/\/www.libraw.org\/docs\/API-datastruct.html#libraw_data_t\">libraw_data_t<\/a> structure, which holds all library internals structures during program execution.<\/p>\n<p>This structure must be initialized before usage:<\/p>\n<pre class=\"prettyprint\">libraw_data_t *rawdata = libraw_init(0);<\/pre>\n<p>And closed in the end:<\/p>\n<pre class=\"prettyprint\">libraw_close(rawdata);<\/pre>\n<p>The initialization method returns NULL in case of error, a pointer to the structure in all other cases. Some LibRaw methods may return integer error codes. You can convert these codes to human-readable strings using libraw_strerror() method.<\/p>\n<p>Now we ready to load our RAW image from the file (picture.cr2, for example).<\/p>\n<pre class=\"prettyprint\">int err = libraw_open_file(rawdata, \"picture.cr2\");\n\nif (err != LIBRAW_SUCCESS) {\n    printf(\"libraw_open_file failed! Error: %s\\n\", libraw_strerror(err));\n    libraw_close(rawdata);\n}<\/pre>\n<p>Here you can see proper error checking and usage of the <strong>libraw_strerror()<\/strong>.<\/p>\n<p>libraw_open_file is very fast since these methods only access the file without any data loading and decoding.<\/p>\n<p>After the file&#8217;s successful opening, we can unpack RAW data to get access to the image meta tags and actual image data.<\/p>\n<pre class=\"prettyprint\">err = libraw_unpack(rawdata);\n\nif (err != LIBRAW_SUCCESS) {\n    printf(\"libraw_unpack! Error: %s\\n\", libraw_strerror(err));\n    libraw_close(rawdata);\n}<\/pre>\n<p>This operation may require some time, depending on the file size and your computer resources.<\/p>\n<p>We can get some visualization of the unpacking progress by setting progress handlers.<\/p>\n<pre class=\"prettyprint\">int decoder_progress_callback(void *arg, enum LibRaw_progress p,int iteration, int expected)\n{\n    printf(\"%s, step %i\/%i\\n\", libraw_strprogress(p), iteration + 1, expected);\n    return 0;\n}\n\nvoid *arg;\nlibraw_set_progress_handler(rawdata, &amp;decoder_progress_callback, arg);<\/pre>\n<p>Arg is a pointer to custom data. You can put here everything you want to use in decoder_progress_callback.<\/p>\n<p>This callback may terminate current image processing by returning a non-zero value. In such cases, all processing will be canceled immediately.<\/p>\n<p>decoder_progress_callback must be called before actual data unpacking and decoding.<\/p>\n<p>Unpacked images must be released at the end of the processing.<\/p>\n<pre class=\"prettyprint\">libraw_recycle(rawdata);<\/pre>\n<h5>Accessing meta information<\/h5>\n<p>At this point, we can get some useful information from our RAW file: camera model, lenses, exposure, and other params. Note that depending on the camera vendor\/model, some of the data may not be available.<\/p>\n<p>There are few data structures available in <strong>libraw_data_t<\/strong>:<\/p>\n<ul>\n<li><strong>libraw_iparams_t<\/strong> &#8211; The structure describes the main image parameters retrieved from the RAW file.<br \/>\nMost useful fields of this structure:<\/li>\n<\/ul>\n<pre><strong>char<\/strong> <strong>make<\/strong>[64] - Camera manufacturer.\n<strong>char<\/strong> <strong>model<\/strong>[64] - Camera model.\n<strong>char<\/strong> <strong>software<\/strong>[64] - Softwary name\/version\n<strong>unsigned<\/strong> <strong>raw_count<\/strong> - Number of RAW images in file<\/pre>\n<ul>\n<li><strong>libraw_image_sizes_t sizes<\/strong> -The structure describes the geometrical parameters of the image.<br \/>\nFields of this structure:<strong>ushort<\/strong> <strong>raw_height<\/strong>,<strong> raw_width<\/strong> &#8211; Full size of a RAW image (including the frame) in pixels<br \/>\n<strong>ushort<\/strong> <strong>height<\/strong>, <strong>width<\/strong> &#8211; Size of visible (&#8220;meaningful&#8221;) part of the image (without the frame)<br \/>\n<strong>ushort<\/strong> <strong>top_margin<\/strong>, <strong>left_margin<\/strong> &#8211; Coordinates of the top left corner of the frame (the second corner is calculated from the full size of the image and size of its visible part)<br \/>\n<strong>ushort<\/strong> <strong>iheight<\/strong>, <strong>iwidth<\/strong> &#8211; Size of the output image (may differ from height\/width for cameras that require image rotation or have non-square pixels)<br \/>\n<strong>double<\/strong> <strong>pixel_aspect<\/strong> &#8211; Pixel width\/height ratio<br \/>\n<strong>int<\/strong> <strong>flip<\/strong> &#8211; Image orientation (0 if does not require rotation; 3 if requires 180-deg rotation; 5 if 90 deg counterclockwise, 6 if 90 deg clockwise)<\/li>\n<li><strong>libraw_lensinfo_t lens<\/strong> &#8211; The structure describes the lens used for the shot. Read the official documentation about this huge structure.<\/li>\n<li><strong>libraw_imgother_t other<\/strong> &#8211; A data structure for information purposes.<br \/>\nFields:<strong>float iso_speed<\/strong> &#8211; ISO sensitivity<br \/>\n<strong>float shutter<\/strong> &#8211; Shutter speed<br \/>\n<strong>float aperture<\/strong> &#8211; Aperture<br \/>\n<strong>float focal_len<\/strong> &#8211; Focal length<br \/>\n<strong>time_t timestamp<\/strong> &#8211; Date of shooting<br \/>\n<strong>unsigned shot_order<\/strong> &#8211; Serial number of image<br \/>\n<strong>unsigned gpsdata<\/strong>[32] &#8211; GPS data (unparsed block, to write to output as is)<br \/>\nlibraw_gps_info_t parsed_gps &#8211; Parsed GPS-data: longtitude\/lattitude\/altitude and time stamp<br \/>\n<strong>char desc<\/strong>[512] &#8211; Image description<br \/>\n<strong>char artist<\/strong>[64] &#8211; Author of image<br \/>\n<strong>float FlashEC<\/strong> &#8211; Flash exposure compensation<\/li>\n<\/ul>\n<p>Reading meta information.<\/p>\n<pre class=\"prettyprint\">\/\/ Camera &amp; user information\nprintf(\"Camera vendor: %s\\n\", rawdata-&gt;idata.make);\nprintf(\"Camera model: %s\\n\", rawdata-&gt;idata.model);\nprintf(\"Camera owner: %s\\n\", rawdata-&gt;other.artist);\n\n\/\/ Date of shooting\nchar time_buf[25];\nstruct tm *utc_tm = gmtime(&amp;rawdata-&gt;other.timestamp);\nstrftime(time_buf, 25, \"%Y-%m-%dT%H:%M:%S\", utc_tm);\nprintf(\"Date of shooting: %s\\n\", time_buf);\n\n\/\/ Shooting params\nprintf(\"Exposure: %d\\n\", rawdata-&gt;other.shutter);\nprintf(\"Aperture: %d\\n\", rawdata-&gt;other.aperture);\n<\/pre>\n<h5>Getting image<\/h5>\n<p>You can get a RAW image buffer from the library to do all post-processing by yourself. But in this case, you have to deal with Bayer RGB filters.<\/p>\n<p>Bayer color filter array is a popular format for the digital acquisition of color images. The pattern of the color filters is shown below. Half of the total number of pixels are green (G), while a quarter of the total number is assigned to both red (R) and blue (B).<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/bayer-pattern.gif\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-508\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/bayer-pattern.gif\" alt=\"\" width=\"360\" height=\"300\" \/><\/a>The color image sensor is covered with either a red, a green, or a blue filter in a repeating pattern to obtain this color information. This pattern, or sequence, of filters, can vary, but the widely adopted \u201cBayer\u201d pattern, invented at Kodak, is a repeating 2&#215;2 arrangement.<\/p>\n<p>Note that different cameras may have different patterns of this filter and even non-square pixels. You should know all the information about your camera sensor if you want to process this image manually.<\/p>\n<p>To convert an image from the Bayer format to an RGB per pixel format, we need to interpolate the two missing color values in each pixel. Several standard interpolation methods (nearest neighbor, linear, cubic, cubic spline, etc.) exist.<\/p>\n<p>Getting raw buffer from the LibRaw, you actually getting three buffers: RED, GREEN, and BLUE. All buffers have the same sizes (size of the image) but with &#8220;holes&#8221; in the place of other colors pixels.<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/bayer-simulation2.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-509\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/bayer-simulation2.png\" alt=\"\" width=\"500\" height=\"300\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/bayer-simulation2.png 500w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/bayer-simulation2-300x180.png 300w\" sizes=\"(max-width: 500px) 100vw, 500px\" \/><\/a>Now you can apply some Bayer Interpolation algorithm to mix these image matrices to get a proper RGB image. You still have to do with three separate buffers for colors, but now every point, this buffer is filled with proper mixed value, without any &#8220;holes&#8221;. Also, at this point can be applied several corrections to the image: white balance, brightness, and so on.<\/p>\n<p>Likely LibRaw can do for us everything of this! \ud83d\ude42<\/p>\n<p>This is a separate subset of API for simulating <a href=\"https:\/\/en.wikipedia.org\/wiki\/Dcraw\">dcraw<\/a> functionality.<\/p>\n<p>Getting an RGB image is required a few simple steps.<\/p>\n<pre class=\"prettyprint\">err = libraw_raw2image(rawdata);\n\nif (err != LIBRAW_SUCCESS) {\n    printf(\"libraw_raw2image failed! Error: %s\", libraw_strerror(err));\n    libraw_recycle(rawdata);\n    libraw_close(rawdata);\n}\n\nerr = libraw_dcraw_process(rawdata);\n\nif (err != LIBRAW_SUCCESS) {\n    printf(\"libraw_dcraw_process failed! Error: %s\", libraw_strerror(err));\n    libraw_free_image(rawdata);\n    libraw_recycle(rawdata);\n    libraw_close(rawdata);\n}\n\nlibraw_processed_image_t *proc_img = libraw_dcraw_make_mem_image(rawdata, &amp;err);\n\nlibraw_free_image(rawdata);\n\nif (!proc_img) {\n    printf(\"libraw_dcraw_make_mem_image failed! Error: %s\", libraw_strerror(err));\n    libraw_recycle(rawdata);\n    libraw_close(rawdata);\n}\n\n\/\/ At this point we got processed image in proc_img\n\/\/ This image can be accessed by proc_img-&gt;data field\n\n\/\/\/\/\/\/\n\nprintf(\"Image decoded, size = %ix%i, bits = %i, colors = %i\\n\",\n        proc_img-&gt;width, proc_img-&gt;height, proc_img-&gt;bits, proc_img-&gt;colors);\n\nlibraw_recycle(rawdata);\nlibraw_close(rawdata);\n\nlibraw_dcraw_clear_mem(proc_img);<\/pre>\n<p>In this example, you can find a new data structure &#8211; <a href=\"https:\/\/www.libraw.org\/docs\/API-datastruct-eng.html#libraw_processed_image_t\"><strong>libraw_processed_image_t<\/strong><\/a>. This structure is holding a processed image.<\/p>\n<p>RGB image can be accessed by proc_img-&gt;data field.<\/p>\n<p>This field is just a byte array holding every pixel of the image in the following pattern: RGBRGBRGBRGB&#8230;. where every R, G, and B is a pixel luminosity value after the &#8220;debayering&#8221; process.<\/p>\n<p>So to read every image pixel RGB value, you can do something like this:<\/p>\n<pre class=\"prettyprint\">int i, k = 0;\nlong rgb[3];\n\nfor (i = 0; i &lt; proc_img-&gt;width * proc_img-&gt;height; i++) {\n    rgb[0] = proc_img-&gt;data[k];\n    rgb[1] = proc_img-&gt;data[k + 1];\n    rgb[2] = proc_img-&gt;data[k + 2];\n\n    \/\/\/\/\/\n\n    k += 3;\n}<\/pre>\n<p>Here on every cycle iteration we get red value in rgb[0], green value in rgb[1] and blue value in rgb[2].<\/p>\n<p>We can do with these values everything we want, copy to separate buffers for future processing or mix up to grayscale.<\/p>\n<p>Conversion to grayscale is also very simple:<\/p>\n<pre class=\"prettyprint\">long gray_pixel = (rgb[0] + rgb[1] + rgb[2]) \/ 3;<\/pre>\n<p>In my Raw2Fits converter, I&#8217;m using these pixel values to store the image into the FITS file. In the next article, I will describe this in detail. But you can discover this <a href=\"https:\/\/github.com\/olegkutkov\/Raw2Fits\/blob\/master\/src\/raw2fits.c\">source<\/a> file.<\/p>\n<h3>Complete example<\/h3>\n<p>In this article, I can show you another example. Let&#8217;s convert RAW images into standard JPEG!<\/p>\n<p>We need one more library &#8211; libjpeg.<\/p>\n<p>The following example contains all code from the above and uses the libjpeg to store the compressed RAW image.<\/p>\n<pre class=\"prettyprint\">#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;libraw\/libraw.h&gt;\n#include &lt;jpeglib.h&gt;\n\nint decoder_progress_callback(void *arg, enum LibRaw_progress p,int iteration, int expected)\n{\n    printf(\"%s, step %i\/%i\\n\", libraw_strprogress(p), iteration + 1, expected);\n    return 0; \n}\n\nint main(int argc, char* argv[])\n{\n    if (argc != 3) {\n        printf(\"Usage: .\/raw_test in.raw (cr2, nef, etc) out.jpg\\n\");\n        return -1;\n    }\n\n    libraw_data_t *rawdata = libraw_init(0);\n\n    int err = libraw_open_file(rawdata, argv[1]);\n\n    if (err != LIBRAW_SUCCESS) { \n        printf(\"libraw_open_file failed! Error: %s\\n\", libraw_strerror(err));\n        libraw_close(rawdata);\n        return -1;\n    }\n\n    libraw_set_progress_handler(rawdata, &amp;decoder_progress_callback, NULL);\n    \n    err = libraw_unpack(rawdata);\n\n    if (err != LIBRAW_SUCCESS) {\n        printf(\"libraw_unpack! Error: %s\\n\", libraw_strerror(err));\n        libraw_close(rawdata);\n        return -1;\n    }\n\n    \/\/ Camera &amp; user information \n    printf(\"Camera vendor: %s\\n\", rawdata-&gt;idata.make);\n    printf(\"Camera model: %s\\n\", rawdata-&gt;idata.model);\n    printf(\"Camera owner: %s\\n\", rawdata-&gt;other.artist);\n\n    \/\/ Date of shooting\n    char time_buf[25]; \n    struct tm *utc_tm = gmtime(&amp;rawdata-&gt;other.timestamp); \n    strftime(time_buf, 25, \"%Y-%m-%dT%H:%M:%S\", utc_tm);\n    printf(\"Date of shooting: %s\\n\", time_buf);\n\n    \/\/ Shooting params\n    printf(\"Exposure: %d\\n\", rawdata-&gt;other.shutter);\n    printf(\"Aperture: %d\\n\", rawdata-&gt;other.aperture);\n\n    err = libraw_raw2image(rawdata);\n\n    if (err != LIBRAW_SUCCESS) {\n        printf(\"libraw_raw2image failed! Error: %s\", libraw_strerror(err));\n        libraw_recycle(rawdata);\n        libraw_close(rawdata);\n        return -1;\n    }\n\n    err = libraw_dcraw_process(rawdata);\n\n    if (err != LIBRAW_SUCCESS) {\n        printf(\"libraw_dcraw_process failed! Error: %s\", libraw_strerror(err));\n        libraw_free_image(rawdata);\n        libraw_recycle(rawdata);\n        libraw_close(rawdata);\n        return -1;\n    }\n\n    libraw_processed_image_t *proc_img = libraw_dcraw_make_mem_image(rawdata, &amp;err);\n\n    libraw_free_image(rawdata);\n\n    if (!proc_img) {\n        printf(\"libraw_dcraw_make_mem_image failed! Error: %s\", libraw_strerror(err));\n        libraw_recycle(rawdata);\n        libraw_close(rawdata);\n        return -1;\n    }\n\n    printf(\"Image decoded, size = %ix%i, bits = %i, colors = %i\\n\", proc_img-&gt;width, proc_img-&gt;height, proc_img-&gt;bits, proc_img-&gt;colors);\n\n    libraw_recycle(rawdata);\n    libraw_close(rawdata);\n\n    \/\/\/\/\n    \/\/ Save decoded RAW image as JPEG file\n\n    \/\/ open file for writing\n    FILE *out_jpeg = fopen(argv[2], \"wb\");\n\n    if (out_jpeg == NULL) {\n        printf(\"Failed to open %s for writing\\n\", argv[2]);\n    }\n\n    \/\/ initialize libjpeg structures\n    struct jpeg_compress_struct cinfo;\n    struct jpeg_error_mgr jerr;\n    cinfo.err = jpeg_std_error(&amp;jerr);\n    jpeg_create_compress(&amp;cinfo);\n\n    \/\/ set output data stream\n    jpeg_stdio_dest(&amp;cinfo, out_jpeg);\n\n    cinfo.image_width = proc_img-&gt;width;\n    cinfo.image_height = proc_img-&gt;height;\n\n    \/\/ set image params - 3 components, RGB\n    cinfo.input_components = 3;\n    cinfo.in_color_space = JCS_RGB;\n\n    int quality = 85;\n\n    \/\/ configure decoder\n    jpeg_set_defaults(&amp;cinfo);\n    jpeg_set_quality(&amp;cinfo, quality, 1);\n    jpeg_start_compress(&amp;cinfo, 1);\n\n    JSAMPROW row_pointer;\n    int row_stride = cinfo.image_width * 3;\n\n    \/\/ write jpeg rows\n    while (cinfo.next_scanline &lt; cinfo.image_height) {\n        \/\/ get data from our proc_img-&gt;data buffer\n        row_pointer = (JSAMPROW) &amp;proc_img-&gt;data[cinfo.next_scanline * row_stride];\n        jpeg_write_scanlines(&amp;cinfo, &amp;row_pointer, 1);\n    }\n\n    \/\/ cleanup\n    jpeg_finish_compress(&amp;cinfo);\n    jpeg_destroy_compress(&amp;cinfo);\n\n    fclose(out_jpeg);\n\n    \/\/\/\n\n    return 0;\n}<\/pre>\n<p>Build and run:<\/p>\n<pre class=\"prettyprint\">$ gcc main.c -I\/usr\/local\/include -L\/usr\/local\/lib -lraw -ljpeg -std=c99 -o raw_test\n\n$ .\/raw_test RAW_CANON600D.CR2 test.jpg\nReading RAW data, step 1\/2\nReading RAW data, step 2\/2\nCamera vendor: Canon\nCamera model: EOS 600D\nCamera owner: \nDate of shooting: 2015-03-27T01:57:57\nExposure: 0\nAperture: 0\nScaling colors, step 1\/2\nScaling colors, step 2\/2\nPre-interpolating, step 1\/2\nPre-interpolating, step 2\/2\nInterpolating, step 1519\/3458\nInterpolating, step 2025\/3458\nConverting to RGB, step 1\/2\nConverting to RGB, step 2\/2\nImage decoded, size = 5202x3465, bits = 8, colors = 3\n<\/pre>\n<p>And results.<\/p>\n<p>Original RAW file (opened with Darktable):<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/darktable_raw.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-large wp-image-511\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/darktable_raw-1024x624.png\" alt=\"\" width=\"840\" height=\"512\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/darktable_raw-1024x624.png 1024w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/darktable_raw-300x183.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/darktable_raw-768x468.png 768w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/darktable_raw-1200x731.png 1200w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/darktable_raw.png 1603w\" sizes=\"(max-width: 840px) 100vw, 840px\" \/><\/a>Generated test.jpg:<\/p>\n<h5><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/test.jpg\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-513\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/test.jpg\" alt=\"\" width=\"800\" height=\"533\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/test.jpg 1000w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/test-300x200.jpg 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/05\/test-768x511.jpg 768w\" sizes=\"(max-width: 800px) 100vw, 800px\" \/><\/a>Additional image tuning<\/h5>\n<p>LibRaw allows us to configure some decoding params. We can disable interpolation, apply auto bright, and so on.<\/p>\n<p>Let&#8217;s apply auto bright to see how it works. Add following code before <strong>libraw_dcraw_process<\/strong>():<\/p>\n<pre class=\"prettyprint\">rawdata-&gt;params.no_auto_bright = 1;<\/pre>\n<p>Run the code again and check the result. Generated images should be darker and more natural.<\/p>\n<p>Try to disable interpolation with &#8220;rawdata-&gt;params.no_interpolation = 1&#8221; and check the result \ud83d\ude42<\/p>\n<h5>Dealing with different LibRaw versions<\/h5>\n<p>Using different versions of LibRaw, you can found that some functionality is not implemented yet or not working properly. Using special library macros, we can check the LibRaw version at compilation time and disable some code.<\/p>\n<pre class=\"prettyprint\">#if (LIBRAW_COMPILE_CHECK_VERSION_NOTLESS(0,17))\n    rawdata-&gt;params.no_auto_bright = 1;\n#else\n    #pragma message (\"LibRaw version is to old, unable to use image autobright\")\n#endif<\/pre>\n<p>&nbsp;<\/p>\n<p>Thanks for reading<\/p>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous article, I&#8217;m started to describe my Raw2Fits converter. It was a brief note about GTK user interface development. Now I want to talk about the LibRaw library. This is a great library for reading RAW files from digital photo cameras (CRW\/CR2, NEF, RAF, DNG, and others). Take a look at the LibRaw [&hellip;]<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[11,54],"tags":[13,56,55],"_links":{"self":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/496"}],"collection":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/comments?post=496"}],"version-history":[{"count":18,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/496\/revisions"}],"predecessor-version":[{"id":1739,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/496\/revisions\/1739"}],"wp:attachment":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/media?parent=496"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/categories?post=496"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/tags?post=496"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}