{"id":318,"date":"2018-02-21T15:20:17","date_gmt":"2018-02-21T12:20:17","guid":{"rendered":"http:\/\/olegkutkov.me\/?p=318"},"modified":"2021-02-04T22:00:18","modified_gmt":"2021-02-04T20:00:18","slug":"htu21d-raspberry-pi","status":"publish","type":"post","link":"https:\/\/olegkutkov.me\/2018\/02\/21\/htu21d-raspberry-pi\/","title":{"rendered":"Connecting HTU21D temperature\/humidity sensor to the Raspberry PI using simple C i2c interface"},"content":{"rendered":"<p><img loading=\"lazy\" decoding=\"async\" class=\"size-thumbnail wp-image-320 alignleft\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/SKU207382-1-150x150.jpg\" alt=\"\" width=\"150\" height=\"150\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/SKU207382-1-150x150.jpg 150w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/SKU207382-1-300x300.jpg 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/SKU207382-1.jpg 361w\" sizes=\"(max-width: 150px) 100vw, 150px\" \/>Previously in my projects, I&#8217;m always used well-known DHT22 (AM2302) temperature\/humidity sensors. But I found that these sensors are not very stable and subject to hung. In my case, this device is worked for about two weeks and then stops responding until the power is rebooted. This is absolutely unacceptable on some distant and autonomous devices. After some googling, I found that I&#8217;m not alone, and some peoples also experienced such a problem.<br \/>\nI&#8217;ve decided to replace these sensors with something more reliable and more accurate. My choice fell on HTU21D from the Measurement Specialties. HTU21D is a reliable and precise sensor, much newer than DHT, and uses a standard i2c bus instead of some 1-wire protocol. I want to describe the connection of this device to the Raspberry PI in detail.<\/p>\n<p><!--more--><\/p>\n<p>In one of my <a href=\"http:\/\/olegkutkov.me\/2017\/08\/10\/mlx90614-raspberry\/\">previous<\/a> articles, I&#8217;ve already described interfacing with I2C\/SMBus devices. In the current case, everything is much simpler, but some concepts are the same.<\/p>\n<p>Let&#8217;s check out the device <a href=\"https:\/\/cdn-shop.adafruit.com\/datasheets\/1899_HTU21D.pdf\">datasheet<\/a> first.<br \/>\nThe document says that we can send these commands to trigger some actions and then get the result:<\/p>\n\n<table id=\"tablepress-2\" class=\"tablepress tablepress-id-2\">\n<thead>\n<tr class=\"row-1 odd\">\n\t<th class=\"column-1\"><strong>Command<\/strong><\/th><th class=\"column-2\"><strong>Code<\/strong><\/th><th class=\"column-3\"><strong>Comment<\/strong><\/th>\n<\/tr>\n<\/thead>\n<tbody class=\"row-hover\">\n<tr class=\"row-2 even\">\n\t<td class=\"column-1\">Trigger Temperature Measurement<\/td><td class=\"column-2\">0xE3<\/td><td class=\"column-3\">Hold master<\/td>\n<\/tr>\n<tr class=\"row-3 odd\">\n\t<td class=\"column-1\">Trigger Humidity Measurement<\/td><td class=\"column-2\">0xE5<\/td><td class=\"column-3\">Hold master<\/td>\n<\/tr>\n<tr class=\"row-4 even\">\n\t<td class=\"column-1\">Trigger Temperature Measurement<\/td><td class=\"column-2\">0xF3<\/td><td class=\"column-3\">No Hold master<\/td>\n<\/tr>\n<tr class=\"row-5 odd\">\n\t<td class=\"column-1\">Trigger Humidity Measurement<\/td><td class=\"column-2\">0xF5<\/td><td class=\"column-3\">No Hold master<\/td>\n<\/tr>\n<tr class=\"row-6 even\">\n\t<td class=\"column-1\">Write user register<\/td><td class=\"column-2\">0xE6<\/td><td class=\"column-3\"><\/td>\n<\/tr>\n<tr class=\"row-7 odd\">\n\t<td class=\"column-1\">Read user register<\/td><td class=\"column-2\">0xE7<\/td><td class=\"column-3\"><\/td>\n<\/tr>\n<tr class=\"row-8 even\">\n\t<td class=\"column-1\">Soft Reset<\/td><td class=\"column-2\">0xFE<\/td><td class=\"column-3\"><\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<!-- #tablepress-2 from cache -->\n<p>&nbsp;<\/p>\n<p>Since the driver covers all low-level I2C level, we don&#8217;t worry about clocks and start\/stop sequences.\u00a0 Please read the <a href=\"http:\/\/olegkutkov.me\/2017\/08\/10\/mlx90614-raspberry\/\">MLX90614<\/a> article if you want to know details about this communication protocol.<\/p>\n<p>In the first case, the SCK line is blocked (controlled by the HTU21D sensor) during the measurement process, while in the second case, the SCK line remains open for other communication while the sensor is processing the measurement.<\/p>\n<p>The first variant is faster &#8211; you can get a result at once as measurements are made.<br \/>\nIn the case of the second variant &#8211; you have to poll the device with some timeout, waiting for the status &#8220;done&#8221;. Of course, a persistent request is not a good idea because you can flood the i2c line.<\/p>\n<p>I have multiple devices on the I2C bus in my device, so I chose the second variant with a 50 ms polling.<\/p>\n<h3><strong>Connecting to the Raspberry Pi.<\/strong><\/h3>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"alignleft wp-image-330\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/measurement-spec-htu21d-pic.png-300x230.jpeg\" alt=\"\" width=\"120\" height=\"92\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/measurement-spec-htu21d-pic.png-300x230.jpeg 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/measurement-spec-htu21d-pic.png.jpeg 592w\" sizes=\"(max-width: 120px) 100vw, 120px\" \/><\/p>\n<p>HUT21D is supplied in the small DFN package. This is good but may cause trouble with soldering.<br \/>\nFortunately, It&#8217;s easy to buy a breakout board with an already mounted HTU21D device and all required extra components.<\/p>\n<p>The connection of this board is also straightforward.<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/connection_to_rpi.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-331\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/connection_to_rpi.png\" alt=\"\" width=\"600\" height=\"489\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/connection_to_rpi.png 776w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/connection_to_rpi-300x245.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/connection_to_rpi-768x626.png 768w\" sizes=\"(max-width: 600px) 100vw, 600px\" \/><\/a><\/p>\n<p>The sensor is ready to use.<\/p>\n<h3 lang=\"en-US\"><strong>Programming<\/strong><\/h3>\n<p>There are many options to work with this sensor, using different libraries and programming languages. But in the current example, we will use a pure Linux i2c interface in C. This is the clearest and faster way to use our device.<\/p>\n<p>First of all, we need to load i2c_bcm2708 kernel module. We can do it with a <strong>modprobe<\/strong> command: <em>sudo modprobe i2c_bcm2708<\/em><\/p>\n<p>For automatically loading this module on every boot, add the module name to the end of the <em><span lang=\"ru-RU\">\/<\/span>etc<span lang=\"ru-RU\">\/<\/span>modules<\/em> file.<\/p>\n<p>After successful module loading you can find two new devices: <span lang=\"ru-RU\">\/<\/span>dev<span lang=\"ru-RU\">\/<\/span>i<span lang=\"ru-RU\">2<\/span>c<span lang=\"ru-RU\">-0 and \/<\/span>dev<span lang=\"ru-RU\">\/<\/span>i<span lang=\"ru-RU\">2<\/span>c<span lang=\"ru-RU\">-1. There are two separate i2c buses, and in the case of the first generation of the Raspberry \u2013 only i2c-1 is available on the GPIO header (GPIO2 and GPIO3). i2c-0 is available for manual soldering. In later Raspberry\u2019s models, both buses are available on the GPIO header.<\/span><\/p>\n<p>To check that the HTU21D device is properly connected and worked, run this command: <em>i<span lang=\"ru-RU\">2<\/span>cdetect<span lang=\"ru-RU\"> \u2013<\/span>y <\/em><span lang=\"ru-RU\"><em>1<\/em> (1 means \/dev\/i2c-1 device). This utility is available in the i2c-tools package.<br \/>\n<\/span><\/p>\n<p>HTU21 address is 0x40 and cannot be changed. And if everything is OK and the HTU device is lonely on the bus \u2013 you can see such output:<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-333\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/htu21_i2c.png\" alt=\"\" width=\"424\" height=\"159\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/htu21_i2c.png 424w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/htu21_i2c-300x113.png 300w\" sizes=\"(max-width: 424px) 100vw, 424px\" \/><\/p>\n<blockquote><p>Note: if you want to connect two sensor simultaneously the only way to do this is connect them to separate i2c buses which is available on the Raspberry board.<\/p><\/blockquote>\n<p>Now we ready to write code.<\/p>\n<p>Here is an initialization of the I2C interface for HTU21D, nothing extra:<\/p>\n<pre class=\"prettyprint\">#include &lt;sys\/ioctl.h&gt;\n#include &lt;sys\/types.h&gt;\n#include &lt;sys\/stat.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;string.h&gt;\n#include &lt;linux\/i2c-dev.h&gt;\n\n\nint fdev = open(\"\/dev\/i2c-1\", O_RDWR); \/\/ open i2c bus\n\nif (fdev &lt; 0) {\n    fprintf(stderr, \"Failed to open I2C interface %s Error: %s\\n\", dev_path, strerror(errno));\n    return -1;\n}\n\nunsigned char i2c_addr = 0x40;\n\n\/\/ set slave device address 0x40\nif (ioctl(fdev, I2C_SLAVE, i2c_addr) &lt; 0) {\n    fprintf(stderr, \"Failed to select I2C slave device! Error: %s\\n\", strerror(errno));\n    return -1;\n}<\/pre>\n<p>We got a regular file descriptor in dev, and we can send requests and read responses.<\/p>\n<p>The previous article communication protocol is complex and used SMBus transactions with structures and <strong>ioctl<\/strong>() calls.<br \/>\nNow, all we need is just a write() and read().<\/p>\n<p>According to the datasheet, to trigger the temperature measurements (in blocking mode), we need to send 0xE3, so let&#8217;s do this.<\/p>\n<pre class=\"prettyprint\">uint8_t buf[1];\nbuf[0] = 0xE3;\n\nwrite(fdev, buf, 1);<\/pre>\n<p>That&#8217;s all. Now we ready to get device response with <strong>read<\/strong>().<br \/>\nBecause we used <strong>0xE3<\/strong> command, we can just read on the descriptor, and this call will be blocked while measurements are in progress.<\/p>\n<p>But how many bytes we should read, and what we are actually reading?<br \/>\nAgain, let&#8217;s check out the device datasheet, page 11.<\/p>\n<blockquote><p>Measured data are transferred in two byte packages, i.e. in frames of 8-bit length where the most significant bit (MSB) is transferred first (left aligned). Each byte is followed by an acknowledge bit.<\/p>\n<p>Since the maximum resolution of the measurement is 14 bits, the two last least significant bits (LSBs, bits 43 and 44) are used for transmitting status information. Bit 1 of the two LSBs indicates the measurement type (\u20180\u2019: temperature, \u20181\u2019: humidity). Bit 0 is currently not assigned.<\/p><\/blockquote>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-334\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/htu21_protocol.png\" alt=\"\" width=\"782\" height=\"318\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/htu21_protocol.png 782w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/htu21_protocol-300x122.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/htu21_protocol-768x312.png 768w\" sizes=\"(max-width: 782px) 100vw, 782px\" \/><\/p>\n<p>Sensor data is split into three 8-bit parts, so we need to read three bytes: data1, data2, and checksum.<\/p>\n<pre class=\"prettyprint\">\/\/ device response, 14-bit ADC value:\n\/\/  first 8 bit part ACK  second 8 bit part        CRC\n\/\/ [0 1 2 3 4 5 6 7] [8] [9 10 11 12 13 14 15 16] [17 18 19 20 21 22 23 24]\n\/\/ bit 15 - measurement type (\u20180\u2019: temperature, \u20181\u2019: humidity)\n\/\/ bit 16 - currently not assigned\n\nuint8_t buf[3] = { 0 };\n\nread(fdev, buf, 3);<\/pre>\n<p>We can combine the first and second bytes into one 16 bit value, skipping two last least significant bits.<\/p>\n<pre class=\"prettyprint\">uint16_t sensor_data = (buf [0] &lt;&lt; 8 | buf [1]) &amp; 0xFFFC;<\/pre>\n<p>What next? Using this value, we can calculate actual temperature or humidity using some formulas (page 15 of the device datasheet).<\/p>\n<pre class=\"prettyprint\">\/\/ temperature\ndouble sensor_tmp = sensor_data \/ 65536.0;\ndouble result = -46.85 + (175.72 * sensor_tmp);\n\nprintf(\"Temperature: %.2f C\\n\", result);\n\n\n\/\/ humidity\nresult = -6.0 + (125.0 * sensor_tmp);\n\nprintf(\"Humidity: %.2f %%\\n\", result);<\/pre>\n<p>Little note about the checksum.<br \/>\nIn some simple applications, you can skip verification of the checksum and use data as is. But it would be best if you always remembered that sometimes you could get an error. This error may be caused by some malfunction with a sensor or some Interference on the i2c line.<br \/>\nSo it better to use some simple algorithm to calculate and verify crc8. You can found a lot of examples and ready-to-use functions.<br \/>\nIn my &#8220;production&#8221; application below, you can find such verification.<\/p>\n<h5>No hold master mode<\/h5>\n<p>This mode is preferred when you have multiple devices on your bus, so blocking this bus with one device may be bad.<\/p>\n<p>Temperature and humidity measurement operations can be triggered with 0xF3 and 0xF5 commands, and you can&#8217;t just call read() and wait. This call will return immediately with invalid data in the buffer.<br \/>\nCorrect behavior here is polling with some timeout. Typically this timeout is 50 ms.<br \/>\nSo you need to do read() every 50 ms and check how many actually bytes were read.<br \/>\nIf this count is less than 3 &#8211; try again after the timeout.<br \/>\nSome moderate values can limit retry count, but typically one 50 ms timeout is enough.<\/p>\n<pre class=\"prettyprint\">uint8_t buf[3] = { 0 };\nint counter = 0;\n\nwhile (1) {\n    usleep(50000); \/\/ 50 ms\n    counter++;\n\n    if (read(fdev, buf, 3) != 3) {\n        if (counter &gt;= 5) {\n            break;\n        }\n\n        continue;\n    }\n\n    break;\n}<\/pre>\n<p>If you are interested, which is the difference in reading time between the two modes &#8211; it is quite noticeable but not critical.<\/p>\n<p><strong>No hold master.<\/strong><\/p>\n<pre class=\"prettyprint\">$ time .\/read_htu21d \ntemp=18.99 humidity=33.06\n\nreal    0m0.130s\nuser    0m0.000s\nsys 0m0.000s\n<\/pre>\n<p><strong>Hold master.<\/strong><\/p>\n<pre class=\"prettyprint\">$ time .\/read_htu21d -l\ntemp=19.00 humidity=33.05\n\nreal    0m0.087s\nuser    0m0.000s\nsys 0m0.010s\n<\/pre>\n<p>Of course, it might be critical for some hard real-time applications.<\/p>\n<h5>Soft reset.<\/h5>\n<p>It&#8217;s recommended to perform the software reset of the sensors before any measurements.<br \/>\nA soft reset can be done by sending <strong>0xFE<\/strong> command. After this, you should wait at least 15 ms. This time is required for the correct and full startup of the device.<\/p>\n<p>Full source code of the HTU21D utility you can find on my <a href=\"https:\/\/github.com\/olegkutkov\/allsky\/tree\/master\/src\/utils\/htu21d\">GitHub here<\/a>.<\/p>\n<p>Compilation and usage are pretty simple and described in a README.<\/p>\n<p><strong>P.S.<\/strong><\/p>\n<p>There is another variant of this sensor &#8211; SHT21 from the Sensirion.<br \/>\nThis sensor has the same pinout as HTU21D and uses the same protocol, even the same I2C address. So this code can be used with both types of sensors without any modifications.<\/p>\n<p>Thanks for reading!<\/p>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Previously in my projects, I&#8217;m always used well-known DHT22 (AM2302) temperature\/humidity sensors. But I found that these sensors are not very stable and subject to hung. In my case, this device is worked for about two weeks and then stops responding until the power is rebooted. This is absolutely unacceptable on some distant and autonomous [&hellip;]<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[4,30,25],"tags":[36,27,7,37],"_links":{"self":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/318"}],"collection":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/comments?post=318"}],"version-history":[{"count":23,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/318\/revisions"}],"predecessor-version":[{"id":1745,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/318\/revisions\/1745"}],"wp:attachment":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/media?parent=318"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/categories?post=318"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/tags?post=318"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}