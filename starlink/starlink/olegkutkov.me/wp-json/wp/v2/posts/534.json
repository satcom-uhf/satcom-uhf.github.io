{"id":534,"date":"2018-06-07T01:40:37","date_gmt":"2018-06-06T22:40:37","guid":{"rendered":"http:\/\/olegkutkov.me\/?p=534"},"modified":"2021-02-05T16:21:15","modified_gmt":"2021-02-05T14:21:15","slug":"autonomous-allsky-camera-with-raspberry-pi-part-3-shooting-night-sky-in-fits-using-qhy5-iim-camera","status":"publish","type":"post","link":"https:\/\/olegkutkov.me\/2018\/06\/07\/autonomous-allsky-camera-with-raspberry-pi-part-3-shooting-night-sky-in-fits-using-qhy5-iim-camera\/","title":{"rendered":"Autonomous Allsky camera with Raspberry PI. Part 3: shooting night sky in FITS using QHY5-IIM camera"},"content":{"rendered":"<p><img loading=\"lazy\" decoding=\"async\" class=\"alignleft size-thumbnail wp-image-492\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/03\/cam1-1-150x150.jpg\" alt=\"\" width=\"150\" height=\"150\" \/>This is the third part of the Allsky cycle.<\/p>\n<p>Please read previous articles to get complete information about this project:<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/2018\/03\/20\/autonomous-allsky-camera-with-raspberry-pi-part-1-overview\/\">Part 1. Autonomous Allsky camera with Raspberry PI: an overview.<\/a><br \/>\n<a href=\"http:\/\/olegkutkov.me\/2018\/03\/22\/autonomous-allsky-camera-with-raspberry-pi-part-2-powering-and-lightning-protection\/\">Part 2. Autonomous Allsky camera with Raspberry PI: powering and lightning protection<\/a><\/p>\n<p>This time I will show my utility and script for shooting the night sky and processing the images.<\/p>\n<p><!--more--><\/p>\n<h3>Camera module and iris control<\/h3>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-410\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/03\/cam_modules-300x160.png\" alt=\"\" width=\"519\" height=\"277\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/03\/cam_modules-300x160.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/03\/cam_modules-768x409.png 768w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/03\/cam_modules.png 1016w\" sizes=\"(max-width: 519px) 100vw, 519px\" \/><\/p>\n<p>In this project, I&#8217;m using a popular and cheap QHY5-IIM CMOS camera.<br \/>\nAn aluminum ring holds this camera (came with the camera).<br \/>\nOptics &#8211; CCTV, &#8220;\u0421omputar 1.8-3.6mm 1.6&#8221; with motorized iris. This helps to protect the CMOS sensor in the daytime. Also, we can shoot special calibration images &#8211; darks and biases. The calibration process will be described below.<\/p>\n<p>To able to control this iris, I did a little research on lens electronics. The motor is controlled with few operational amplifiers. I found that pulling down one of the opamp inputs causes closing the iris (default state is open). Adding a simple NPN transistor key can control this iris with GPIO signals from the Raspberry.<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/iris_mod_schem.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-537\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/iris_mod_schem-300x231.png\" alt=\"\" width=\"397\" height=\"306\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/iris_mod_schem-300x231.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/iris_mod_schem.png 752w\" sizes=\"(max-width: 397px) 100vw, 397px\" \/><\/a>Diode D1 is used as a protection circuit for the GPIO. C1 is a bypass capacitor that helps to protect whole circuits from possible voltage transients.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-536\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/iris_motor_mod-300x200.jpg\" alt=\"\" width=\"501\" height=\"334\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/iris_motor_mod-300x200.jpg 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/iris_motor_mod-768x512.jpg 768w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/iris_motor_mod.jpg 1024w\" sizes=\"(max-width: 501px) 100vw, 501px\" \/><\/p>\n<p>This controlling circuit is connected to the Raspberry GPIO pin 16 (but you can use any free pin). The software is straightforward.<\/p>\n<p>To easily access the GPIO, I&#8217;m using the popular bcm2835 library. One of the versions is the in-camera <a href=\"https:\/\/github.com\/olegkutkov\/allsky\/tree\/master\/3rd\/bcm2835-1.52\">GitHub repository<\/a>. You need to compile and install this library.<\/p>\n<pre class=\"prettyprint\">#include <span class=\"pl-s\"><span class=\"pl-pds\">&lt;<\/span>stdio.h<span class=\"pl-pds\">&gt;<\/span><\/span>\n#include <span class=\"pl-s\"><span class=\"pl-pds\">&lt;<\/span>bcm2835.h<span class=\"pl-pds\">&gt;<\/span><\/span>\n#include <span class=\"pl-s\"><span class=\"pl-pds\">&lt;<\/span>unistd.h<span class=\"pl-pds\">&gt;<\/span><\/span>\n\n#define IRIS_PIN RPI_GPIO_P1_16\n\nint main(int argc, char **argv)\n{\n    if (argc == 1) {\n        return 1;\n    }\n\n    if (!bcm2835_init()) {\n        fprintf(stderr, \"Failed to initialize bcm2835\\n\");\n        return 1;\n    }\n\n    bcm2835_gpio_fsel(IRIS_PIN, BCM2835_GPIO_FSEL_OUTP);\n\n    char arg = *argv[1];\n\n    switch (arg) {\n        case 'o':\n            printf(\"IRIS - open\\n\");\n            bcm2835_gpio_write(IRIS_PIN, LOW);\n            break;\n\n        case 'c':\n            printf(\"IRIS - close\\n\");\n            bcm2835_gpio_write(IRIS_PIN, HIGH);\n            break;\n\n        default:\n            break;\n    }\n\n    bcm2835_close();\n\n    return 0;\n}\n<\/pre>\n<p>Compilation<\/p>\n<pre class=\"prettyprint\">gcc -Wall -std=gnu99 main.c -l bcm2835 -lrt -o iris_control\n<\/pre>\n<p>Now we can open and close our iris with commands<strong> iris_control 0<\/strong> and <strong>iris_close c<\/strong>, respectively.<\/p>\n<h3>QHY5-IIM camera software<\/h3>\n<p>The source code of the camera utility is written in C++ and also available on <a href=\"https:\/\/github.com\/olegkutkov\/allsky\/tree\/master\/src\/skycam\">GitHub<\/a>. This program is doing shots with selected gain\/exposure time params. Results are saving as FITS files.<\/p>\n<p>FITS is an open standard defining a digital file format useful for storing, transmitting, and processing scientific and other images. FITS is the most commonly used digital file format in astronomy. Unlike many image formats, FITS is designed specifically for scientific data and hence includes many provisions for describing photometric and spatial calibration information, together with image origin metadata. Image data in the FITS is uncompressed, which is very good for the next processing steps.<\/p>\n<p>The core of this program is a QHYCCD protocol taken from the official repository of the vendor (now this source is removed for some reason). You can find protocol implementation in a <strong>qhy5ii.cpp<\/strong> file.<\/p>\n<p>Communication with the camera is made through <strong>libusb<\/strong>.<\/p>\n<p>Here is interface claiming and initialization. All we need is a VID and PID of the device.<\/p>\n<pre class=\"prettyprint\">#define QHY5II_VENDOR_ID   0x1618\n#define QHY5II_PRODUCT_ID 0x0921\n\nstruct libusb_device_handle *handle = libusb_open_device_with_vid_pid(NULL, QHY5II_VENDOR_ID, QHY5II_PRODUCT_ID);\n\nif (!handle) {\n    return QHYCCD_ERROR_NO_DEVICE;\n}\n\nif( libusb_kernel_driver_active(handle, 0)) {\n       libusb_detach_kernel_driver(handle, 0);\n}\n\nint open_status = libusb_set_configuration(handle, 1);\n\nif (libusb_claim_interface(handle, 0) != 0) {\n    return QHYCCD_ERROR_INITRESOURCE;\n}\n<\/pre>\n<p>Now we got libusb handle and can send commands and data requests to the device using <strong>libusb_control_transfer<\/strong><\/p>\n<pre class=\"prettyprint\">int libusb_control_transfer    (   libusb_device_handle *      dev_handle,\n        uint8_t     bmRequestType,\n        uint8_t     bRequest,\n        uint16_t    wValue,\n        uint16_t    wIndex,\n        unsigned char *     data,\n        uint16_t    wLength,\n        unsigned int    timeout \n    )   \n<\/pre>\n<p>All we need to know is a vendor&#8217;s &#8220;magic&#8221; numbers for the commands and options. You can find everything in source files. Check out functions <a href=\"https:\/\/github.com\/olegkutkov\/allsky\/blob\/master\/src\/skycam\/src\/qhy5ii.cpp#L462\">CtrlMsg<\/a> and <a href=\"https:\/\/github.com\/olegkutkov\/allsky\/blob\/master\/src\/skycam\/src\/qhy5ii.cpp#L479\">EepromRead<\/a>, for example.<\/p>\n<p>The whole exposure flow is also simple:<\/p>\n<ol>\n<li>open device<\/li>\n<li>set resolution<\/li>\n<li>set gain<\/li>\n<li>set exposure time<\/li>\n<li>prepare buffer for the image<\/li>\n<li>start expositions process<\/li>\n<li>wait for data<\/li>\n<li>verify data<\/li>\n<li>stop expositions process<\/li>\n<li>close device<\/li>\n<\/ol>\n<p>You can find functions in my source for each of these steps. The function&#8217;s names are corresponding to what they are doing.<\/p>\n<p>The frame buffer is an unsigned char array with the size of the image width * height. This array is holding a 2d matrix of the image, line by line. Every byte represents one pixel with a value from 0 (black) to 255 (white). In this way, data is writing into the FITS file.<\/p>\n<p>Writing and reading FITS files are made using the cfitsio library. I wrote a little wrapper C++ class <a href=\"https:\/\/github.com\/olegkutkov\/allsky\/blob\/master\/src\/skycam\/src\/fits_handler.cpp\">FitsHandler<\/a>. This class is holding an image buffer and can write this buffer to the new FITS file and load it from some existing file. Also, can be set FITS header data.<\/p>\n<p>Opening existing and creating new FITS files:<\/p>\n<pre class=\"prettyprint\">fitsfile *fhandle;\nint status = 0;\n\n\/\/ opening existing FITS\nfits_open_file(&amp;fhandle, \"old_image.fits\", READONLY, &amp;status);\n\n\/\/\/\n\/\/ creating new FITS\n<span class=\"pl-c1\">fits_create_file<\/span>(&amp;fhandle, \"new_image.fits\", &amp;status);\n\nif (status != 0) {\n    \/\/ error\n}\n<\/pre>\n<p><em>Important note!<\/em><br \/>\n<em>Never try to call<strong> fits_create_file()<\/strong> on existing file. This function doesn&#8217;t support overwriting, and errors will be raised.<\/em><br \/>\n<em>Existing file must be removed (with <a href=\"http:\/\/man7.org\/linux\/man-pages\/man2\/unlink.2.html\"><strong>unlink()<\/strong><\/a>, for example) before calling <strong>fits_create_file()<\/strong>.<\/em><\/p>\n<p>Getting image size and loading image data as uint16_t array from the FITS file:<\/p>\n<pre class=\"prettyprint\">int status = 0;\nint bitpix;\nlong anaxes[2] = { 1, 1 };\n\nfits_get_img_size(fhandle, 2, anaxes, &amp;status);\n\nint image_width = anaxes[0];\nint image_height = anaxes[1];\n\nfits_get_img_type(fhandle, &amp;bitpix, &amp;status);\n\nif (status != 0) {\n    \/\/\/ error\n}\n\nlong firstpix[2] = { 1, 1 };\nsize_t numpix = image_width * image_height;\n\nuint16_t *imagebuf = new uint16_t(numpix);\n\nfits_read_pix(fhandle, TUSHORT, firstpix, numpix, NULL, imagebuf-&gt;Raw(), NULL, &amp;status);\n\n\/\/\/ image processing\n\ndelete[] imagebuf;\n<\/pre>\n<p>TUSHORT specifies the data type of our buffer, possible values are:<\/p>\n<pre>  TBYTE     unsigned char\n  TSBYTE    signed char\n  TSHORT    signed short\n  TUSHORT   unsigned short\n  TINT      signed int\n  TUINT     unsigned int\n  TLONG     signed long\n  TLONGLONG signed 8-byte integer\n  TULONG    unsigned long\n  TFLOAT    float\n  TDOUBLE   double<\/pre>\n<p>The correct type of data can be chosen by <strong>bitpix<\/strong> value, which was initialized with <strong>fits_get_img_type().<\/strong><\/p>\n<p>Writing image buffer to the FITS file:<\/p>\n<pre class=\"prettyprint\">unsigned int naxis = 2;\nlong naxes[2] = { image_width, image_height };\nlong fpx[2] = { 1L, 1L };\nint status = 0;\n\nfits_create_img(fhandle, bitpixel, naxis, naxes, &amp;status);\nfits_write_pix(fhandle, TUSHORT, fpx, image_width * image_height, imagebuf, &amp;status);\n<\/pre>\n<p>imagebuf can be filled with data from the actual device.<\/p>\n<p>Always check status. Non-zero values mean that something goes wrong.<\/p>\n<p>An additional and handy feature of this class is the subtraction of the images. This method subtracts one image matrix from another. Simple arithmetic method.<\/p>\n<pre class=\"prettyprint\">for (long i = 0; i &lt; imgwidth * imgheight; ++i) {\n    imagebuf_a[i] -= imagebuf_b[i];\n}\n<\/pre>\n<p>Both image buffers must be the same size.<\/p>\n<p>By subtracting frames, we can remove CMOS matrix noise and amplifier noise.<br \/>\nThis can be done by using special calibration files &#8211; dark and bias.<br \/>\nThis is a regular FITS file shooted with this QHY utility.<\/p>\n<p>The dark file is shooting with closed iris and with long exposure and big gain, just like a normal exposition.<br \/>\nThe resulting image contains only hot pixels and matrix noise on dark background.<\/p>\n<p>Typical dark:<br \/>\n<a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/dark.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-550\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/dark-300x187.png\" alt=\"\" width=\"340\" height=\"212\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/dark-300x187.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/dark.png 711w\" sizes=\"(max-width: 340px) 100vw, 340px\" \/><\/a><\/p>\n<p>Bias is the same, but the only gain is high. Exposure is the fastest as possible &#8211; 1ms, for example.<br \/>\nThe resulting image contains only the noise of the amplifier (and ADC probably).<\/p>\n<p>Typical bias:<a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/bias.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-551\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/bias-300x224.png\" alt=\"\" width=\"347\" height=\"259\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/bias-300x224.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/06\/bias.png 733w\" sizes=\"(max-width: 347px) 100vw, 347px\" \/><\/a><\/p>\n<p>By subtracting the dark\/bias matrix, we can remove all these pixel values and get a clearer image of the sky.<\/p>\n<p>It&#8217;s always a good idea to subtract the bias from the image itself and the dark image.<\/p>\n<p>Fits header is a simple key-value pair in ASCII (usually). Typical content is file creation date, object, coordinates, conditions, and additional technical information.<\/p>\n<p>FITS header data row can be written with function:<\/p>\n<pre class=\"prettyprint\">int fits_write_key(fitsfile *fptr, int datatype, char *keyname, DTYPE *value, char *comment, int *status)\n<\/pre>\n<p>Writing FITS creation date and time (in a standardized way), for example:<\/p>\n<pre class=\"prettyprint\">#include &lt;time.h&gt;\n#include &lt;string.h&gt;\n\nint status = 0;\nchar time_now[25];\ntime_t lt = time(NULL);\nstruct tm *utc_tm = gmtime(&amp;lt);\n\nstrftime(time_now, 25, \"%Y-%m-%dT%H:%M:%S\", utc_tm);\n\nfits_write_key(fhandle, TSTRING, \"DATE\", time_now, \"Fits creation date, UTC\", &amp;status);\n<\/pre>\n<p>Calibration files and fits header data is passed to the QHY program as arguments. Please refer <a href=\"https:\/\/github.com\/olegkutkov\/allsky\/blob\/master\/src\/skycam\/src\/main.cpp#L281\">main.cpp<\/a> to see how all this logic works.<\/p>\n<p>Usage of the QHY utility (30 is gain and 30000 is exposure time in ms):<\/p>\n<pre class=\"prettyprint\">iris_control c\nqhy_camera -m qhy5ii -e 1 -g 30 -o bias.fits\nqhy_camera -m qhy5ii -e 30000 -g 30 -o dark.fits\niris_control o\nqhy_camera -m qhy5ii -e 30000 -g 30 -o image.fits -b bias.fits -k dark.fits -x fits_header.dat\n<\/pre>\n<p>Example of the fits_header.dat:<\/p>\n<pre>CREATOR Allsky camera\nINSTRUME QHY5-IIM\nEXPTIME 30.0\nTEMPERAT 16.07\nHUMIDITY 84.41\nSKYTEMP -2.12\nOBSERVAT Crimean astrophysical observatory\nSITENAME Nauchniy, Crimea\nSITELAT 44.727007\nSITELONG 34.013173\nSITEELEV 600<\/pre>\n<p>The left column is a key, and the right is a value.<\/p>\n<p>Let&#8217;s check our resulting fits:<\/p>\n<pre>$ hexdump -e '80\/1 \"%_p\" \"\\n\"' image.fits | head -n22\nSIMPLE = T \/ file does conform to FITS standard \nBITPIX = 8 \/ number of bits per data pixel \nNAXIS = 2 \/ number of data axes \nNAXIS1 = 1280 \/ length of data axis 1 \nNAXIS2 = 960 \/ length of data axis 2 \nEXTEND = T \/ FITS dataset may contain extensions \nCOMMENT FITS (Flexible Image Transport System) format is defined in 'Astronomy\nCOMMENT and Astrophysics', volume 376, page 359; bibcode: 2001A&amp;A...376..359H \nDATE = '2018-06-06T22:34:57' \/ Fits creation date, UTC \nCREATOR = 'Allsky camera' \nINSTRUME= 'QHY5-IIM' \nEXPTIME = '30.0 ' \nTEMPERAT= '16.07 ' \nHUMIDITY= '84.41 ' \nSKYTEMP = '-2.12 ' \nOBSERVAT= 'Crimean astrophysical observatory' \nSITENAME= 'Nauchniy, Crimea' \nSITELAT = '44.727007' \nSITELONG= '34.013173' \nSITEELEV= '600 ' \nEND<\/pre>\n<p>Below this header is the binary data of the image.<\/p>\n<p>In the next article, I will describe astrocamera script where most of the camera logic is done.<\/p>\n<p>Thanks for reading!<\/p>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n","protected":false},"excerpt":{"rendered":"<p>This is the third part of the Allsky cycle. Please read previous articles to get complete information about this project: Part 1. Autonomous Allsky camera with Raspberry PI: an overview. Part 2. Autonomous Allsky camera with Raspberry PI: powering and lightning protection This time I will show my utility and script for shooting the night [&hellip;]<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[4,11,30,54],"tags":[],"_links":{"self":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/534"}],"collection":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/comments?post=534"}],"version-history":[{"count":22,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/534\/revisions"}],"predecessor-version":[{"id":1755,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/534\/revisions\/1755"}],"wp:attachment":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/media?parent=534"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/categories?post=534"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/tags?post=534"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}