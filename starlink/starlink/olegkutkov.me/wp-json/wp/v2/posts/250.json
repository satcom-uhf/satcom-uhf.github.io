{"id":250,"date":"2018-02-14T02:38:20","date_gmt":"2018-02-13T23:38:20","guid":{"rendered":"http:\/\/olegkutkov.me\/?p=250"},"modified":"2021-02-11T16:16:24","modified_gmt":"2021-02-11T14:16:24","slug":"monitoring-linux-networking-state-using-netlink","status":"publish","type":"post","link":"https:\/\/olegkutkov.me\/2018\/02\/14\/monitoring-linux-networking-state-using-netlink\/","title":{"rendered":"Monitoring Linux networking state using netlink"},"content":{"rendered":"<p><img loading=\"lazy\" decoding=\"async\" class=\"alignleft wp-image-255 size-thumbnail\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/nemon_example-150x150.png\" alt=\"\" width=\"150\" height=\"150\" \/>Once in my work, I needed to monitor all changes in the Linux networking subsystem: adding or deleting IP addresses, routes, etc.<br \/>\nMaybe the best way to do this is to use socket-based Netlink technology. Using Netlink, we can &#8220;subscribe&#8221; to some network-related notifications from the kernel. It&#8217;s also possible to send commands to the network stack and change the routing table, interface configurations, and packet filtering. For example, popular utilities like &#8220;iproute2&#8221; are also using Netlink to do their job.<br \/>\nThe easiest way to access Netlink sockets from the userspace is to use <a href=\"https:\/\/www.infradead.org\/~tgr\/libnl\/doc\/core.html\">a libnetlink<\/a> library, which provides many macros, defines, and functions.<br \/>\nThe worst part of this library and whole Netlink technology is a lack of good examples.<br \/>\nIn this case, a good solution is using iproute2 source code to discover things you interesting in. This article is also may be used as a good startup point.<\/p>\n<p><!--more--><\/p>\n<h3>Introduction in Netlink<\/h3>\n<p>The Netlink is a socket-based Linux kernel interface used for inter-process communication (IPC) between both the kernel and userspace processes and between different userspace processes, in a way similar to the Unix domain sockets.<\/p>\n<p>Like the Unix domain sockets, unlike INET sockets, Netlink communication cannot traverse host boundaries.<br \/>\nHowever, while the Unix domain sockets use the file system namespace, Netlink processes are addressed by process identifiers (PIDs).<\/p>\n<p>Communication with Netlink is made using a separate socket&#8217;s family &#8211; <strong>AF_NETLINK<\/strong>.<br \/>\nEvery Netlink message contains a header, represented with <strong>nlmsghdr<\/strong> structure. After the header may be attached some payload: some special structure or RAW data.<br \/>\nNetlink can split big messages into multiple parts. In such a case, every &#8220;partial&#8221; package is marked with <strong>NLM_F_MULTI<\/strong> flag, and the last package is marked with <strong>NLMSG_DONE<\/strong> flag.<\/p>\n<p>There are a lot of useful macros that can help us to parse Netlink messages.<br \/>\nEverything is defined in Netlink.h and rtnetlink.h header files.<\/p>\n<p>Creating of Netlink socket is pretty standard.<\/p>\n<pre class=\"prettyprint\">socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE)<\/pre>\n<p>where:<br \/>\n<strong>AF_NETLINK<\/strong> \u2014 netlink domain<br \/>\n<strong>SOCK_RAW<\/strong> \u2014 raw socket<br \/>\n<strong>NETLINK_ROUTE<\/strong> \u2014 required protocol.<\/p>\n<p>In particular, <strong>NETLINK_ROUTE<\/strong> is used for routing and link information.<\/p>\n<p>All available protocols can be found in the documentation. Here is a list of the most interesting:<\/p>\n<ul>\n<li><strong>NETLINK_ROUTE \u2014 <\/strong>routing and link information, monitoring and configuration routines<\/li>\n<li><strong>NETLINK_FIREWALL<\/strong> \u2014 transfer packets to userspace from the firewall<\/li>\n<li><strong>NETLINK_INET_DIAG<\/strong> \u2014 information about sockets of various protocol families<\/li>\n<li><strong>NETLINK_NFLOG<\/strong> \u2014 Netfilter\/iptables ULOG<\/li>\n<li><strong>NETLINK_SELINUX<\/strong> \u2014 SELinux event notifications<\/li>\n<li><strong>NETLINK_NETFILTER<\/strong> \u2014 communications with Netfilter subsystem<\/li>\n<li><strong>NETLINK_KOBJECT_UEVENT<\/strong> \u2014 get kernel messages<\/li>\n<li><strong>NETLINK_USERSOCK<\/strong> \u2014 reserved for user-defined protocols<\/li>\n<\/ul>\n<h3>Communication<\/h3>\n<p>All communications through the Netlink socket is made with two well-known structures: <strong>msghdr<\/strong> and <strong>iovec<\/strong>.<\/p>\n<pre class=\"prettyprint\">struct iovec\n{\n    void *iov_base; \/\/ data buff\n    __kernel_size_t iov_len; \/\/ size of the data\n};<\/pre>\n<p>This structure contains a link to the actual message buffer with some data and its size.<\/p>\n<pre class=\"prettyprint\">struct msghdr {\n    void *msg_name; \/\/ client addr (socket name)\n    int msg_namelen; \/\/ length of the client addr\n    struct iovec *msg_iov; \/\/ pointer to the iovec structure with message data\n    __kernel_size_t msg_iovlen; \/\/ count of the data blocks\n    void *msg_control; \/\/ points to a buffer for other protocol control-related messages or miscellaneous ancillary data. \n    __kernel_size_t msg_controllen; \/\/ length of the msg_control\n    unsigned  msg_flags; \/\/ flags on received message\n};\n<\/pre>\n<p>struct <strong>msghdr<\/strong> can be directly passed to socket&#8217;s <strong>recvmsg<\/strong> and <strong>sendmsg<\/strong> and used to minimize the number of directly supplied arguments.<\/p>\n<p>This structure is defined in <em>&lt;sys\/socket.h&gt;<\/em><\/p>\n<p>See <a href=\"https:\/\/linux.die.net\/man\/2\/recvmsg\">recvmsg<\/a> and <a href=\"https:\/\/linux.die.net\/man\/2\/sendmsg\">sendmsg<\/a> for details.<\/p>\n<p>A Netlink message stored in <strong>iovec<\/strong> typically contains a Netlink message header (<strong>struct nlmsghdr<\/strong>) and the payload attached. The payload can consist of arbitrary data but usually contains a fixed size protocol-specific header followed by a stream of attributes.<\/p>\n<pre class=\"prettyprint\">struct nlmsghdr\n{\n    __u32 nlmsg_len; \/\/ message size, include this header\n    __u16 nlmsg_type; \/\/ message type (see below)\n    __u16 nlmsg_flags; \/\/ message flags (see below)\n    __u32 nlmsg_seq; \/\/ sequence number\n    __u32 nlmsg_pid; \/\/ sender identifier (typically - process id)\n};<\/pre>\n<div class=\"paragraph\">\n<p>The following standard message types are defined:<\/p>\n<ul>\n<li><strong>NLMSG_NOOP<\/strong> &#8211; No operation, a message must be discarded<\/li>\n<li><strong>NLMSG_ERROR<\/strong> &#8211; Error message or ACK, see Error Message respectively ACKs<\/li>\n<li><strong>NLMSG_DONE<\/strong> &#8211; End of multipart sequence, see Multipart Messages<\/li>\n<li><strong>NLMSG_OVERRUN<\/strong> &#8211; Overrun notification (Error)<\/li>\n<\/ul>\n<blockquote><p>Every netlink protocol is free to define own message types. Note that message type values <code>&lt; NLMSG_MIN_TYPE (0x10)<\/code> are reserved and may not be used.<\/p><\/blockquote>\n<div class=\"paragraph\">\n<p>The following standard flags are defined:<\/p>\n<ul>\n<li><strong>NLM_F_REQUEST<\/strong> \u2014 Request message<\/li>\n<li><strong>NLM_F_MULTI<\/strong> \u2014 Part of the multipart message<\/li>\n<li><strong>NLM_F_ACK<\/strong> \u2014 Acknowledge requested<\/li>\n<li><strong>NLM_F_ECHO<\/strong> \u2014 Request to echo this request; typical direction is from kernel to user<\/li>\n<li><strong>NLM_F_ROOT<\/strong> \u2014 Return based on the root of the tree<\/li>\n<li><strong>NLM_F_MATCH<\/strong> \u2014 Return all matching entries<\/li>\n<li><strong>NLM_F_ATOMIC<\/strong> \u2014 Is obsolete now, used to request an atomic operation<\/li>\n<li><strong>NLM_F_DUMP<\/strong> \u2014 Same as <strong>NLM_F_ROOT|NLM_F_MATCH<\/strong><\/li>\n<\/ul>\n<p>The client&#8217;s identifications (user and kernel spaces) are made with structure <strong>sockaddr_nl.<\/strong><\/p>\n<\/div>\n<\/div>\n<pre class=\"prettyprint\">struct sockaddr_nl\n{\n    sa_family_t nl_family; \/\/ always AF_NETLINK\n    unsigned short nl_pad; \/\/ typically filled with zeros\n    pid_t nl_pid; \/\/ client identifier (process id)\n    __u32 nl_groups; \/\/ mask for senders\/recivers group\n};<\/pre>\n<p><strong>nl_pid<\/strong> &#8211; unique socket identifier, for the kernel sockets, this value is always zero. On the userspace, typically used current process id. This may cause problems in multithreading applications if multiple threads are trying to create and use Netlink sockets.<br \/>\nTo work around this, we can initialize every nl_pid with this construction:<\/p>\n<pre class=\"prettyprint\">pthread_self() &lt;&lt; 16 | getpid()<\/pre>\n<p><strong>nl_groups<\/strong> \u2014 is a special bitmask of Netlink groups. This value is used after calling bind() on the Netlink socket to &#8220;subscribe&#8221; to specified groups&#8217; events.<br \/>\nThis is what we gonna use in our current task &#8211; network monitoring.<\/p>\n<p>The definition of all groups can be found in the Netlink header file.<br \/>\nHere is some of them, which we can use in the current situation:<\/p>\n<ul>\n<li><strong>RTMGRP_LINK<\/strong> \u2014 notifications about changes in network interface (up\/down\/added\/removed)<\/li>\n<li><strong>RTMGRP_IPV4_IFADDR<\/strong> \u2014 notifications about changes in IPv4 addresses (address was added or removed)<\/li>\n<li><strong>RTMGRP_IPV6_IFADDR<\/strong> \u2014 same for IPv6<\/li>\n<li><strong>RTMGRP_IPV4_ROUTE<\/strong> \u2014 notifications about changes in IPv4 routing table<\/li>\n<li><strong>RTMGRP_IPV6_ROUTE<\/strong> \u2014 same for IPv6<\/li>\n<\/ul>\n<h5>Netlink message payload<\/h5>\n<p>As I already said &#8211; after the header, we can found some payload, which may be split into parts. Libnetlink contains several macros that are extremely helpful in accessing and checking message payload.<\/p>\n<p>Some most useful:<\/p>\n<ul>\n<li><strong>NLMSG_DATA<\/strong> \u2014 Get pointer to the message payload<\/li>\n<li><strong>NLMSG_PAYLOAD<\/strong> \u2014 Get the actual size of the message payload<\/li>\n<li><strong>NLMSG_ALIGN<\/strong> \u2014 Rounds the message size to the nearest aligned value<\/li>\n<li><strong>NLMSG_LENGTH<\/strong> \u2014 Get the size of the payload and returns a correct aligned value<\/li>\n<li><strong>NLMSG_SPACE<\/strong> \u2014 Get the actual size of the data in the Netlink packet<\/li>\n<li><strong>NLMSG_NEXT<\/strong> \u2014 Get the next part of the multipart message. When using these macros, it&#8217;s important to check for <strong>NLMSG_DONE<\/strong> message flag to avoid buffer overruns.<\/li>\n<li><strong>NLMSG_OK<\/strong> \u2014 Returns true if the message is correct and was successfully parsed<\/li>\n<\/ul>\n<h3>Practical usage of Netlink<\/h3>\n<p>Okay, I think that it&#8217;s enough of boring theory \ud83d\ude42<br \/>\nTime to write some code and testing of the application.<\/p>\n<p>Here is the full source code:<\/p>\n<pre class=\"prettyprint\">#include &lt;errno.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;memory.h&gt;\n#include &lt;net\/if.h&gt;\n#include &lt;arpa\/inet.h&gt;\n#include &lt;sys\/socket.h&gt;\n#include &lt;linux\/rtnetlink.h&gt;\n\n\/\/ little helper to parsing message using netlink macroses\nvoid parseRtattr(struct rtattr *tb[], int max, struct rtattr *rta, int len)\n{\n    memset(tb, 0, sizeof(struct rtattr *) * (max + 1));\n\n    while (RTA_OK(rta, len)) {  \/\/ while not end of the message\n        if (rta-&gt;rta_type &lt;= max) {\n            tb[rta-&gt;rta_type] = rta; \/\/ read attr\n        }\n        rta = RTA_NEXT(rta,len);    \/\/ get next attr\n    }\n}\n\nint main()\n{\n    int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);   \/\/ create netlink socket\n\n    if (fd &lt; 0) {\n        printf(\"Failed to create netlink socket: %s\\n\", (char*)strerror(errno));\n        return 1;\n    }\n\n    struct sockaddr_nl  local;  \/\/ local addr struct\n    char buf[8192];             \/\/ message buffer\n    struct iovec iov;           \/\/ message structure\n    iov.iov_base = buf;         \/\/ set message buffer as io\n    iov.iov_len = sizeof(buf);  \/\/ set size\n\n    memset(&amp;local, 0, sizeof(local));\n\n    local.nl_family = AF_NETLINK;       \/\/ set protocol family\n    local.nl_groups =   RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;   \/\/ set groups we interested in\n    local.nl_pid = getpid();    \/\/ set out id using current process id\n\n    \/\/ initialize protocol message header\n    struct msghdr msg;  \n    {\n        msg.msg_name = &amp;local;                  \/\/ local address\n        msg.msg_namelen = sizeof(local);        \/\/ address size\n        msg.msg_iov = &amp;iov;                     \/\/ io vector\n        msg.msg_iovlen = 1;                     \/\/ io size\n    }   \n\n    if (bind(fd, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0) {     \/\/ bind socket\n        printf(\"Failed to bind netlink socket: %s\\n\", (char*)strerror(errno));\n        close(fd);\n        return 1;\n    }   \n\n    \/\/ read and parse all messages from the\n    while (1) {\n        ssize_t status = recvmsg(fd, &amp;msg, MSG_DONTWAIT);\n\n        \/\/  check status\n        if (status &lt; 0) {\n            if (errno == EINTR || errno == EAGAIN)\n            {\n                usleep(250000);\n                continue;\n            }\n\n            printf(\"Failed to read netlink: %s\", (char*)strerror(errno));\n            continue;\n        }\n\n        if (msg.msg_namelen != sizeof(local)) { \/\/ check message length, just in case\n            printf(\"Invalid length of the sender address struct\\n\");\n            continue;\n        }\n\n        \/\/ message parser\n        struct nlmsghdr *h;\n\n        for (h = (struct nlmsghdr*)buf; status &gt;= (ssize_t)sizeof(*h); ) {   \/\/ read all messagess headers\n            int len = h-&gt;nlmsg_len;\n            int l = len - sizeof(*h);\n            char *ifName;\n\n            if ((l &lt; 0) || (len &gt; status)) {\n                printf(\"Invalid message length: %i\\n\", len);\n                continue;\n            }\n\n            \/\/ now we can check message type\n            if ((h-&gt;nlmsg_type == RTM_NEWROUTE) || (h-&gt;nlmsg_type == RTM_DELROUTE)) { \/\/ some changes in routing table\n                printf(\"Routing table was changed\\n\");  \n            } else {    \/\/ in other case we need to go deeper\n                char *ifUpp;\n                char *ifRunn;\n                struct ifinfomsg *ifi;  \/\/ structure for network interface info\n                struct rtattr *tb[IFLA_MAX + 1];\n\n                ifi = (struct ifinfomsg*) NLMSG_DATA(h);    \/\/ get information about changed network interface\n\n                parseRtattr(tb, IFLA_MAX, IFLA_RTA(ifi), h-&gt;nlmsg_len);  \/\/ get attributes\n                \n                if (tb[IFLA_IFNAME]) {  \/\/ validation\n                    ifName = (char*)RTA_DATA(tb[IFLA_IFNAME]); \/\/ get network interface name\n                }\n\n                if (ifi-&gt;ifi_flags &amp; IFF_UP) { \/\/ get UP flag of the network interface\n                    ifUpp = (char*)\"UP\";\n                } else {\n                    ifUpp = (char*)\"DOWN\";\n                }\n\n                if (ifi-&gt;ifi_flags &amp; IFF_RUNNING) { \/\/ get RUNNING flag of the network interface\n                    ifRunn = (char*)\"RUNNING\";\n                } else {\n                    ifRunn = (char*)\"NOT RUNNING\";\n                }\n\n                char ifAddress[256];    \/\/ network addr\n                struct ifaddrmsg *ifa; \/\/ structure for network interface data\n                struct rtattr *tba[IFA_MAX+1];\n\n                ifa = (struct ifaddrmsg*)NLMSG_DATA(h); \/\/ get data from the network interface\n\n                parseRtattr(tba, IFA_MAX, IFA_RTA(ifa), h-&gt;nlmsg_len);\n\n                if (tba[IFA_LOCAL]) {\n                    inet_ntop(AF_INET, RTA_DATA(tba[IFA_LOCAL]), ifAddress, sizeof(ifAddress)); \/\/ get IP addr\n                }\n\n                switch (h-&gt;nlmsg_type) { \/\/ what is actually happenned?\n                    case RTM_DELADDR:\n                        printf(\"Interface %s: address was removed\\n\", ifName);\n                        break;\n\n                    case RTM_DELLINK:\n                        printf(\"Network interface %s was removed\\n\", ifName);\n                        break;\n\n                    case RTM_NEWLINK:\n                        printf(\"New network interface %s, state: %s %s\\n\", ifName, ifUpp, ifRunn);\n                        break;\n\n                    case RTM_NEWADDR:\n                        printf(\"Interface %s: new address was assigned: %s\\n\", ifName, ifAddress);\n                        break;\n                }\n            }\n\n            status -= NLMSG_ALIGN(len); \/\/ align offsets by the message length, this is important\n\n            h = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));    \/\/ get next message\n        }\n\n        usleep(250000); \/\/ sleep for a while\n    }\n\n    close(fd);  \/\/ close socket\n\n    return 0;\n}\n<\/pre>\n<p>The compilation is straightforward, nothing additional:<\/p>\n<pre class=\"prettyprint\">gcc netmon.c -o netmon<\/pre>\n<p>And run:<\/p>\n<pre class=\"prettyprint\">.\/netmon<\/pre>\n<p>Now you can try to play with your network interfaces &#8211; unplug and plug back of the Ethernet cable, reconnect WiFi, and so on.<\/p>\n<p>You will get something like this:<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/nemon_example.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-255 size-full\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/nemon_example.png\" alt=\"\" width=\"746\" height=\"474\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/nemon_example.png 746w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/nemon_example-300x191.png 300w\" sizes=\"(max-width: 746px) 100vw, 746px\" \/><\/a>It&#8217;s alive! \ud83d\ude42<\/p>\n<h5>Data processing<\/h5>\n<p>In this example, you can find some new structures:<\/p>\n<pre class=\"prettyprint\">struct ifinfomsg\n{\n    unsigned char  ifi_family;  \/\/ interface family\n    unsigned short ifi_type;    \/\/ device type\n    int            ifi_index;   \/\/ interface index\n    unsigned int   ifi_flags;   \/\/ device flags\n    unsigned int   ifi_change;  \/\/ reserved, currently always 0xFFFFFFFF\n};<\/pre>\n<p><strong>struct ifinfomsg<\/strong> represents a network device and contains some useful fields, like device flags and index.<\/p>\n<pre class=\"prettyprint\">struct ifaddrmsg\n{\n    unsigned char  ifa_family;    \/\/ Adress type (AF_INET or AF_INET6)\n    unsigned char  ifa_prefixlen; \/\/ Length of the network mask\n    unsigned char  ifa_flags;     \/\/ Address flags\n    unsigned char  ifa_scope;     \/\/ Address scope\n    int            ifa_index;     \/\/ Interface index, same as in struct ifinfomsg\n};<\/pre>\n<p><strong>struct ifaddrmsg <\/strong>represents the network address assigned to the device<\/p>\n<pre class=\"prettyprint\">struct rtattr\n{\n    unsigned short rta_len; \/\/ Length of the option\n    unsigned short rta_type; \/\/ Type of the option\n    \/* data *\/ \n}\n<\/pre>\n<p><strong>struct rtattr<\/strong> is a helper structure used to store some parameters of the address or network link<\/p>\n<p>After the successful creation of the Netlink socket, we initializing <strong>sockaddr_nl<\/strong> structure by setting a mask of the groups which messages we want to receive:<br \/>\n<strong>RTMGRP_LINK, RTMGRP_IPV4_IFADDR<\/strong> and <strong>RTMGRP_IPV4_ROUTE<\/strong>.<br \/>\nAlso, at this point, we are allocating message structure and data buffer with a length of 8192 bytes.<br \/>\nAfter all of this, we can call <strong>bind()<\/strong> on a socket, subscribing to group events.<br \/>\nWe get new messages from the socket in the infinity cycle and then parsing this message using Netlink macro.<br \/>\nChecking <strong>nlmsg_type<\/strong> field, we can detect the type of the received message. In the case of some interface\/address event, we are digging deeper and getting all the interesting data.<br \/>\nAll information is stored as an array of attributes with<strong> struct rtattr<\/strong>.<br \/>\nUsing the little helper function parseRattr we can parse all attributes and extract readable information from this array.<\/p>\n<pre class=\"prettyprint\">struct ifinfomsg *ifi = (struct ifinfomsg*) NLMSG_DATA(h); \/\/ where h is netlink message header\nparseRtattr(tb, IFLA_MAX, IFLA_RTA(ifi), h-&gt;nlmsg_len);\nchar* ifName = (char*)RTA_DATA(tb[IFLA_IFNAME]); \/\/ readable interface name, eth0 for example<\/pre>\n<p>You can check <a href=\"http:\/\/man7.org\/linux\/man-pages\/man7\/rtnetlink.7.html\">rtnetlink<\/a> manual page to get more information about <strong>rtattr<\/strong> arrays and possible attributes indexes.<\/p>\n<p>I believe that all other code in this example is pretty obvious and didn&#8217;t require detailed explanations.<br \/>\nBut if you have some questions &#8211; please ask in the comments.<\/p>\n<p>I hope this article will be helpful.<\/p>\n<p>Additional materials:<\/p>\n<ol>\n<li><a href=\"http:\/\/tools.ietf.org\/html\/rfc3549\">tools.ietf.org\/html\/rfc3549<\/a><\/li>\n<li><a href=\"http:\/\/man7.org\/linux\/man-pages\/man7\/netlink.7.html\">http:\/\/man7.org\/linux\/man-pages\/man7\/netlink.7.html<\/a><\/li>\n<li><a href=\"http:\/\/man7.org\/linux\/man-pages\/man7\/rtnetlink.7.html\">http:\/\/man7.org\/linux\/man-pages\/man7\/rtnetlink.7.html<\/a><\/li>\n<li><a href=\"http:\/\/linuxjournal.com\/article\/7356\">http:\/\/linuxjournal.com\/article\/7356<\/a><\/li>\n<\/ol>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Once in my work, I needed to monitor all changes in the Linux networking subsystem: adding or deleting IP addresses, routes, etc. Maybe the best way to do this is to use socket-based Netlink technology. Using Netlink, we can &#8220;subscribe&#8221; to some network-related notifications from the kernel. It&#8217;s also possible to send commands to the [&hellip;]<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[76,25,78],"tags":[27,26,29,28],"_links":{"self":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/250"}],"collection":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/comments?post=250"}],"version-history":[{"count":25,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/250\/revisions"}],"predecessor-version":[{"id":1851,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/250\/revisions\/1851"}],"wp:attachment":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/media?parent=250"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/categories?post=250"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/tags?post=250"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}