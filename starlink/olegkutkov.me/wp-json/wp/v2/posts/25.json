{"id":25,"date":"2017-08-10T08:36:06","date_gmt":"2017-08-10T08:36:06","guid":{"rendered":"http:\/\/olegkutkov.me\/?p=25"},"modified":"2022-06-09T22:23:37","modified_gmt":"2022-06-09T19:23:37","slug":"mlx90614-raspberry","status":"publish","type":"post","link":"https:\/\/olegkutkov.me\/2017\/08\/10\/mlx90614-raspberry\/","title":{"rendered":"Connecting MLX90614 infrared thermometer to the Raspberry PI"},"content":{"rendered":"<h3><img loading=\"lazy\" decoding=\"async\" class=\"alignleft wp-image-56\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/mlx.jpg\" alt=\"\" width=\"132\" height=\"132\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/mlx.jpg 200w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/mlx-150x150.jpg 150w\" sizes=\"(max-width: 132px) 100vw, 132px\" \/><\/h3>\n<p class=\"western\" lang=\"en-US\">MLX<span lang=\"ru-RU\">90614<\/span> is a cheap and popular infrared thermometer from Melexis. This device is made in different versions for different purposes.<br \/>\nYou can get a general-purpose version with 0.5 accuracies or for medical purposes with accuracy up to 0.2.<\/p>\n<p class=\"western\" lang=\"en-US\">Also, you can choose the voltage you need: 3.3v or 5v versions are available.<br \/>\nWith MLX90614, you can distantly measure the objects&#8217; temperature, even the temperature of the sky. This enables a wide range of tasks in science and technics.<br \/>\nThis article will show how to connect this device to the Raspberry PI microcomputer via the i2c bus.<\/p>\n<p lang=\"en-US\"><!--more--><\/p>\n<p lang=\"en-US\">Inside the hermetic package, you can find two sensors &#8211; one infrared and one thermopile for classical temperature sensing. Thermopiles may be used for some calibration of the main infrared sensor.<\/p>\n<div>The sensor&#8217;s values are digitized by the 17-bit ADC and processed with a powerful DSP unit.<\/div>\n<div>The operation of the MLX90614 is controlled by an internal state machine, which controls the measurements and calculations of the object and ambient temperatures and does the post-processing of the temperatures to output them through the PWM output or the SMBus compatible interface. In this article, we are connecting this device to the i2c interface, which is mostly compatible with SMBus (in our case).<\/div>\n<div><\/div>\n<div><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/mlx90614_block_diagram.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-68\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/mlx90614_block_diagram-300x144.png\" alt=\"\" width=\"492\" height=\"236\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/mlx90614_block_diagram-300x144.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/mlx90614_block_diagram-768x368.png 768w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/mlx90614_block_diagram.png 1003w\" sizes=\"(max-width: 492px) 100vw, 492px\" \/><\/a><\/div>\n<div>PWM mode enables stand-alone usage of this device like a thermostat and won&#8217;t be discussed in this article (well, almost).<\/div>\n<p>Most important characteristics of this device you can find in the table below.<br \/>\nFor full specifications, description, and complete usage, please use the official <a href=\"https:\/\/www.melexis.com\/-\/media\/files\/documents\/datasheets\/mlx90614-datasheet-melexis.pdf\">datasheet<\/a>.<\/p>\n<p lang=\"en-US\"><h2 id=\"tablepress-1-name\" class=\"tablepress-table-name tablepress-table-name-id-1\">MLX90614 specifications<\/h2>\n\n<table id=\"tablepress-1\" class=\"tablepress tablepress-id-1\" aria-labelledby=\"tablepress-1-name\">\n<thead>\n<tr class=\"row-1 odd\">\n\t<th class=\"column-1\"><\/th><th class=\"column-2\"><\/th>\n<\/tr>\n<\/thead>\n<tbody class=\"row-hover\">\n<tr class=\"row-2 even\">\n\t<td class=\"column-1\">Power supply<\/td><td class=\"column-2\">5V for MLX90614Axx<br \/>\n3.3V for MLX90614Bxx<\/td>\n<\/tr>\n<tr class=\"row-3 odd\">\n\t<td class=\"column-1\">Temperature ranges<\/td><td class=\"column-2\">-40...+125 \u030aC for ambient sensor<br \/>\n-70...+380 \u030aC for infrared sensor<\/td>\n<\/tr>\n<tr class=\"row-4 even\">\n\t<td class=\"column-1\">Accuracy<\/td><td class=\"column-2\">0.5\u00b0C for general purpose version<br \/>\n0.2\u00b0C for medical version<br \/>\nBoth sensors<\/td>\n<\/tr>\n<tr class=\"row-5 odd\">\n\t<td class=\"column-1\">Infrared sensor field of view<\/td><td class=\"column-2\">90\u00b0 for MLX90614xAA<\/td>\n<\/tr>\n<tr class=\"row-6 even\">\n\t<td class=\"column-1\">Infrared sensor wavelengths<\/td><td class=\"column-2\">5.5 \u2013 14 \u03bcm<\/td>\n<\/tr>\n<tr class=\"row-7 odd\">\n\t<td class=\"column-1\">Ambient temperature ranges<\/td><td class=\"column-2\">-40...+85 C<\/td>\n<\/tr>\n<tr class=\"row-8 even\">\n\t<td class=\"column-1\">Max current<\/td><td class=\"column-2\">2 mA<\/td>\n<\/tr>\n<tr class=\"row-9 odd\">\n\t<td class=\"column-1\"><\/td><td class=\"column-2\"><\/td>\n<\/tr>\n<tr class=\"row-10 even\">\n\t<td class=\"column-1\"><\/td><td class=\"column-2\"><\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<!-- #tablepress-1 from cache --><\/p>\n<p lang=\"en-US\"><strong>\u00a0Device pinout<\/strong><\/p>\n<p lang=\"en-US\"><img loading=\"lazy\" decoding=\"async\" class=\"wp-image-74 aligncenter\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/mlx_pinout-300x292.png\" alt=\"\" width=\"248\" height=\"241\" \/><\/p>\n<p lang=\"en-US\"><strong>VDD<\/strong> &#8211; power supply (3.3 or 5 volts).<\/p>\n<p lang=\"en-US\"><strong>SCL<\/strong> &#8211; i2c\/SMBus clock.<\/p>\n<p lang=\"en-US\"><strong>SDA<\/strong> &#8211; i2c\/SMBus data or PWM output.<\/p>\n<p lang=\"en-US\"><strong>VSS\/GND<\/strong> &#8211; Ground.<\/p>\n<p lang=\"en-US\">Please always carefully check voltages. 5v can kill your 3.3 v device!<\/p>\n<h3 lang=\"en-US\"><strong>Connecting to the Raspberry Pi.<\/strong><\/h3>\n<p lang=\"en-US\">It&#8217;s simple.<\/p>\n<p lang=\"en-US\"><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/mlx_connection.jpg\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-76\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/mlx_connection-300x188.jpg\" alt=\"\" width=\"565\" height=\"354\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/mlx_connection-300x188.jpg 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/mlx_connection-768x482.jpg 768w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/mlx_connection.jpg 800w\" sizes=\"(max-width: 565px) 100vw, 565px\" \/><\/a><\/p>\n<p class=\"western\" lang=\"en-US\">R<span lang=\"ru-RU\">1 and <\/span>R<span lang=\"ru-RU\">2 \u2013 4<\/span>K<span lang=\"ru-RU\">7 are optional because Raspberry contains such resistors aboard. It may be used only in case of a &#8220;long&#8221; line.<br \/>\n<\/span><\/p>\n<p lang=\"en-US\">C1 capacitor is important and should be placed as close as possible to the device.<\/p>\n<p lang=\"en-US\">\u00a0Another important note about voltages! Raspberry PI is a 3.3v device and not tolerant of 5v inputs. So in the case of a 5v MLX device, an additional voltage shifter should be used!<\/p>\n<p lang=\"en-US\">By default, the device is working in SMBus mode, but my sample was in PWM mode. What was puzzled me for some time i2c bus was full of random numbers. But after connecting the oscilloscope, I finally figured out what was going on and switched MLX to the &#8220;normal&#8221; SMBus mode.<\/p>\n<p lang=\"en-US\">Switching is simple &#8211; pull the SCL pin to the ground for a short time. After resetting device returns to the original work mode. For permanent switching, some EEPROM values should be corrected. EEPROM reading and writing will be discussed below.<\/p>\n<h3 lang=\"en-US\"><strong>Programming<\/strong><\/h3>\n<p lang=\"en-US\">There are two ways to work with i2c devices.<\/p>\n<ol>\n<li lang=\"en-US\">Using hardware i2c bus through i<span lang=\"ru-RU\">2<\/span>c<span lang=\"ru-RU\">_<\/span>bcm<span lang=\"ru-RU\">2708<\/span> kernel module and libi<span lang=\"ru-RU\">2<\/span>c library.<\/li>\n<li lang=\"en-US\">Using a popular <a href=\"http:\/\/www.airspayce.com\/mikem\/bcm2835\/\">bcm<span lang=\"ru-RU\">2835<\/span><\/a> library with software emulation of the i2c protocol.<\/li>\n<\/ol>\n<p>Looking ahead, I can tell you that I don&#8217;t have any problems with bcm2835. MLX device worked like a charm.<br \/>\nBut I didn&#8217;t prefer this way due to its programmatic nature. Why emulate some hardware bus when we already had one? Especially on such a weak device as a Raspberry.<\/p>\n<p>So I chose the i2c_bcm2708, and this is the beginning of the interesting debugging with magic&#8230;<\/p>\n<p>First of all, we need to load the i2c_bcm2708 kernel module. We can do it with a <strong>modprobe<\/strong> command: <span style=\"color: #808080;\">sudo modprobe i2c_bcm2708<\/span><\/p>\n<p>For automatically loading this module on every boot, add the module name to the end of the <span style=\"color: #808080;\"><span lang=\"ru-RU\">\/<\/span>etc<span lang=\"ru-RU\">\/<\/span>modules<\/span> file.<\/p>\n<p>After successful module loading you can find two new devices: <span lang=\"ru-RU\">\/<\/span>dev<span lang=\"ru-RU\">\/<\/span>i<span lang=\"ru-RU\">2<\/span>c<span lang=\"ru-RU\">-0 and \/<\/span>dev<span lang=\"ru-RU\">\/<\/span>i<span lang=\"ru-RU\">2<\/span>c<span lang=\"ru-RU\">-1. There are two separate i2c buses, and in the case of the first generation of the Raspberry &#8211; only i2c-1 is available on the GPIO header. i2c-0 is available for manual soldering. In later Raspberry models, both buses are available on the GPIO header.<br \/>\n<\/span><\/p>\n<p>To check that the MLX device is properly connected and working, run this command:<span style=\"color: #808080;\"> i<span lang=\"ru-RU\">2<\/span>cdetect<span lang=\"ru-RU\"> &#8211;<\/span>y <\/span><span lang=\"ru-RU\"><span style=\"color: #808080;\">1<\/span> (1 means \/dev\/i2c-1 device). This utility is available in the i2c-tools package.<br \/>\n<\/span><\/p>\n<p>The Default MLX address is 0x5A. And if everything is OK and the MLX device is lonely on the bus &#8211; you can see such output:<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\" wp-image-87 aligncenter\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/i2cdetect-300x115.jpg\" alt=\"\" width=\"535\" height=\"205\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/i2cdetect-300x115.jpg 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/i2cdetect.jpg 478w\" sizes=\"(max-width: 535px) 100vw, 535px\" \/><\/p>\n<p>In the case of numbers chaos, your device might be in PWM mode and should be switched as described earlier.<\/p>\n<p>Okay, let&#8217;s write a simple program.<\/p>\n<pre class=\"prettyprint\">#include &lt;sys\/ioctl.h&gt;\n#include &lt;sys\/types.h&gt;\n#include &lt;sys\/stat.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;string.h&gt;\n#include &lt;linux\/i2c-dev.h&gt;\n\n\/\/\/\n#define I2C_DEV_PATH \"\/dev\/i2c-1\"\n\n\/* Just in case *\/\n#ifndef I2C_SMBUS_READ \n#define I2C_SMBUS_READ 1 \n#endif \n#ifndef I2C_SMBUS_WRITE \n#define I2C_SMBUS_WRITE 0 \n#endif\n\n<span class=\"pl-k\">typedef<\/span> <span class=\"pl-k\">union<\/span> i2c_smbus_data i2c_data;\nint main()\n{\n    int fdev = open(I2C_DEV_PATH, O_RDWR); \/\/ open i2c bus\n\n    if (fdev &lt; 0) {\n        fprintf(stderr, \"Failed to open I2C interface %s Error: %s\\n\", I2C_DEV_PATH, strerror(errno));\n        return -1;\n    }\n\n    unsigned char i2c_addr = 0x5A;\n\n    \/\/ set slave device address, default MLX is 0x5A\n    if (ioctl(fdev, I2C_SLAVE, i2c_addr) &lt; 0) {\n        fprintf(stderr, \"Failed to select I2C slave device! Error: %s\\n\", strerror(errno));\n        return -1;\n    }\n\n    \/\/ enable checksums control\n    if (ioctl(fdev, I2C_PEC, 1) &lt; 0) {\n        fprintf(stderr, \"Failed to enable SMBus packet error checking, error: %s\\n\", strerror(errno));\n        return -1;\n    }\n\n\n    \/\/ trying to read something from the device unsing SMBus READ request\n    i2c_data data;\n    char command = 0x06; \/\/ command 0x06 is reading thermopile sensor, see datasheet for all commands\n\n    \/\/ build request structure\n    struct i2c_smbus_ioctl_data sdat = {\n        .read_write = I2C_SMBUS_READ,\n        .command = command,\n        .size = I2C_SMBUS_WORD_DATA,\n        .data = &amp;data\n    };\n\n    \/\/ do actual request\n    if (ioctl(fdev, I2C_SMBUS, &amp;sdat) &lt; 0) {\n        fprintf(stderr, \"Failed to perform I2C_SMBUS transaction, error: %s\\n\", strerror(errno));\n        return -1;\n    }\n\n    \/\/ calculate temperature in Celsius by formula from datasheet\n    double temp = (double) data.word;\n    temp = (temp * 0.02)-0.01;\n    temp = temp - 273.15;\n\n    \/\/ print result\n    printf(\"Tamb = %04.2f\\n\", temp);\n\n    return 0;\n}<\/pre>\n<p>Compile and run:<\/p>\n<pre><code>gcc <span class=\"hljs-keyword\">test<\/span>.c -o <span class=\"hljs-keyword\">test<\/span><\/code> &amp;&amp; .\/test<\/pre>\n<pre><strong>NOTE:<\/strong> \nIf I2C_SMBUS_READ and I2C_SMBUS_WORD_DATA is undeclared please try to include &lt;linux\/i2c.h&gt; instead or redifine this commands:\n\n#ifndef I2C_SMBUS_READ\n#define I2C_SMBUS_READ    1\n#endif\n#ifndef I2C_SMBUS_WRITE\n#define I2C_SMBUS_WRITE    0\n#endif<\/pre>\n<p>And Oops! We got the error &#8220;<b>Failed to perform I2C_SMBUS transaction, error: bad message<\/b>&#8221;<\/p>\n<p>So what is the problem? Sure, we did everything correctly and sent the correct messages to the device.<\/p>\n<p>I&#8217;ve spent a few days trying to figure out what is going on. Digging Raspberry PI forums, other code examples, and even the Linux kernel.<\/p>\n<p>As I already noted, using the bcm2835 library caused no errors.<\/p>\n<p>Finally, I&#8217;ve connected my logic analyzer to the Raspberry i2c bus and captured both communications &#8211; using the bcm2835 code and this example code.<\/p>\n<p>Looking datasheet, we can find an example of the proper SMBus communication.<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/smbus.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-116\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/smbus.png\" alt=\"\" width=\"502\" height=\"108\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/smbus.png 937w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/smbus-300x65.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/smbus-768x166.png 768w\" sizes=\"(max-width: 502px) 100vw, 502px\" \/><\/a><\/p>\n<p>But the analyzer showed something strange.<br \/>\nA long pause after ACK is caused by an extra stop bit (red dot), just after the ACK packet.<br \/>\nThe device recognizes this situation as two separate writes. But both these <code>write<\/code> operations are incomplete and incorrect, of course.<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/analyze_bad_color.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-119\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/analyze_bad_color-300x104.png\" alt=\"\" width=\"600\" height=\"207\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/analyze_bad_color-300x104.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/analyze_bad_color-768x265.png 768w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/analyze_bad_color.png 900w\" sizes=\"(max-width: 600px) 100vw, 600px\" \/><\/a>And for example, this is a request made with the bcm2835 library.<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/analyze_good_color.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-120\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/analyze_good_color.png\" alt=\"\" width=\"600\" height=\"181\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/analyze_good_color.png 900w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/analyze_good_color-300x90.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/analyze_good_color-768x231.png 768w\" sizes=\"(max-width: 600px) 100vw, 600px\" \/><\/a><\/p>\n<p>Everything is ok as expected.<\/p>\n<p>Digging the forums, I found that such behavior is a feature of the Raspberry i2c_bcm2708 driver. The driver should be switched to the &#8220;combined&#8221; mode to stop such packet splitting.<\/p>\n<p>Fortunately, this can be done with a simple command (as root):<\/p>\n<pre><code>echo -n <span class=\"hljs-number\">1<\/span> &gt; <span class=\"hljs-regexp\">\/sys\/module<\/span><span class=\"hljs-regexp\">\/i2c_bcm2708\/parameters<\/span><span class=\"hljs-regexp\">\/combined<\/span><\/code><\/pre>\n<p><strong>UPD: On modern devices with a modern OS, this is not required! I2C bus works correctly from the box \ud83d\ude42<\/strong><br \/>\n<strong>Tested on Raspberry PI 3 and newer, the Raspbian version is 10.1 (Buster)<\/strong><\/p>\n<p>Run our test utility, and magic happens.<\/p>\n<pre><code class=\"hljs protobuf\">sudo .\/test\nTamb = <span class=\"hljs-number\">19.4<\/span><\/code><\/pre>\n<p>It works!<\/p>\n<p>Now it&#8217;s time to write a fully functional utility.<\/p>\n<p>You can find all EEPROM and RAM addresses in the MLX <a href=\"https:\/\/www.melexis.com\/-\/media\/files\/documents\/datasheets\/mlx90614-datasheet-melexis.pdf\">datasheet<\/a>.<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/eeprom_table.png\"><img loading=\"lazy\" decoding=\"async\" class=\"wp-image-123 size-full aligncenter\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/eeprom_table.png\" alt=\"\" width=\"575\" height=\"377\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/eeprom_table.png 575w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/eeprom_table-300x197.png 300w\" sizes=\"(max-width: 575px) 100vw, 575px\" \/><\/a><\/p>\n<p>PWCTRL is what we need to switch off PWM mode permanently.<\/p>\n<p>Register description<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/pwmctrl.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-124 size-full\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/pwmctrl.png\" alt=\"\" width=\"656\" height=\"211\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/pwmctrl.png 656w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/pwmctrl-300x96.png 300w\" sizes=\"(max-width: 656px) 100vw, 656px\" \/><\/a><\/p>\n<p>So to disable PWM mode, just set the first (0) bit to the zero value. Simple.<\/p>\n<p>Temperatures are reading from RAM.<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/ram.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-125 size-full\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/ram.png\" alt=\"\" width=\"461\" height=\"260\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/ram.png 461w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/ram-300x169.png 300w\" sizes=\"(max-width: 461px) 100vw, 461px\" \/><\/a><\/p>\n<p>Here you can see infrared channels RAW data (some versions of the MLX device contain two infrared sensors, see documentation), thermopile sensor temperature value (Ta), and infrared sensors calculated values (Tobj1 and Tobj2). For the single IR sensor device temperature value is read from Tojb1.<\/p>\n<p>I&#8217;ve made a header file with all useful address values.<\/p>\n<pre class=\"prettyprint\">\/\/ RAM\n#define MLX90614_RAWIR1 0x04\n#define MLX90614_RAWIR2 0x05\n#define MLX90614_TA 0x06\n#define MLX90614_TOBJ1 0x07\n#define MLX90614_TOBJ2 0x08\n\n\/\/ EEPROM\n#define MLX90614_TOMAX 0x20\n#define MLX90614_TOMIN 0x21\n#define MLX90614_PWMCTRL 0x22\n#define MLX90614_TARANGE 0x23\n#define MLX90614_EMISS 0x24\n#define MLX90614_CONFIG 0x25\n#define MLX90614_ADDR 0x2E\n#define MLX90614_ID1 0x1C\n#define MLX90614_ID2 0x1D\n#define MLX90614_ID3 0x1E\n#define MLX90614_ID4 0x1F<\/pre>\n<p>Full source code of the utility with Makefile and good Readme you can find on <a href=\"https:\/\/github.com\/olegkutkov\/allsky\/tree\/master\/src\/utils\/mlx90614\">my GitHub.<\/a><\/p>\n<p>The compilation is simple. Just call <strong>make<\/strong>.<\/p>\n<p>Let&#8217;s test this program.<\/p>\n<p>Reading infrared temperature from the device on i2c bus 1 and with address 0x5A:<\/p>\n<pre><code class=\"hljs stylus\">.\/read_mlx90614 --bus <span class=\"hljs-number\">1<\/span> --i2c_addr <span class=\"hljs-number\">0<\/span>x5a -<span class=\"hljs-selector-tag\">i<\/span>\nTobj = <span class=\"hljs-number\">21.3<\/span><\/code><\/pre>\n<p>Seems plausible.<\/p>\n<p>Now thermopile:<\/p>\n<pre><code class=\"hljs livecodeserver\">.\/read_mlx90614 <span class=\"hljs-comment\">--bus 1 --i2c_addr 0x5a -a<\/span>\nTamb = <span class=\"hljs-number\">19.4<\/span><\/code><\/pre>\n<p>Checking the state of the PWM mode:<\/p>\n<pre><code class=\"hljs stylus\">.\/read_mlx90614 --bus <span class=\"hljs-number\">1<\/span> --i2c_addr <span class=\"hljs-number\">0<\/span>x5a -<span class=\"hljs-selector-tag\">p<\/span>\nPWM mode - enabled<\/code><\/pre>\n<p>Disable PWM mode:<\/p>\n<pre><code><span class=\"hljs-string\">.<\/span><span class=\"hljs-comment\">\/read_mlx90614<\/span> <span class=\"hljs-literal\">-<\/span><span class=\"hljs-literal\">-<\/span><span class=\"hljs-comment\">bus<\/span> <span class=\"hljs-comment\">1<\/span> <span class=\"hljs-literal\">-<\/span><span class=\"hljs-literal\">-<\/span><span class=\"hljs-comment\">i2c_addr<\/span> <span class=\"hljs-comment\">0x5a<\/span> <span class=\"hljs-literal\">-<\/span><span class=\"hljs-literal\">-<\/span><span class=\"hljs-comment\">pwm_mode=0<\/span> <span class=\"hljs-literal\">-<\/span><span class=\"hljs-comment\">w<\/span><\/code><\/pre>\n<p>And enable (why not):<\/p>\n<pre><code><span class=\"hljs-string\">.<\/span><span class=\"hljs-comment\">\/read_mlx90614<\/span> <span class=\"hljs-literal\">-<\/span><span class=\"hljs-literal\">-<\/span><span class=\"hljs-comment\">bus<\/span> <span class=\"hljs-comment\">1<\/span> <span class=\"hljs-literal\">-<\/span><span class=\"hljs-literal\">-<\/span><span class=\"hljs-comment\">i2c_addr<\/span> <span class=\"hljs-comment\">0x5a<\/span> <span class=\"hljs-literal\">-<\/span><span class=\"hljs-literal\">-<\/span><span class=\"hljs-comment\">pwm_mode=1<\/span> <span class=\"hljs-literal\">-<\/span><span class=\"hljs-comment\">w<\/span><\/code><\/pre>\n<p>You can use an additional &#8211;debug option to see what is actually going on.<\/p>\n<pre><code class=\"hljs livecodeserver\">.\/read_mlx90614 <span class=\"hljs-comment\">--bus 1 --i2c_addr 0x5a --pwm_mode=1 -w \u2013debug<\/span>\n\n   Opening i2c interface \/dev\/i2c<span class=\"hljs-number\">-1<\/span>\n   Setting up slave address <span class=\"hljs-number\">0x5A<\/span>\n   Perfoming I2C_SMBUS_READ request <span class=\"hljs-built_in\">to<\/span> device, <span class=\"hljs-keyword\">command<\/span> = <span class=\"hljs-title\">0x22<\/span>\n   Ok, got answer <span class=\"hljs-built_in\">from<\/span> device\n   EEPROM cell = <span class=\"hljs-number\">0x22<\/span> current <span class=\"hljs-built_in\">value<\/span> = <span class=\"hljs-number\">0x0201<\/span>\n   Erasing EEPROM cell = <span class=\"hljs-number\">0x22<\/span>\n   Trying <span class=\"hljs-built_in\">to<\/span> store <span class=\"hljs-built_in\">value<\/span> = <span class=\"hljs-number\">0x0203<\/span> <span class=\"hljs-built_in\">to<\/span> <span class=\"hljs-keyword\">the<\/span> EEPROM cell = <span class=\"hljs-number\">0x22<\/span>\n   PWM mode is now enabled<\/code><\/pre>\n<h3><strong>Offtopic. Sensor usage<\/strong><\/h3>\n<p>One of the most interesting usages of this device is to measure the sky temperature.\u00a0 Why does it make sense?<\/p>\n<p>Well. Sky temperature &#8211; is the median temperature of the flipped conus from our sensor to the stratosphere.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-128\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/sensor_atm_volume.png\" alt=\"\" width=\"385\" height=\"358\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/sensor_atm_volume.png 385w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/sensor_atm_volume-300x279.png 300w\" sizes=\"(max-width: 385px) 100vw, 385px\" \/><\/p>\n<p>This temperature depends on the quantity of water vapor in the air. This water vapor is heated by the infrared radiation re-emitted by the Earth&#8217;s surface.\u00a0 More water &#8211; higher temperature. The sky&#8217;s temperature without any vapor and any gases are striving to the outer space&#8217;s temperature. So measuring the sky temperature can tell us how much water vapor in the air.<br \/>\nThe concentration of the vapor is called clouds. Thus with these measurements, we can judge how cloudy it is today.<\/p>\n<p style=\"text-align: center;\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-129\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/skytemp_test_color.png\" alt=\"\" width=\"700\" height=\"237\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/skytemp_test_color.png 700w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2017\/08\/skytemp_test_color-300x102.png 300w\" sizes=\"(max-width: 700px) 100vw, 700px\" \/> <i>(Image credit: Forrest M. Mims III., mynasadata.larc.nasa.gov)<\/i><\/p>\n<p>&nbsp;<\/p>\n<p>As was found experimentally, if the sky temperature is less than ambient temperature by 5 or fewer degrees &#8211; the sky is full of clouds. The difference by 20 or more is always the clearest sky.<\/p>\n<hr \/>\n<p>Thanks for reading.<br \/>\nI hope this material will be helpful.<\/p>\n<p>&nbsp;<\/p>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n","protected":false},"excerpt":{"rendered":"<p>MLX90614 is a cheap and popular infrared thermometer from Melexis. This device is made in different versions for different purposes. You can get a general-purpose version with 0.5 accuracies or for medical purposes with accuracy up to 0.2. Also, you can choose the voltage you need: 3.3v or 5v versions are available. With MLX90614, you [&hellip;]<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[4],"tags":[8,10,6,7,9],"_links":{"self":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/25"}],"collection":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/comments?post=25"}],"version-history":[{"count":75,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/25\/revisions"}],"predecessor-version":[{"id":2750,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/25\/revisions\/2750"}],"wp:attachment":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/media?parent=25"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/categories?post=25"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/tags?post=25"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}