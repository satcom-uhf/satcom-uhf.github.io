{"id":678,"date":"2019-03-25T03:24:05","date_gmt":"2019-03-25T00:24:05","guid":{"rendered":"http:\/\/olegkutkov.me\/?p=678"},"modified":"2021-02-04T14:04:49","modified_gmt":"2021-02-04T12:04:49","slug":"simple-logger-with-stdout-files-and-syslog-support-for-c-projects-in-linux","status":"publish","type":"post","link":"https:\/\/olegkutkov.me\/2019\/03\/25\/simple-logger-with-stdout-files-and-syslog-support-for-c-projects-in-linux\/","title":{"rendered":"Simple logger with STDOUT, Files and syslog support for C projects in Linux"},"content":{"rendered":"<p><img loading=\"lazy\" decoding=\"async\" class=\"alignleft size-thumbnail wp-image-294\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2018\/02\/Screenshot-02152018-121038-PM-150x150.png\" alt=\"\" width=\"150\" height=\"150\" \/>In this little note, I want to describe a simple logging module for C programs in Linux. I&#8217;m using this code for years in my projects. This module supports different types of output &#8220;targets&#8221; &#8211; files, syslog, and stdout.<\/p>\n<p><!--more--><\/p>\n<p>Every printed message is the preceded name of the program, current date\/time, type of the message &#8211; debug\/error\/warning\/etc.<br \/>\nThis is very useful, can improve readability, and can provide easy filtering of the required messages. The programmer can configure the logging level in a runtime.<\/p>\n<p>The logging module provides a set of functions for configuring and message printing.<\/p>\n<pre class=\"prettyprint\">\/*\n * Logging methods by levels\n *\/\nvoid log_error(char* format, ...);\nvoid log_warning(char* format, ...);\nvoid log_status(char* format, ...);\nvoid log_debug(char* format, ...);\n\n\/*\n * Log level configurator\n * Default is LOG_MAX_LEVEL_ERROR_WARNING_STATUS\n *\/ \n\n#define LOG_MAX_LEVEL_ERROR 0\n#define LOG_MAX_LEVEL_ERROR_WARNING_STATUS 1\n#define LOG_MAX_LEVEL_ERROR_WARNING_STATUS_DEBUG 2\n\nvoid logger_set_log_level(const int level);\n\n\/*\n * Set target type\n * Default is syslog\n *\/\nvoid logger_reset_state(void);\nint logger_set_log_file(const char* filename);\nvoid logger_set_out_stdout();\n<\/pre>\n<p>As you can see, logging methods supported variable types of the arguments, so you can use these methods like a regular <strong>printf<\/strong> providing different types of formats and argument types.<\/p>\n<p>Different logging levels can be configured, which can be used for suppressing some message types if needed, without program recompilation. The default log level is ERROR\/WARNING\/STATUS, and DEBUG messages are disabled in a normal state.<\/p>\n<p>By default, all messages are going to the <strong>syslog<\/strong>. But you can specify a separate text file or use regular stdout. In file mode, logger automatically handles non-existing files creating a new file or appending the message to the already existing file.<\/p>\n<p>Here is the full source code of this logging module:<\/p>\n<pre class=\"prettyprint\">#include &lt;syslog.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;time.h&gt;\n#include &lt;stdarg.h&gt;\n#include &lt;string.h&gt;\n#include \"logger.h\"\n\n\/*\n * Program name variable is provided by the libc\n *\/\nextern const char* __progname;\n\n\/*\n * Logger internal sctructure\n *\/\nstruct logger_t {\n    int max_log_level;\n    int use_stdout;\n    FILE* out_file;\n    void (*logger_func) (const int level, const char*);\n};\n\n#define PROGRAM_NAME __progname\n\n#define LOG_LEVEL_ERROR 0\n#define LOG_LEVEL_WARNING 1\n#define LOG_LEVEL_STATUS 2\n#define LOG_LEVEL_DEBUG 3\n\n\/*\n * Prefixes for the different logging levels\n *\/\n#define LOG_PREFIX_ERROR \"ERROR\"\n#define LOG_PREFIX_WARNING \"WARNING\"\n#define LOG_PREFIX_STATUS \"STATUS\"\n#define LOG_PREFIX_DEBUG \"DEBUG\"\n\n\/*\n*\/  \nstatic struct logger_t log_global_set;\n\nstatic const char* LOG_LEVELS[] = { LOG_PREFIX_ERROR,\n                    LOG_PREFIX_WARNING,\n                    LOG_PREFIX_STATUS,\n                    LOG_PREFIX_DEBUG };\n\nvoid print_to_syslog(const int level, const char* message);\nvoid print_to_file(const int level, const char* message);\n\n\/*\n * Close remaining file descriptor and reset global params\n *\/\nvoid cleanup_internal()\n{\n    if (log_global_set.out_file) {\n        if (!log_global_set.use_stdout) {\n            fclose(log_global_set.out_file);\n        }\n\n        log_global_set.use_stdout = 0;\n        log_global_set.out_file = NULL;\n    }\n}\n\n\/*\n * Reset internal state and set syslog as default target\n *\/ \nvoid logger_reset_state(void)\n{\n    log_global_set.max_log_level = LOG_MAX_LEVEL_ERROR_WARNING_STATUS;\n    cleanup_internal();\n    log_global_set.logger_func = print_to_syslog;\n}\n\n\/*\n * Print to syslog\n *\/\nvoid print_to_syslog(const int level, const char* message)\n{\n    syslog(LOG_INFO, \"[%s] %s\\n\", LOG_LEVELS[level], message);\n}\n\n\/*\n * Print to file which can be a regular text file or STDOUT \"file\"\n *\/\nvoid print_to_file(const int level, const char* message)\n{\n    struct tm* current_tm;\n    time_t time_now;\n\n    time(&amp;time_now);\n    current_tm = localtime(&amp;time_now);\n\n    int res = fprintf(log_global_set.out_file,\n            \"%s: %02i:%02i:%02i [%s] %s\\n\"\n                , PROGRAM_NAME\n                , current_tm-&gt;tm_hour\n                , current_tm-&gt;tm_min\n                , current_tm-&gt;tm_sec\n                , LOG_LEVELS[level]\n                , message );\n\n    if (res == -1) {\n        print_to_syslog(LOG_LEVEL_ERROR, \"Unable to write to log file!\");\n        return;\n    }\n\n    fflush(log_global_set.out_file);\n}\n\n\/*\n *\/\nvoid logger_set_log_level(const int level)\n{\n    log_global_set.max_log_level = level;\n}\n\n\/*\n *\/\nint logger_set_log_file(const char* filename)\n{\n    cleanup_internal();\n\n    log_global_set.out_file = fopen(filename, \"a\");\n\n    if (log_global_set.out_file == NULL) {\n        log_error(\"Failed to open file %s error %s\", filename, strerror(errno));\n        return -1;\n    }\n\n    log_global_set.logger_func = print_to_file;\n\n    return 0;\n}\n\n\/*\n *\/\nvoid logger_set_out_stdout()\n{\n    cleanup_internal();\n\n    log_global_set.use_stdout = 1;\n    log_global_set.logger_func = print_to_file;\n    log_global_set.out_file = stdout;\n}\n\n\/*\n * Logging functions\n *\/\nvoid log_generic(const int level, const char* format, va_list args)\n{\n    char buffer[256];\n    vsprintf(buffer, format, args);\n    log_global_set.logger_func(level, buffer);\n}\n\nvoid log_error(char *format, ...)\n{\n    va_list args;\n    va_start(args, format);\n    log_generic(LOG_LEVEL_ERROR, format, args);\n    va_end(args);\n}\n\nvoid log_warning(char *format, ...)\n{\n    if (log_global_set.max_log_level &lt; LOG_MAX_LEVEL_ERROR_WARNING_STATUS) {\n        return;\n    }\n\n    va_list args;\n    va_start(args, format);\n    log_generic(LOG_LEVEL_WARNING, format, args);\n    va_end(args);\n}\n\nvoid log_status(char *format, ...)\n{\n    if (log_global_set.max_log_level &lt; LOG_MAX_LEVEL_ERROR_WARNING_STATUS) {\n        return;\n    }\n\n    va_list args;\n    va_start(args, format);\n    log_generic(LOG_LEVEL_STATUS, format, args);\n    va_end(args);\n}\n\nvoid log_debug(char *format, ...)\n{\n    if (log_global_set.max_log_level &lt;  LOG_MAX_LEVEL_ERROR_WARNING_STATUS_DEBUG) {\n        return;\n    }\n\n    va_list args;\n    va_start(args, format);\n    log_generic(LOG_LEVEL_DEBUG, format, args);\n    va_end(args);\n}<\/pre>\n<p>And simple usage example<\/p>\n<pre class=\"prettyprint\">#include \"logger.h\"\n\nint main()\n{\n    logger_reset_state();\n\n    log_warning(\"This message goes to syslog\");\n\n    logger_set_out_stdout();\n\n    log_status(\"Hello!\");\n\n    logger_set_log_file(\"log.txt\");\n\n    log_error(\"Logger in a file mode!\");\n\n    return 0;\n}\n<\/pre>\n<p>Compile and run:<\/p>\n<pre class=\"prettyprint\">$ gcc main.c logger.c -o test_logger\n$ .\/test_logger<\/pre>\n<p>You should see a greeting message on a console. Also, you can find <strong>log.txt<\/strong> file with appropriate content and grep program message from the <strong>syslog<\/strong>.<\/p>\n<p><a href=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/03\/logger_test.png\" rel=\"attachment wp-att-842\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-842 size-full\" src=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/03\/logger_test.png\" alt=\"\" width=\"661\" height=\"104\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/03\/logger_test.png 661w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/03\/logger_test-300x47.png 300w\" sizes=\"(max-width: 661px) 100vw, 661px\" \/><\/a>Thanks for reading!<br \/>\nI hope this logger will be useful in your cool projects \ud83d\ude42<\/p>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In this little note, I want to describe a simple logging module for C programs in Linux. I&#8217;m using this code for years in my projects. This module supports different types of output &#8220;targets&#8221; &#8211; files, syslog, and stdout.<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[25,54],"tags":[73,27,72,74],"_links":{"self":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/678"}],"collection":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/comments?post=678"}],"version-history":[{"count":11,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/678\/revisions"}],"predecessor-version":[{"id":1736,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/678\/revisions\/1736"}],"wp:attachment":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/media?parent=678"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/categories?post=678"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/tags?post=678"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}