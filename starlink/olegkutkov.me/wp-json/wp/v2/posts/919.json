{"id":919,"date":"2019-08-29T02:14:11","date_gmt":"2019-08-28T23:14:11","guid":{"rendered":"http:\/\/olegkutkov.me\/?p=919"},"modified":"2021-02-11T16:15:18","modified_gmt":"2021-02-11T14:15:18","slug":"modifying-linux-network-routes-using-netlink","status":"publish","type":"post","link":"https:\/\/olegkutkov.me\/2019\/08\/29\/modifying-linux-network-routes-using-netlink\/","title":{"rendered":"Modifying Linux network routes using netlink"},"content":{"rendered":"<p><img loading=\"lazy\" decoding=\"async\" class=\"alignleft wp-image-920\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/08\/route_add_del_logo.png\" alt=\"\" width=\"101\" height=\"135\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/08\/route_add_del_logo.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/08\/route_add_del_logo-225x300.png 225w\" sizes=\"(max-width: 101px) 100vw, 101px\" \/><\/p>\n<p>Last time we <a href=\"https:\/\/olegkutkov.me\/2019\/03\/24\/getting-linux-routing-table-using-netlink\/\">talked<\/a> about getting a Linux routing table with a simple Netlink code.<br \/>\nNow it&#8217;s time to do more interesting stuff. Let&#8217;s add and delete some routes using the power of the Netlink!<!--more--><\/p>\n<p>At the end of this article, we will create a command-line utility with syntax similar to <strong>ip route<\/strong> command, which can add and delete custom routes.<\/p>\n<p>Like in previous examples, everything starts with a Netlink socket.<\/p>\n<pre class=\"prettyprint\">\/* Open netlink socket *\/\nint open_netlink()\n{\n    int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n\n    if (sock &lt; 0) {\n        perror(\"Failed to open netlink socket\");\n        return -1;\n    }\n\n    return sock;\n}<\/pre>\n<p>And that&#8217;s it!<br \/>\nWe don&#8217;t need to bind to the socket or do some other things. All we have to do is to build a special message and send it to the Netlink socket.<\/p>\n<p>Let&#8217;s describe the message structure.<\/p>\n<pre class=\"prettyprint\">struct {\n    struct nlmsghdr n;\n    struct rtmsg r;\n    char buf[4096];\n} nl_request;<\/pre>\n<p>Now we need to configure some fields of <strong>nlmsghdr<\/strong> and <strong>rtmsg<\/strong>.<br \/>\nSome of them are basic and used both in &#8220;add&#8221; and &#8220;delete&#8221; requests, but some contain actual command of what to do.<\/p>\n<p>Basic initialization:<\/p>\n<pre class=\"prettyprint\">nl_request.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtmsg));\nnl_request.r.rtm_table = RT_TABLE_MAIN;\nnl_request.r.rtm_scope = RT_SCOPE_NOWHERE;\nnl_request.n.nlmsg_flags = 0;<\/pre>\n<p>Let&#8217;s specify what we want to do &#8211; add or remove the route.<br \/>\nTo add a new route, specify <strong>nlmsg_type<\/strong> as <strong>RTM_NEWROUTE<\/strong><\/p>\n<pre class=\"prettyprint\">nl_request.n.nlmsg_type = RTM_NEWROUTE;<\/pre>\n<p>And <strong>RTM_DELROUTE<\/strong> in case of deleting<\/p>\n<pre class=\"prettyprint\">nl_request.n.nlmsg_type = RTM_DELROUTE;<\/pre>\n<p>Additionally, we can specify flags for the &#8220;add&#8221; operation, combining with <strong>NLM_F_REQUEST<\/strong> flag.<\/p>\n<blockquote>\n<p style=\"padding-left: 40px;\">NLM_F_REPLACE Replace existing matching object.<br \/>\nNLM_F_EXCL Don&#8217;t replace if the object already exists.<br \/>\nNLM_F_CREATE Create object if it doesn&#8217;t already exist.<br \/>\nNLM_F_APPEND Add to the end of the object list.<\/p>\n<\/blockquote>\n<p>Create a new routing table entry and don&#8217;t replace already existing record:<\/p>\n<pre class=\"prettyprint\">nl_request.n.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL<\/pre>\n<p>Also, we need to specify the route type in case of adding a new one.<\/p>\n<blockquote>\n<p style=\"padding-left: 40px;\">RTN_UNSPEC unknown route<br \/>\nRTN_UNICAST a gateway or direct route<br \/>\nRTN_LOCAL a local interface route<br \/>\nRTN_BROADCAST a local broadcast route (sent as a broadcast)<br \/>\nRTN_ANYCAST a local broadcast route (sent as a unicast)<br \/>\nRTN_MULTICAST a multicast route<br \/>\nRTN_BLACKHOLE a packet dropping route<br \/>\nRTN_UNREACHABLE an unreachable destination<br \/>\nRTN_PROHIBIT a packet rejection route<br \/>\nRTN_THROW continue routing lookup in another table<br \/>\nRTN_NAT a network address translation rule<\/p>\n<\/blockquote>\n<p>In simple cases, we can use <strong>RTN_UNICAST<\/strong>:<\/p>\n<pre class=\"prettyprint\">if (nl_request.n.nlmsg_type != RTM_DELROUTE) {\n    nl_request.r.rtm_type = RTN_UNICAST;\n}<\/pre>\n<p>Now the most interesting part &#8211; adding route details. It may vary depending on what we want. We can specify the target network, gateway, network interface, or just gateway.<\/p>\n<p>According to these details &#8211; protocol family, scope, and address length should be set.<\/p>\n<p>Let&#8217;s describe a simple case with the IPv4 route.<\/p>\n<pre class=\"prettyprint\">nl_request.r.rtm_family = AF_INET;\nnl_request.r.rtm_scope = RT_SCOPE_LINK;<\/pre>\n<p>If we add a route to some network, not a default gateway &#8211; we also need to specify destination address length in Bits. It&#8217;s simply 32 for IPv4 and 128 for IPv6.<!--?prettify linenums=true?--><\/p>\n<pre class=\"prettyprint\">nl_request.r.rtm_dst_len = 32;<\/pre>\n<p>Typically IP addresses are represented in human-readable text forms, but Netlink accepts only binary format.<\/p>\n<p>To deal with this, we can use <strong>inet_pton<\/strong> function from <strong>arpa\/inet.h.<\/strong><br \/>\nThis function supports converting both IPv4 and IPv6 into binary form.<\/p>\n<p>Conversion of the <strong>AF_INET<\/strong> (IPv4) address 192.168.1.0 into binary form and put it to <strong>data<\/strong> buffer:<\/p>\n<pre class=\"prettyprint\">#include &lt;arpa\/inet.h&gt;\n\nunsigned char data[sizeof(struct in6_addr)];\n\ninet_pton(AF_INET, \"192.168.1.0\", data);<\/pre>\n<p>In some cases, we also need to specify the outgoing network interface.<br \/>\nUser-friendly names like &#8220;eth0&#8221; should also be converted to numeric indexes. Here we can use <strong>if_nametoindex<\/strong> from <strong>net\/if.h.<\/strong><\/p>\n<pre class=\"prettyprint\">#include &lt;net\/if.h&gt;\n\nint if_idx = if_nametoindex(\"eth0\");<\/pre>\n<p>To add IP addresses data and interface index to our Netlink request, we need to use a special function that actually acts as a reverse of the <strong>parse_rtattr<\/strong> from the <a href=\"https:\/\/olegkutkov.me\/2019\/03\/24\/getting-linux-routing-table-using-netlink\/\">previous<\/a> articles.<\/p>\n<pre class=\"prettyprint\">\/* Add new data to rtattr *\/\nint rtattr_add(struct nlmsghdr *n, int maxlen, int type, const void *data, int alen)\n{\n    int len = RTA_LENGTH(alen);\n    struct rtattr *rta;\n\n    if (NLMSG_ALIGN(n-&gt;nlmsg_len) + RTA_ALIGN(len) &gt; maxlen) {\n        fprintf(stderr, \"rtattr_add error: message exceeded bound of %d\\n\", maxlen);\n        return -1;\n    }\n\n    rta = NLMSG_TAIL(n);\n    rta-&gt;rta_type = type;\n    rta-&gt;rta_len = len; \n\n    if (alen) {\n        memcpy(RTA_DATA(rta), data, alen);\n    }\n\n    n-&gt;nlmsg_len = NLMSG_ALIGN(n-&gt;nlmsg_len) + RTA_ALIGN(len);\n\n    return 0;\n}<\/pre>\n<p>And here is how to use this function and add network interface-id to our <strong>nl_request<\/strong> structure:<\/p>\n<pre class=\"prettyprint\">rtattr_add(&amp;nl_request.n, sizeof(nl_request), RTA_OIF, &amp;if_idx, sizeof(int));<\/pre>\n<p>Add gateway:<\/p>\n<pre class=\"prettyprint\">rtattr_add(&amp;nl_request.n, sizeof(nl_request), RTA_GATEWAY, gw_bin_data, 16);<\/pre>\n<p><strong>gw_bin_data<\/strong> is IP address binary data acquired with inet_pton, and 16 is IPv4 address length in bytes (not a bit in this case), for IPv6 use 16.<\/p>\n<p>We can use attribute type RTA_DST or RTA_NEWDST on the newest Linux kernels to add a destination network. Just check what&#8217;s available on your system.<\/p>\n<pre class=\"prettyprint\">rtattr_add(&amp;nl_request.n, sizeof(nl_request), \/*RTA_NEWDST*\/ RTA_DST, dst_net_bin_data, 16);<\/pre>\n<p>Please note that there are some rules with a combination of these attributes. For the default gateway, we DON&#8217;T need to specify the destination network and even network interface id. The kernel can figure it out by itself.<\/p>\n<p>Now send this message to the socket.<\/p>\n<pre class=\"prettyprint\">send(sock, &amp;nl_request, sizeof(nl_request), 0);<\/pre>\n<p>A complete example is below.<br \/>\nI decided to write a program with quite a complex command-line interface that can act as the <strong>ip route<\/strong> tool. All arguments parsing is implemented withing <strong>main()<\/strong> function, parser requires strict order of the params.<br \/>\nThis program might be buggy and imperfect, but this is just an example that can do the job \ud83d\ude42<\/p>\n<pre class=\"prettyprint\">\/*\n *\n *\/\n\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;sys\/types.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;net\/if.h&gt;\n#include &lt;arpa\/inet.h&gt;\n#include &lt;sys\/socket.h&gt;\n#include &lt;linux\/rtnetlink.h&gt;\n\n\/* Open netlink socket *\/\nint open_netlink()\n{\n    struct sockaddr_nl saddr;\n\n    int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n\n    if (sock &lt; 0) {\n        perror(\"Failed to open netlink socket\");\n        return -1;\n    }\n\n    memset(&amp;saddr, 0, sizeof(saddr));\n\n    return sock;\n}\n\n\/* Helper structure for ip address data and attributes *\/\ntypedef struct {\n    char family;\n    char bitlen;\n    unsigned char data[sizeof(struct in6_addr)];\n} _inet_addr;\n\n\/* *\/\n\n#define NLMSG_TAIL(nmsg) \\\n    ((struct rtattr *) (((void *) (nmsg)) + NLMSG_ALIGN((nmsg)-&gt;nlmsg_len)))\n\n\/* Add new data to rtattr *\/\nint rtattr_add(struct nlmsghdr *n, int maxlen, int type, const void *data, int alen)\n{\n    int len = RTA_LENGTH(alen);\n    struct rtattr *rta;\n\n    if (NLMSG_ALIGN(n-&gt;nlmsg_len) + RTA_ALIGN(len) &gt; maxlen) {\n        fprintf(stderr, \"rtattr_add error: message exceeded bound of %d\\n\", maxlen);\n        return -1;\n    }\n\n    rta = NLMSG_TAIL(n);\n    rta-&gt;rta_type = type;\n    rta-&gt;rta_len = len; \n\n    if (alen) {\n        memcpy(RTA_DATA(rta), data, alen);\n    }\n\n    n-&gt;nlmsg_len = NLMSG_ALIGN(n-&gt;nlmsg_len) + RTA_ALIGN(len);\n\n    return 0;\n}\n\nint do_route(int sock, int cmd, int flags, _inet_addr *dst, _inet_addr *gw, int def_gw, int if_idx)\n{\n    struct {\n        struct nlmsghdr n;\n        struct rtmsg r;\n        char buf[4096];\n    } nl_request;\n\n    \/* Initialize request structure *\/\n    nl_request.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtmsg));\n    nl_request.n.nlmsg_flags = NLM_F_REQUEST | flags;\n    nl_request.n.nlmsg_type = cmd;\n    nl_request.r.rtm_family = dst-&gt;family;\n    nl_request.r.rtm_table = RT_TABLE_MAIN;\n    nl_request.r.rtm_scope = RT_SCOPE_NOWHERE;\n\n    \/* Set additional flags if NOT deleting route *\/\n    if (cmd != RTM_DELROUTE) {\n        nl_request.r.rtm_protocol = RTPROT_BOOT;\n        nl_request.r.rtm_type = RTN_UNICAST;\n    }\n\n    nl_request.r.rtm_family = dst-&gt;family;\n    nl_request.r.rtm_dst_len = dst-&gt;bitlen;\n\n    \/* Select scope, for simplicity we supports here only IPv6 and IPv4 *\/\n    if (nl_request.r.rtm_family == AF_INET6) {\n        nl_request.r.rtm_scope = RT_SCOPE_UNIVERSE;\n    } else {\n        nl_request.r.rtm_scope = RT_SCOPE_LINK;\n    }\n\n    \/* Set gateway *\/\n    if (gw-&gt;bitlen != 0) {\n        rtattr_add(&amp;nl_request.n, sizeof(nl_request), RTA_GATEWAY, &amp;gw-&gt;data, gw-&gt;bitlen \/ 8);\n        nl_request.r.rtm_scope = 0;\n        nl_request.r.rtm_family = gw-&gt;family;\n    }\n\n    \/* Don't set destination and interface in case of default gateways *\/\n    if (!def_gw) {\n        \/* Set destination network *\/\n        rtattr_add(&amp;nl_request.n, sizeof(nl_request), \/*RTA_NEWDST*\/ RTA_DST, &amp;dst-&gt;data, dst-&gt;bitlen \/ 8);\n\n        \/* Set interface *\/\n        rtattr_add(&amp;nl_request.n, sizeof(nl_request), RTA_OIF, &amp;if_idx, sizeof(int));\n    }\n\n    \/* Send message to the netlink *\/\n    return send(sock, &amp;nl_request, sizeof(nl_request), 0);\n}\n\n\/* Simple parser of the string IP address\n *\/\nint read_addr(char *addr, _inet_addr *res)\n{\n    if (strchr(addr, ':')) {\n        res-&gt;family = AF_INET6;\n        res-&gt;bitlen = 128;\n    } else {\n        res-&gt;family = AF_INET;\n        res-&gt;bitlen = 32;\n    }\n\n    return inet_pton(res-&gt;family, addr, res-&gt;data);\n}\n\n#define NEXT_CMD_ARG() do { argv++; if (--argc &lt;= 0) exit(-1); } while(0)\n\nint main(int argc, char **argv)\n{\n    int default_gw = 0;\n    int if_idx = 0;\n    int nl_sock;\n    _inet_addr to_addr = { 0 };\n    _inet_addr gw_addr = { 0 };\n\n    int nl_cmd;\n    int nl_flags;\n\n    \/* Parse command line arguments *\/\n    while (argc &gt; 0) {\n        if (strcmp(*argv, \"add\") == 0) {\n            nl_cmd = RTM_NEWROUTE;\n            nl_flags = NLM_F_CREATE | NLM_F_EXCL;\n\n        } else if (strcmp(*argv, \"del\") == 0) {\n            nl_cmd = RTM_DELROUTE;\n            nl_flags = 0;\n\n        } else if (strcmp(*argv, \"to\") == 0) {\n            NEXT_CMD_ARG(); \/* skip \"to\" and jump to the actual destination addr *\/\n\n            if (read_addr(*argv, &amp;to_addr) != 1) {\n                fprintf(stderr, \"Failed to parse destination network %s\\n\", *argv);\n                exit(-1);\n            }\n\n        } else if (strcmp(*argv, \"dev\") == 0) {\n            NEXT_CMD_ARG(); \/* skip \"dev\" *\/\n\n            if_idx = if_nametoindex(*argv);\n\n        } else if (strcmp(*argv, \"via\") == 0) {\n            NEXT_CMD_ARG(); \/* skip \"via\"*\/\n\n            \/* Instead of gw address user can set here keyword \"default\" *\/\n            \/* Try to read this keyword and jump to the actual gateway addr *\/\n            if (strcmp(*argv, \"default\") == 0) {\n                default_gw = 1;\n                NEXT_CMD_ARG();\n            }\n\n            if (read_addr(*argv, &amp;gw_addr) != 1) {\n                fprintf(stderr, \"Failed to parse gateway address %s\\n\", *argv);\n                exit(-1);\n            }\n        }\n\n        argc--; argv++;\n    }\n\n    nl_sock = open_netlink();\n\n    if (nl_sock &lt; 0) {\n        exit(-1);\n    }\n\n    do_route(nl_sock, nl_cmd, nl_flags, &amp;to_addr, &amp;gw_addr, default_gw, if_idx);\n\n    close (nl_sock);\n\n    return 0;\n}\n<\/pre>\n<p>Before testing, let&#8217;s print the current routing table:<\/p>\n<blockquote><p>$ ip route<br \/>\ndefault via 192.168.8.1 dev eth0<br \/>\n192.168.8.0\/24 dev eth0 proto kernel scope link src 192.168.8.2<\/p><\/blockquote>\n<p>Now compile our program.<\/p>\n<blockquote><p>gcc set_route.c -o set_route<\/p><\/blockquote>\n<p>Add a new route to network 192.168.1.0 via eth0:<\/p>\n<blockquote><p>$ sudo .\/set_route add to 192.168.1.0 dev eth0<\/p>\n<p>$ ip route<br \/>\ndefault via 192.168.8.1 dev eth0<br \/>\n192.168.1.0 dev eth0 proto none scope link<br \/>\n192.168.8.0\/24 dev eth0 proto kernel scope link src 192.168.8.2<\/p><\/blockquote>\n<p>Works!<\/p>\n<p>Delete this route:<\/p>\n<blockquote><p>$ sudo .\/set_route del to 192.168.1.0 dev eth0<\/p>\n<p>$ ip route<br \/>\ndefault via 192.168.8.1 dev eth0<br \/>\n192.168.8.0\/24 dev eth0 proto kernel scope link src 192.168.8.2<\/p><\/blockquote>\n<p>More examples.<\/p>\n<p>Add route to 192.168.1.0 using eth0 and 192.168.8.1 gateway: <b>sudo .\/set_route add to 192.168.8.0 dev eth0 via 192.168.8.1<\/b><br \/>\nDelete this route: <b>sudo .\/set_route del to 192.168.8.0 dev eth0 via 192.168.8.1<\/b><\/p>\n<p>To add default gateway via 192.168.8.1 just: <b>sudo .\/set_route add via default 192.168.8.1<\/b><\/p>\n<p>Thanks for reading!<\/p>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Last time we talked about getting a Linux routing table with a simple Netlink code. Now it&#8217;s time to do more interesting stuff. Let&#8217;s add and delete some routes using the power of the Netlink!<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[76,25,78,54],"tags":[27,26,29,75],"_links":{"self":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/919"}],"collection":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/comments?post=919"}],"version-history":[{"count":19,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/919\/revisions"}],"predecessor-version":[{"id":1849,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/919\/revisions\/1849"}],"wp:attachment":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/media?parent=919"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/categories?post=919"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/tags?post=919"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}