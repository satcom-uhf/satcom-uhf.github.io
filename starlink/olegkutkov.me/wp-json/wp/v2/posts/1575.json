{"id":1575,"date":"2021-01-07T01:05:57","date_gmt":"2021-01-06T23:05:57","guid":{"rendered":"https:\/\/olegkutkov.me\/?p=1575"},"modified":"2022-04-03T14:52:45","modified_gmt":"2022-04-03T11:52:45","slug":"writing-a-pci-device-driver-for-linux","status":"publish","type":"post","link":"https:\/\/olegkutkov.me\/2021\/01\/07\/writing-a-pci-device-driver-for-linux\/","title":{"rendered":"Writing a PCI device driver for Linux"},"content":{"rendered":"<p><img loading=\"lazy\" decoding=\"async\" class=\"alignleft size-full wp-image-1577\" src=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2020\/12\/pic_card_image.jpeg\" alt=\"\" width=\"150\" height=\"131\" \/>In this article, I want to discuss some basics of the Linux PCI\/PCIe drivers development. I think this issue is not properly covered, and some existing information is might be outdated.<\/p>\n<p>I will show basic concepts and important structures, and this is might be a good beginner guide for newbie driver developers.<\/p>\n<p><!--more--><\/p>\n<p>The <a href=\"https:\/\/en.wikipedia.org\/wiki\/Peripheral_Component_Interconnect\">PCI<\/a> bus is the most popular way to connect high-speed peripheral inside a modern computer system. It&#8217;s a video and network adapters, sound cards, storage devices, etc. Some custom and special devices, some acquisition boards with ADC, or any other interface might be custom and special devices. Even your modern laptop uses this bus to connect internal devices to the CPU, even without actual physical connectors.<br \/>\nThis bus is widely available on a different platforms, like x86 and ARM. These days, it&#8217;s quite common to use a PCI bus to connect a high-performance wireless chip to the SoC inside WiFi routers.<\/p>\n<p><a href=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/simple_pcie_wifi_router.png\"><img loading=\"lazy\" decoding=\"async\" class=\"size-full wp-image-1586 aligncenter\" src=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/simple_pcie_wifi_router.png\" alt=\"\" width=\"634\" height=\"225\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/simple_pcie_wifi_router.png 634w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/simple_pcie_wifi_router-400x142.png 400w\" sizes=\"(max-width: 634px) 100vw, 634px\" \/><\/a><\/p>\n<h3>PCI and PCI Express<\/h3>\n<p>The original PCI bus was parallel with a lot of contacts and is currently obsolete. I will not focus on the obsolete PCI bus.<br \/>\nModern and faster <strong>PCIe<\/strong> bus uses single or multiple (1-16) pairs of differential wires (lanes, one pair for TX, and one for RX). You can tell the number of differential lines by the bus name, x1, x4, and x16. More lanes give a bigger throughput. Another difference between the PCI Express bus and the older PCI is the bus topology; PCI uses a shared parallel bus architecture. PCI Express is based on point-to-point topology, with separate serial links connecting every device to the root complex controller that can be integrated into the CPU. The PCI host and all devices share a common set of address, data, and control lines. You can read an excellent architecture explanation in <a href=\"https:\/\/en.wikipedia.org\/wiki\/PCI_Express#Architecture\">this<\/a> Wikipedia article.<\/p>\n<p>From the typical driver&#8217;s point of view, there is no difference between PCI and PCI Express. All differences are handled by the hardware and lower bus drivers of the Linux kernel. For the driver developer, API is the same.<\/p>\n<h3>Linux PCI subsystem<\/h3>\n<p>The operating system PCI subsystem reflects the actual hardware configuration and interconnections. There might be multiple PCI buses and multiple devices on those buses. Every bus and device is assigned a unique number, which allows identifying each module. Also, a PCI device might have different &#8220;functions&#8221; or &#8220;endpoints.&#8221; All those endpoints are also numbered. The full system path to the device might look like this: <strong>&lt;bus id&gt;:&lt;device id&gt;:&lt;function id&gt;<\/strong><br \/>\nAdditionally, every PCI device contains factory-programmed Vendor and Device IDs. These IDs are also unique and assigned by the <a href=\"https:\/\/pcisig.com\">PCI regulatory consortium<\/a>.<br \/>\nThe Linux kernel can properly identify a device and load the proper driver using these IDs. Of course, every driver should have ID verification routines.<\/p>\n<p>The primary userspace utility is <code>lspci<\/code> This command can show a lot of useful information.\u00a0 Run this command with &#8220;<strong>-nn<\/strong>&#8221; argument to get all devices with IDs.<\/p>\n<p><a href=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/lspci_explain1_nr.jpeg\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-large wp-image-1607\" src=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/lspci_explain1_nr-1024x760.jpeg\" alt=\"\" width=\"850\" height=\"631\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/lspci_explain1_nr-1024x760.jpeg 1024w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/lspci_explain1_nr-400x297.jpeg 400w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/lspci_explain1_nr-768x570.jpeg 768w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/lspci_explain1_nr.jpeg 1102w\" sizes=\"(max-width: 850px) 100vw, 850px\" \/><\/a><\/p>\n<p>You can see many internal PCIe devices here, bridges, USB controllers, Audio and Network controllers, etc. All this information can be obtained manually from the <strong>sysfs<\/strong>:<\/p>\n<blockquote><p>ls -la \/sys\/bus\/pci\/devices<br \/>\nlrwxrwxrwx 1 root root 0 Dec 21 14:05 0000:00:00.0 -&gt; ..\/..\/..\/devices\/pci0000:00\/0000:00:00.0<br \/>\nlrwxrwxrwx 1 root root 0 Dec 21 14:05 0000:00:00.2 -&gt; ..\/..\/..\/devices\/pci0000:00\/0000:00:00.2<br \/>\nlrwxrwxrwx 1 root root 0 Dec 21 14:05 0000:00:01.0 -&gt; ..\/..\/..\/devices\/pci0000:00\/0000:00:01.0<br \/>\nlrwxrwxrwx 1 root root 0 Dec 21 14:05 0000:00:01.2 -&gt; ..\/..\/..\/devices\/pci0000:00\/0000:00:01.2<\/p>\n<p>&#8230;<\/p><\/blockquote>\n<p>The human-readable strings are not taken from the hardware. This is a local database of the <code>lspci<\/code>: <strong>\/usr\/share\/hwdata\/pci.id<\/strong><br \/>\nYou can always find the latest PCI ID database here: <a href=\"https:\/\/pci-ids.ucw.cz\/\">https:\/\/pci-ids.ucw.cz\/<\/a><br \/>\nOr you can check the Vendor ID here: <a href=\"https:\/\/pcisig.com\/membership\/member-companies\">https:\/\/pcisig.com\/membership\/member-companies<\/a><\/p>\n<p>The Linux kernel assigns special memory regions, &#8220;Base Address Registers&#8221; (BARs), to communicate with the hardware. These memory addresses (and region length) are written to the PCI controller hardware during the system boot.<br \/>\nYou can find something like this In <code>dmesg<\/code>:<\/p>\n<blockquote><p>[ 0.959296] pci_bus 0001:00: root bus resource [bus 00-ff]<br \/>\n[ 0.964853] pci_bus 0001:00: root bus resource [io 0x10000-0x1ffff] (bus address [0x0000-0xffff])<br \/>\n[ 0.973943] pci_bus 0001:00: root bus resource [mem 0x4840000000-0x487fffffff] (bus address [0x40000000-0x7fffffff])<br \/>\n[ 0.999755] pci 0001:00:00.0: <strong>BAR<\/strong> 14: assigned [mem 0x4840000000-0x48402fffff]<br \/>\n[ 1.007107] pci 0001:00:00.0: <strong>BAR<\/strong> 6: assigned [mem 0x4840300000-0x48403007ff pref]<br \/>\n[ 1.014769] pci 0001:01:00.0: <strong>BAR<\/strong> 0: assigned [mem 0x4840000000-0x48401fffff 64bit]<br \/>\n[ 1.022579] pci 0001:01:00.0: <strong>BAR<\/strong> 6: assigned [mem 0x4840200000-0x484020ffff pref]<br \/>\n[ 1.030265] pci 0001:00:00.0: PCI bridge to [bus 01-ff]<br \/>\n[ 1.035563] pci 0001:00:00.0: bridge window [mem 0x4840000000-0x48402fffff]<\/p><\/blockquote>\n<p>There is no way to determine installed PCI hardware. So the bus must be enumerated. Bus enumeration is performed by attempting to read the vendor ID and device ID (VID\/DID) register for each combination of the bus number and device number at the device&#8217;s function #0.<\/p>\n<p>The kernel can call the corresponding driver during the enumeration stage with a compatible VID\/PID pair. Some devices (like PCI bridges) might be statically described in the device tree in an embedded system. The static hardware configuration is supported with &#8220;platform drivers&#8221;.<\/p>\n<p>Every PCI compliant device should implement a basic set of register &#8211; configuration registers.<br \/>\nThe Linux kernel attempts to read these registers to identify and properly configure the device. All these registers are mapped to the memory and available for the driver developer for reading and writing.<\/p>\n<p>The first 64 bytes of the registers are mandatory and should be implemented (by the hardware vendor) in any case.<\/p>\n<p><a href=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/RECg6.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-1595\" src=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/RECg6.png\" alt=\"\" width=\"705\" height=\"400\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/RECg6.png 705w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/RECg6-400x227.png 400w\" sizes=\"(max-width: 705px) 100vw, 705px\" \/><\/a>The optional registers may contain zero values if there is nothing to provide from the hardware.<\/p>\n<blockquote><p>Please note that byte order is always little-endian. This might be important if you are working on some big-endian system.<\/p><\/blockquote>\n<p>Let&#8217;s dig into some registers deeply.<\/p>\n<p><strong>Vendor ID<\/strong> and <strong>Device ID<\/strong> are already well known and should contain valid identifiers of the hardware vendor.<\/p>\n<p><strong>Command<\/strong> registers define some capabilities. The operating system initializes these bits.<\/p>\n<p><a href=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/pci_command.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-1597\" src=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/pci_command.png\" alt=\"\" width=\"563\" height=\"324\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/pci_command.png 709w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/pci_command-400x230.png 400w\" sizes=\"(max-width: 563px) 100vw, 563px\" \/><\/a><\/p>\n<p><strong>Status<\/strong> register holds different events of the PCI bus and is filled by the hardware.<\/p>\n<p><a href=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/pci_status.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-1598\" src=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/pci_status.png\" alt=\"\" width=\"563\" height=\"333\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/pci_status.png 735w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2021\/01\/pci_status-400x237.png 400w\" sizes=\"(max-width: 563px) 100vw, 563px\" \/><\/a><strong>Class code <\/strong>defines a class of the device (Network adapter, for example). The full list of the class codes can be found here: <a href=\"https:\/\/wiki.osdev.org\/PCI#Class_Codes\">https:\/\/wiki.osdev.org\/PCI#Class_Codes<\/a><\/p>\n<p><strong>Base Address Registers<\/strong> &#8211; &#8220;BAR&#8221; registers filled by the Linux kernel and used for the IO operations.<\/p>\n<p><strong>Subsystem Vendor ID<\/strong> and <strong>Subsystem<\/strong> <strong>Device ID <\/strong>&#8211; helps to differentiate specific board\/device model. This is is optional, of course.<\/p>\n<p>The Linux kernel PCI implementation can be found in the kernel source tree <code>drivers\/pci directory<\/code>.<br \/>\nFor driver developers kernel provides a header file <code>include\/linux\/pci.h<\/code>. Here you can find all the required structures and functions.<\/p>\n<p>The main PCI driver structure is <a href=\"https:\/\/elixir.bootlin.com\/linux\/latest\/source\/include\/linux\/pci.h#L309\"><code>struct pci_dev<\/code><\/a>. This is quite a big structure representing an actual device and can be used for the register&#8217;s access and IO operations. Typically you don&#8217;t need to remember all fields of the structure, only basic concepts.<\/p>\n<p>PCI driver entry point is <code>struct pci_driver<\/code>. The driver developer should initialize this structure (set callbacks) and pass it to the kernel.<\/p>\n<pre class=\"prettyprint\">struct pci_driver {\n    struct list_head node;\n    const char *name;\n    const struct pci_device_id *id_table; \/* Must be non-NULL for probe to be called *\/\n    int (*probe)(struct pci_dev *dev, const struct pci_device_id *id); \/* New device inserted *\/\n    void (*remove)(struct pci_dev *dev); \/* Device removed (NULL if not a hot-plug capable driver) *\/\n    int (*suspend)(struct pci_dev *dev, pm_message_t state); \/* Device suspended *\/\n    int (*resume)(struct pci_dev *dev); \/* Device woken up *\/\n    void (*shutdown)(struct pci_dev *dev);\n    int (*sriov_configure)(struct pci_dev *dev, int num_vfs); \/* On PF *\/\n    const struct pci_error_handlers *err_handler;\n    const struct attribute_group **groups;\n    struct device_driver driver;\n    struct pci_dynids dynids;\n};<\/pre>\n<p>The structure field &#8220;id_table&#8221; should be initialized with the IDs array. Those IDs define compatible Vendor and Product IDs for devices. You can set here multiple pairs of VID\/PID if your driver supports multiple devices. For example, declare support of <strong>VID<\/strong> = 0F1F + <strong>PID<\/strong> = 0F0E, and <strong>VID<\/strong> = 0F2F + <strong>PID<\/strong> = 0F0D:<\/p>\n<pre class=\"prettyprint\">static struct pci_device_id my_driver_id_table[] = {\n    { PCI_DEVICE(0x0F1F, 0x0F0E) },\n    { PCI_DEVICE(0x0F2F, 0x0F0D) },\n    {0,}\n};<\/pre>\n<p>It&#8217;s important to end this array with a single zero value.<\/p>\n<p>Most drivers should export this table using <code>MODULE_DEVICE_TABLE(pci, ...)<\/code>.<\/p>\n<p>This macro is doing a few important things.<br \/>\nIf your driver is built-in and compiled with the kernel, then the driver information (device IDs table) will be statically integrated into the global devices table. This allows the kernel to run your driver automatically when compatible hardware is found.<br \/>\nIf your driver is built as a separate module, then the device table can be extracted with <code>depmod<\/code> utility. This information is added to a cache and automatically loads your driver kernel object when compatible hardware is found.<\/p>\n<p>Other important fields of the <code>struct pci_driver<\/code> are:<\/p>\n<p><strong>.name<\/strong> &#8211; unique driver name, this string will be displayed in <code>\/sys\/bus\/pci\/drivers<\/code><br \/>\n<strong>.probe<\/strong> &#8211; A callback function called by the kernel after the driver registration.<br \/>\n<strong>.remove<\/strong> &#8211; A callback function called by the kernel during the driver unloading.<br \/>\n<strong>.suspend<\/strong> &#8211; A callback function called by kernel when the system is going to suspend mode.<br \/>\n<strong>.resume<\/strong> &#8211; A callback function called when the system resumes after the suspend mode.<\/p>\n<p>Configured pci_driver should be registered and unregistered during the driver module loading and unloading. This allows the kernel to run your driver.<\/p>\n<pre class=\"prettyprint\">pci_register_driver(struct pci_driver *);\npci_unregister_driver(struct pci_driver *);<\/pre>\n<h3>Device access<\/h3>\n<p>To access PCI configuration registers kernel provides a set of functions:<\/p>\n<pre class=\"prettyprint\">int pci_read_config_byte(const struct pci_dev *dev, int where, u8 *val);\nint pci_read_config_word(const struct pci_dev *dev, int where, u16 *val);\nint pci_read_config_dword(const struct pci_dev *dev, int where, u32 *val);\nint pci_write_config_byte(const struct pci_dev *dev, int where, u8 val);\nint pci_write_config_word(const struct pci_dev *dev, int where, u16 val);\nint pci_write_config_dword(const struct pci_dev *dev, int where, u32 val);<\/pre>\n<p>You can read and write 8, 16, and 32-bit data.<\/p>\n<p>The argument &#8220;where&#8221; specifies the actual register offset. All accessible values are defined in <code>linux\/pci_regs.h<\/code><\/p>\n<p>For example, read PCI device <strong>Vendor ID<\/strong> and <strong>Product ID<\/strong>:<\/p>\n<pre class=\"prettyprint\">#include &lt;linux\/pci.h&gt;\n\nu16 vendor, device, revision;\n\npci_read_config_word(dev, PCI_VENDOR_ID, &amp;vendor);\npci_read_config_word(dev, PCI_DEVICE_ID, &amp;device);<\/pre>\n<p>Read the &#8220;Interrupt state&#8221; of the <strong>Status<\/strong> register:<\/p>\n<pre class=\"prettyprint\">#include &lt;linux\/pci.h&gt;\n\nu16 status_reg;\n\npci_read_config_word(dev, PCI_STATUS, &amp;status_reg);\n\n\/* Check the bit 3 *\/\nif ((status_reg &gt;&gt; 3) &amp; 0x1) {\n    printk(\"Interrupt bit is set\\n\");\n} else {\n    printk(\"Interrupt bit is not set\\n\");\n}<\/pre>\n<p>Sure, the kernel has many other functions, but we will not discuss them there.<\/p>\n<p>Actual device control and data communication is made through the mapped memory (BARs). It&#8217;s a little bit tricky.<br \/>\nOf course, it&#8217;s just a memory region(s). What to read and write is depends on the actual hardware. It&#8217;s required to get actual offsets, data types, and &#8220;magic&#8221; numbers somewhere. Typically this is done through the reverse engineering of the Windows driver. But this is outside the scope of this article.<br \/>\nSometimes hardware vendors are kind enough to share their protocols and specifications.<\/p>\n<p>To access the device memory, we need to request the memory region, start and stop offsets and map this memory region to some local pointer.<\/p>\n<pre class=\"prettyprint\">#include &lt;linux\/pci.h&gt;\n\nint bar;\nunsigned long mmio_start, mmio_len;\nu8 __iomem *hwmem; \/* Memory pointer for the I\/O operations *\/\n\nstruct pci_dev *pdev; \/* Initialized pci_dev *\/\n\n...\n\n\/* Request the I\/O resource *\/\nbar = pci_select_bars(pdev, IORESOURCE_MEM);\n\n\/* \"enable\" device memory *\/\npci_enable_device_mem(pdev);\n\n\/* Request the memory region *\/\npci_request_region(pdev, bar, \"My PCI driver\");\n\n\/* Get the start and stop memory positions *\/\nmmio_start = pci_resource_start(pdev, 0);\nmmio_len = pci_resource_len(pdev, 0);\n\n\/* map provided resource to the local memory pointer *\/\nhwmem = ioremap(mmio_start, mmio_len);\n<\/pre>\n<p>Now it&#8217;s possible to use <code>hwmem<\/code> to read and write from\/to the device. The only correct way is to use special kernel routines. The data can be read and written in the 8, 16, and 32-bit chunks.<\/p>\n<pre class=\"prettyprint\">void iowrite8(u8 b, void __iomem *addr);\nvoid iowrite16(u16 b, void __iomem *addr);\nvoid iowrite32(u16 b, void __iomem *addr);\n\nunsigned int ioread8(void __iomem *addr);\nunsigned int ioread16(void __iomem *addr);\nunsigned int ioread32(void __iomem *addr);<\/pre>\n<p>You might note that there is an alternatively IO API that can be found in some drivers.<\/p>\n<pre class=\"prettyprint\">#include &lt;linux\/io.h&gt;\n\nunsigned readb(address);\nunsigned readw(address);\nunsigned readl(address);\nvoid writeb(unsigned value, address);\nvoid writew(unsigned value, address);\nvoid writel(unsigned value, address);<\/pre>\n<p>On x86 and ARM platforms, <code>ioreadX<\/code>\/<code>iowriteX<\/code> functions are just inline wrappers around these <code>readX<\/code>\/<code>writeX<\/code> functions. But for better portability and compatibility, it&#8217;s highly recommended to use <code>io*<\/code> functions.<\/p>\n<h3>PCI DMA<\/h3>\n<p>The high-performance device supports Direct Memory Access. This is implemented with bus mastering. Buse mastering is the capability of devices on the PCI bus to take control of the bus and perform transfers to the mapped memory directly.<\/p>\n<p>Bus mastering (if supported) can be enabled and disabled with the following functions:<\/p>\n<pre class=\"prettyprint\">void pci_set_master(struct pci_dev *dev);\nvoid pci_clear_master(struct pci_dev *dev);<\/pre>\n<h3>PCI interrupts<\/h3>\n<p>Interrupt handling is critical in device drivers.<br \/>\nHardware may generate an interrupt on data reception event, error, state changes, and so on. All interrupts should be handled most optimally.<\/p>\n<p>There are two types of PCI interrupts:<\/p>\n<ul>\n<li><strong>Pin-based (INTx)<\/strong> interrupts, an old and classic way<\/li>\n<li><strong>MSI\/MSI-X<\/strong> interrupts, modern and more optimal way, introduced in PCI 2.2<\/li>\n<\/ul>\n<p>It&#8217;s highly recommended to use MSI interrupts when possible. There are a few reasons why using MSIs can be advantageous over traditional pin-based interrupts.<\/p>\n<p>Pin-based PCI interrupts are often shared amongst several devices. To support this, the kernel must call each interrupt handler associated with an interrupt, which leads to reduced performance for the system. MSIs are never shared, so this problem cannot arise.<\/p>\n<p>When a device writes data to memory, then raises a pin-based interrupt, the interrupt may arrive before all the data has arrived in memory (this becomes more likely with devices behind PCI-PCI bridges). The interrupt handler must read a register on the device that raised the interrupt to ensure that all the data has arrived in memory. PCI transaction ordering rules require that all the data arrive in memory before the value may be returned from the register. Using MSI&#8217;s avoids this problem as the interrupt-generating write cannot pass the data writes, so by the time the interrupt is raised, the driver knows that all the data has arrived in memory.<\/p>\n<p>Please note that not all machines support MSIs correctly.<\/p>\n<p>You can find information about currently allocated interrupts in \/proc\/interrupts<br \/>\nThis information contains interrupt spreads over the CPU cores and interrupts types (MSI or pin-based).<br \/>\nTypically interrupts are dynamically set for the CPU cores. A special daemon tries to spread interrupts in the most optimal way on some systems.<\/p>\n<p>Also, you can manually select the CPU core for the selected interrupt. This might be helpful in some fine-tuning situations.<br \/>\nThe core assignment can be done via the <strong>SMP affinity<\/strong> mechanism.<br \/>\nJust select required cores (in a binary pattern) and send this value (as HEX number) to <code>\/proc\/irq\/X\/smp_affinity<\/code>, where <strong>X<\/strong> is the interrupt number.<br \/>\nFor example, put IRQ 44 to the first and third cores (set bits 0 and 2, from left to right):<\/p>\n<p><code>echo 5 &gt; \/proc\/irq\/44\/smp_affinity<\/code><\/p>\n<p>Now let&#8217;s see how to use both types of interrupts.<\/p>\n<p><strong>INTx interrupts<\/strong><\/p>\n<p>The classic pin-based interrupt can be requested with <code>request_threaded_irq()<\/code>and <code>request_irq()<\/code><\/p>\n<pre class=\"prettyprint\">int request_threaded_irq( unsigned int irq,\n                          irq_handler_t handler,\n                          irq_handler_t thread_fn,\n                          unsigned long irqflags,\n                          const char * devname,\n                          void * dev_id);\n\nint request_irq( unsigned int irq,\n                 irqreturn_t handler,\n                 unsigned long irqflags,\n                 const char *devname,\n                 void *dev_id);<\/pre>\n<p>For the new drivers, it&#8217;s recommended to use <code>request_threaded_irq()<\/code><\/p>\n<p>The first parameter, <code>irq<\/code> specifies the interrupt number to allocate. For some devices, for example, legacy PC devices such as the system timer or keyboard, this value is typically hard-coded. It is probed or otherwise determined programmatically and dynamically for most other devices.<\/p>\n<p>The second parameter, <code>handler<\/code>Is the function to be called when the IRQ occurs.<\/p>\n<p><code>thread_fn<\/code> &#8211; Function called from the IRQ handler thread. If NULL &#8211; no IRQ thread is created.<\/p>\n<p><span class=\"term\"><code>irqflags<\/code> &#8211; <\/span>Interrupt type flags; Possible values can be found <a href=\"https:\/\/elixir.bootlin.com\/linux\/latest\/source\/include\/linux\/interrupt.h#L42\">here<\/a>.<\/p>\n<p><span class=\"term\"><code>dev_name<\/code><\/span> &#8211; The string passed to request_irq is used in <code>\/proc\/interrupts<\/code> to show the owner of the <code>interrupt<\/code>.<\/p>\n<p><span class=\"term\"><code>dev_id<\/code> &#8211; This pointer is used for shared interrupt lines. It is a unique identifier used when the interrupt line is freed, and the driver may also use that to point to its own private data area (to identify which device is interrupting).<br \/>\n<\/span><\/p>\n<p>In the end, all requested IRQs should be released with <code>free_irq()<\/code><\/p>\n<pre class=\"prettyprint\">void free_irq ( unsigned int irq, void * dev_id);<\/pre>\n<p><strong>A simple example, install and use interrupt #42:<\/strong><\/p>\n<pre class=\"prettyprint\">static irqreturn_t sample_irq(int irq, void *dev_id)\n{\n    printk(\"IRQ %d\\n\", irq);\n    return IRQ_HANDLED;\n}\n\n...\n\nif (request_irq(42, test_irq, 0, \"test_irq\", 0) &lt; 0) {\n    return -1;\n}<\/pre>\n<p>&nbsp;<\/p>\n<p><strong>MSI interrupts<\/strong><\/p>\n<p>In the case of MSI\/MSIX interrupts, everything is almost the same, but it&#8217;s required to tell the PCI subsystem that we want to use MSI\/MSIX interrupts.<\/p>\n<p>Use the following function:<\/p>\n<pre class=\"prettyprint\">int pci_alloc_irq_vectors(struct pci_dev *dev, unsigned int min_vecs, unsigned int max_vecs, unsigned int flags);<\/pre>\n<p>This function allocates up to max_vecs interrupt vectors for a PCI device. It returns the number of vectors allocated or a negative error.<\/p>\n<p>The flags argument is used to specify which type of interrupt can be used by the device and the driver (<strong>PCI_IRQ_LEGACY<\/strong>, <strong>PCI_IRQ_MSI<\/strong>, <strong>PCI_IRQ_MSIX<\/strong>). A convenient short-hand (PCI_IRQ_ALL_TYPES) is also available to ask for any possible kind of interrupt. If the <strong>PCI_IRQ_AFFINITY<\/strong> flag is set, <code>pci_alloc_irq_vectors()<\/code> will spread the interrupts around the available CPUs.<\/p>\n<p>Of course, interrupt type (MSI\/MSIX) and the number of MSI interrupts depend on your hardware.<\/p>\n<p>Free the allocated resources with:<\/p>\n<pre class=\"prettyprint\">void pci_free_irq_vectors(struct pci_dev *dev);<\/pre>\n<h3><\/h3>\n<h3>PCI driver skeleton<\/h3>\n<p>I think it&#8217;s enough with boring theory.<br \/>\nThis is an example of the PCI device driver. This driver can load and register for specified VID\/PID pairs. Some basic operations (config registers read, memory read\/write) are performed.<\/p>\n<pre class=\"prettyprint\">\/* Sample Linux PCI device driver *\/\n\n#include &lt;linux\/init.h&gt;\n#include &lt;linux\/module.h&gt;\n#include &lt;linux\/pci.h&gt;\n\n#define MY_DRIVER \"my_pci_driver\"\n\n\/* This sample driver supports device with VID = 0x010F, and PID = 0x0F0E*\/\nstatic struct pci_device_id my_driver_id_table[] = {\n    { PCI_DEVICE(0x010F, 0x0F0E) },\n    {0,}\n};\n\nMODULE_DEVICE_TABLE(pci, my_driver_id_table);\n\nstatic int my_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent);\nstatic void my_driver_remove(struct pci_dev *pdev);\n\n\/* Driver registration structure *\/\nstatic struct pci_driver my_driver = {\n    .name = MY_DRIVER,\n    .id_table = my_driver_id_table,\n    .probe = my_driver_probe,\n    .remove = my_driver_remove\n};\n\n\/* This is a \"private\" data structure *\/\n\/* You can store there any data that should be passed between driver's functions *\/\nstruct my_driver_priv {\n    u8 __iomem *hwmem;\n};\n\n\/* *\/\n\nstatic int __init mypci_driver_init(void)\n{\n    \/* Register new PCI driver *\/\n    return pci_register_driver(&amp;my_driver);\n}\n\nstatic void __exit mypci_driver_exit(void)\n{\n    \/* Unregister *\/\n    pci_unregister_driver(&amp;my_driver);\n}\n\nvoid release_device(struct pci_dev *pdev)\n{\n    \/* Disable IRQ #42*\/\n    free_irq(42, pdev);\n    \/* Free memory region *\/\n    pci_release_region(pdev, pci_select_bars(pdev, IORESOURCE_MEM));\n    \/* And disable device *\/\n    pci_disable_device(pdev);\n}\n\n\/* *\/\n\nstatic irqreturn_t irq_handler(int irq, void *cookie)\n{\n   (void) cookie;\n   printk(\"Handle IRQ #%d\\n\", irq);\n   return IRQ_HANDLED;\n}\n\n\/* Reqest interrupt and setup handler *\/\nint set_interrupts(struct pci_dev *pdev)\n{\n    \/* We want MSI interrupt, 3 lines (just an example) *\/\n    int ret = pci_alloc_irq_vectors(pdev, 3, 3, PCI_IRQ_MSI);\n\n    if (ret &lt; 0) {\n        return ret;\n    }\n\n    \/* Request IRQ #42 *\/\n    return request_threaded_irq(42, irq_handler, NULL, 0, \"TEST IRQ\", pdev);\n}\n\n\/* Write some data to the device *\/\nvoid write_sample_data(struct pci_dev *pdev)\n{\n    int data_to_write = 0xDEADBEEF; \/* Just a random trash *\/\n\n    struct my_driver_priv *drv_priv = (struct my_driver_priv *) pci_get_drvdata(pdev);\n\n    if (!drv_priv) {\n        return;\n    }\n\n    \/* Write 32-bit data to the device memory *\/\n    iowrite32(data_to_write, drv_priv-&gt;hwmem);\n}\n\n\/* This function is called by the kernel *\/\nstatic int my_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n    int bar, err;\n    u16 vendor, device;\n    unsigned long mmio_start,mmio_len;\n    struct my_driver_priv *drv_priv;\n\n    \/* Let's read data from the PCI device configuration registers *\/\n    pci_read_config_word(pdev, PCI_VENDOR_ID, &amp;vendor);\n    pci_read_config_word(pdev, PCI_DEVICE_ID, &amp;device);\n\n    printk(KERN_INFO \"Device vid: 0x%X pid: 0x%X\\n\", vendor, device);\n\n    \/* Request IO BAR *\/\n    bar = pci_select_bars(pdev, IORESOURCE_MEM);\n\n    \/* Enable device memory *\/\n    err = pci_enable_device_mem(pdev);\n\n    if (err) {\n        return err;\n    }\n\n    \/* Request memory region for the BAR *\/\n    err = pci_request_region(pdev, bar, MY_DRIVER);\n\n    if (err) {\n        pci_disable_device(pdev);\n        return err;\n    }\n\n    \/* Get start and stop memory offsets *\/\n    mmio_start = pci_resource_start(pdev, 0);\n    mmio_len = pci_resource_len(pdev, 0);\n\n    \/* Allocate memory for the driver private data *\/\n    drv_priv = kzalloc(sizeof(struct my_driver_priv), GFP_KERNEL);\n\n    if (!drv_priv) {\n        release_device(pdev);\n        return -ENOMEM;\n    }\n\n    \/* Remap BAR to the local pointer *\/\n    drv_priv-&gt;hwmem = ioremap(mmio_start, mmio_len);\n\n    if (!drv_priv-&gt;hwmem) {\n       release_device(pdev);\n       return -EIO;\n    }\n\n    \/* Set driver private data *\/\n    \/* Now we can access mapped \"hwmem\" from the any driver's function *\/\n    pci_set_drvdata(pdev, drv_priv);\n\n    write_sample_data(pdev);\n\n    return set_interrupts(pdev);\n}\n\n\/* Clean up *\/\nstatic void my_driver_remove(struct pci_dev *pdev)\n{\n    struct my_driver_priv *drv_priv = pci_get_drvdata(pdev);\n\n    if (drv_priv) {\n        if (drv_priv-&gt;hwmem) {\n            iounmap(drv_priv-&gt;hwmem);\n        }\n\n        pci_free_irq_vectors(pdev);\n\n        kfree(drv_priv);\n    }\n\n    release_device(pdev);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Oleg Kutkov &lt;contact@olegkutkov.me&gt;\");\nMODULE_DESCRIPTION(\"Test PCI driver\");\nMODULE_VERSION(\"0.1\");\n\nmodule_init(mypci_driver_init);\nmodule_exit(mypci_driver_exit);<\/pre>\n<p>And <strong>Makefile<\/strong>:<\/p>\n<pre class=\"prettyprint\">BINARY     := test_pci_module\nKERNEL      := \/lib\/modules\/$(shell uname -r)\/build\nARCH        := x86\nC_FLAGS     := -Wall\nKMOD_DIR    := $(shell pwd)\n\nOBJECTS := test_pci.o\n\nccflags-y += $(C_FLAGS)\n\nobj-m += $(BINARY).o\n\n$(BINARY)-y := $(OBJECTS)\n\n$(BINARY).ko:\n    make -C $(KERNEL) M=$(KMOD_DIR) modules\n\nclean:\n    rm -f $(BINARY).ko<\/pre>\n<h3><\/h3>\n<h3>Real-life example<\/h3>\n<p>I worked in the Crimean Astrophysical observatory a few years ago and found a PCI interface board for 4 incremental linear or angular encoders. I decided to use this board, but there was no Linux driver.<br \/>\nI contacted the vendor and proposed to them to write an open-source driver for Linux. They were kind enough and proposed the full documentation.<br \/>\nThis was a table with memory offsets and data sizes. Basically, at which offsets I can read sensor data and so on.<\/p>\n<p>I wrote <a href=\"https:\/\/github.com\/olegkutkov\/lir941_linux_driver\">this driver<\/a>. The driver uses a <a href=\"https:\/\/olegkutkov.me\/2018\/03\/14\/simple-linux-character-device-driver\/\">character device<\/a> interface to interact with the user.<br \/>\nIt&#8217;s quite simple and might be a good example to start PCI driver development.<\/p>\n<p>Thanks for reading<\/p>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In this article, I want to discuss some basics of the Linux PCI\/PCIe drivers development. I think this issue is not properly covered, and some existing information is might be outdated. I will show basic concepts and important structures, and this is might be a good beginner guide for newbie driver developers.<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[76,25,54],"tags":[100,39,40,27,99],"_links":{"self":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/1575"}],"collection":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/comments?post=1575"}],"version-history":[{"count":75,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/1575\/revisions"}],"predecessor-version":[{"id":2584,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/1575\/revisions\/2584"}],"wp:attachment":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/media?parent=1575"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/categories?post=1575"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/tags?post=1575"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}