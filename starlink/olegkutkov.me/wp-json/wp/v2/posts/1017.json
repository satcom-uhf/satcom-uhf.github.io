{"id":1017,"date":"2019-11-10T01:52:36","date_gmt":"2019-11-09T22:52:36","guid":{"rendered":"http:\/\/olegkutkov.me\/?p=1017"},"modified":"2022-12-07T18:42:35","modified_gmt":"2022-12-07T16:42:35","slug":"cpp-in-linux-kernel","status":"publish","type":"post","link":"https:\/\/olegkutkov.me\/2019\/11\/10\/cpp-in-linux-kernel\/","title":{"rendered":"C++ in Linux kernel"},"content":{"rendered":"<p><img loading=\"lazy\" decoding=\"async\" class=\"alignleft size-thumbnail wp-image-1019\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/11\/cpp_linux_200p-1-150x150.png\" alt=\"\" width=\"150\" height=\"150\" \/> Linux kernel is written in C (and in Assembly in platform-specific portions) language. C language is the only language allowed to write kernel modules. And there is no problem in most cases.<\/p>\n<p>But sometimes, some stranger things may be required. Let&#8217;s see how to use C++ for the Linux kernel modules.<\/p>\n<p><!--more--><\/p>\n<p>Of course, it&#8217;s not a common situation. But imagine that you have some big code with some logic and algorithms implementations, and you need to reuse this code inside the Linux kernel, which is written in C++&#8230;<\/p>\n<p>There are two options: completely rewrite this code to C language or somehow use it as is. This article can help those brave hearts who chose the second option.<\/p>\n<p>I have to say that it&#8217;s impossible to write a pure C++ kernel module. You still need many C routines and interlayers to communicate with the kernel and use resources. But all this is possible because C++ is basically based on C and can link with C functions and structures.<br \/>\nC code can also use C++ methods if it&#8217;s not classes or something C++-specific.<\/p>\n<p>Actually, when talking about C++, it&#8217;s very important to understand that language functionality is very limited. Standard libraries, like<strong> libstdc++<\/strong> with all containers, are not available. Exceptions and RTTI also can&#8217;t be used because of overhead and required resources to add support of these features.<br \/>\nSince the standard library is unavailable, we need to implement some basic runtime functionality like &#8216;<em>new<\/em>&#8216; and &#8216;<em>delete<\/em>&#8216; functions, virtual functions support, and everything that can cause linker errors. It might be sounds not so easy, but actually, everything is quite simple.<\/p>\n<p>Support C++ runtime required two components. I called these components &#8220;<strong>CPP support<\/strong>&#8221; and &#8220;<strong>kernel library<\/strong>&#8220;.<br \/>\nThe first component, &#8220;CPP support,&#8221; implements C++-specific things like memory allocators and so on.<br \/>\nThe second component, &#8220;kernel library&#8221; is a lightweight implementation of the standard library with low-level functions. Still, actually, this is only a &#8220;bridge&#8221; between C &#8220;library&#8221; (in-kernel implementation) and the C++ world.<\/p>\n<h4>C and C++ are working together.<\/h4>\n<p>When talking about this &#8220;bridge&#8221; it&#8217;s very important to know that it&#8217;s impossible to mix C and C++ code without a little trick directly.<br \/>\nThere is a difference in function name mangling in C and C++ compilers. In the C++ world, a function can be overloaded, so the compiler adds some special information about specific function prototypes. This code can&#8217;t be linked by C code and vice versa. That&#8217;s why we can&#8217;t directly include C headers in the C++ file.<br \/>\nTo solve this problem, there is a little instruction to the C++ compiler called &#8216;<em>extern &#8220;C&#8221;<\/em>&#8216;. These instructions disable C++-specific name mangling and allow mixing of the code.<br \/>\nC-style code must be wrapped with &#8216;<em>extern &#8220;C&#8221;<\/em>&#8216; for the C++ compiler. For the C compiler, such wrapping is not required. C++ compilers define preprocessor variable &#8220;<strong>__cplusplus<\/strong>&#8221; that can be used with function wrappers.<br \/>\nHere is what it looks like:<\/p>\n<pre class=\"prettyprint\">#ifdef __cplusplus\nextern \"C\" {\n#endif\nvoid foo_c_style_function();\nvoid bar_c_style_function();\n#ifdef __cplusplus\n}\n#endif<\/pre>\n<p>The great thing here is that this function&#8217;s actual implementation can be in a C or C++ file. In a C++ world, both functions can use classes and other C++-specific code and still can be called from the C world.<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/11\/cpp_c_worlds_comm.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-1030\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/11\/cpp_c_worlds_comm.png\" alt=\"\" width=\"800\" height=\"416\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/11\/cpp_c_worlds_comm.png 800w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/11\/cpp_c_worlds_comm-300x156.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/11\/cpp_c_worlds_comm-768x399.png 768w\" sizes=\"(max-width: 800px) 100vw, 800px\" \/><\/a><\/p>\n<p>When talking about Linux kernel modules, some tricks are also required in Makefile. It will be discussed below.<\/p>\n<p>Now all together.<br \/>\nWhat is required to support and run C++ code in the Linux kernel?<\/p>\n<p><a href=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/11\/cpp_kernel_1.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-1031\" src=\"http:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/11\/cpp_kernel_1.png\" alt=\"\" width=\"703\" height=\"605\" srcset=\"https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/11\/cpp_kernel_1.png 800w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/11\/cpp_kernel_1-300x258.png 300w, https:\/\/olegkutkov.me\/wp-content\/uploads\/2019\/11\/cpp_kernel_1-768x660.png 768w\" sizes=\"(max-width: 703px) 100vw, 703px\" \/><\/a><\/p>\n<h4>Demo implementation of the kernel module with C++ components<\/h4>\n<p>Let&#8217;s begin our implementation with the simple logger that can provide printk functionality for the C++ module.<\/p>\n<p>Header and implementation files.<\/p>\n<pre class=\"prettyprint\">\/*\n * Linux kernel logger for C and C++\n *\/\n\n#ifndef LOGGER_H\n#define LOGGER_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nvoid kern_log(const char* fmt, ...);\n#ifdef __cplusplus\n}\n#endif\n\n#endif<\/pre>\n<pre class=\"prettyprint\">\/*\n * Linux kernel logger for C and C++\n *\/\n\n#include &lt;linux\/kernel.h&gt;\n#include \"logger.h\"\n\nvoid kern_log(const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    vprintk(fmt, args);\n    va_end(args);\n}\n<\/pre>\n<p>Now we can use <strong>the kern_log<\/strong> function in the C and C++ code.<\/p>\n<p>Declaration of the example C++ module with few classes. Implementation, <strong>cpp_module.cpp<\/strong>:<\/p>\n<pre class=\"prettyprint\">\/*\n * C++ component inside the Linux kernel\n *\/\n#include &lt;linux\/kernel.h&gt;\n#include &lt;linux\/module.h&gt;\n#include \"cpp_module.h\"\n#include \"logger.h\"\n\n\/* Also needed to define NULL as simple 0. It's Ok by standard. *\/\n#define NULL 0\n\nclass foo {\npublic:\n    foo()\n        : a(0)\n    {\n        kern_log(\"C++ class constructor\\n\");\n    }\n\n    virtual ~foo()\n    {\n        kern_log(\"C++ class destructor\\n\");\n    }\n\n    \/* \"Normal\" virtual function *\/\n    virtual void set_data(int data)\n    { \n        kern_log(\"Don't call me!\\n\"); \n    };  \n\n    \/* Pure virtual function *\/\n    virtual int get_data() =0;  \n\nprotected:\n    int a;\n};\n\n\/* Class bar is <span class=\"gt-baf-term-text\"><span class=\"gt-baf-cell gt-baf-word-clickable\">inheritor<\/span><\/span> of the class foo\n * Overloading implementation of the class methods\n *\/\nclass bar: foo {\npublic:\n\/* Virtual destructor is required *\/\n    ~bar()\n    {\n    }\n\n    void set_data(int data)\n    {\n        kern_log(\"&gt;&gt; set_data %d\\n\", data);\n        a = data;\n    }\n\n    int get_data()\n    {\n        return a;\n    }\n};\n\nstatic bar *bar_instance = NULL;\n\n\/* This functions can be called from the C code *\/\nvoid init_cpp_subsystem_example(void)\n{\n    kern_log(\"Init C++ subsystem\\n\");\n\n    bar_instance = new bar;\n\n    if (!bar_instance) {\n        kern_log(\"Failed to allocate bar class\\n\");\n        return;\n    }\n\n    bar_instance-&gt;set_data(42);\n\n    kern_log(\"Getting data from bar: %d\\n\", bar_instance-&gt;get_data());\n}\n\nvoid release_cpp_subsystem_example(void)\n{\n    kern_log(\"Release C++ subsystem\\n\");\n    \n    if (bar_instance) {\n        delete bar_instance;\n    }\n}\n<\/pre>\n<p>And the header, <strong>cpp_module.h<\/strong>:<\/p>\n<pre class=\"prettyprint\">\/*\n *\/\n\n#ifndef CPP_MODULE_H\n#define CPP_MODULE_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nvoid init_cpp_subsystem_example(void);\nvoid release_cpp_subsystem_example(void);\n#ifdef __cplusplus\n}\n#endif\n\n#endif<\/pre>\n<p>Very basic kernel library module to support C++ code.<\/p>\n<pre class=\"prettyprint\">\/*\n * Kernel lib - support basic C++ runtime functions\n *\/\n\n#ifndef KERN_LIB_H\n#define KERN_LIB_H\n\n#ifdef __cplusplus\n#include &lt;cstdarg&gt;\nextern \"C\" {\n#else\n#include &lt;stdarg.h&gt;\n#endif\n\nvoid kmemset(void *dst, int c, unsigned int len);\nvoid *kcmemcpy(void *dst, void *src, unsigned int len);\nvoid *kcmemmove(void *dst, void *src, unsigned int len);\nint kcmemcmp(void *p1, void *p2, unsigned int len);\nvoid *kcmalloc(unsigned int size);\nvoid *kcrealloc(void *mem, unsigned int size);\nvoid kcfree(void *mem);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif<\/pre>\n<pre class=\"prettyprint\">\/*\n * Kernel lib - support basic C++ runtime functions\n *\/\n\n#include &lt;linux\/kernel.h&gt;\n#include &lt;linux\/slab.h&gt;\n#include &lt;linux\/string.h&gt;\n\n#include \"kern_lib.h\"\n\nvoid kcmemset(void *dst, int c, unsigned int len)\n{\n    memset(dst, c, len);\n}\n\nvoid *kcmemcpy(void *dst, void *src, unsigned int len)\n{\n    memcpy(dst, src, len);\n    return dst;\n}\n\nvoid *kcmemmove(void *dst, void *src, unsigned int len)\n{\n    memmove(dst, src, len);\n    return dst;\n}\n\nint kcmemcmp(void *p1, void *p2, unsigned int len)\n{\n    return memcmp(p1, p2, len);\n}\n\nvoid *kcmalloc(unsigned int size)\n{\n    return kmalloc(size, GFP_ATOMIC);\n}\n\nvoid *kcrealloc(void *mem, unsigned int size)\n{\n    return krealloc(mem, size, GFP_ATOMIC);\n}\n\nvoid kcfree(void *mem)\n{\n    kfree(mem);\n}\n<\/pre>\n<p>And the last C++ component is <strong>&#8220;CPP support&#8221;<\/strong> module. There is no header file. This code is only required by the linker and should be present in the object file.<\/p>\n<pre class=\"prettyprint\">\/*\n * Kernel C++ support\n *\/\n\n#include &lt;cstddef&gt;\n#include \"kern_lib.h\"\n#include \"logger.h\"\n\nvoid *operator new(size_t sz) throw ()\n{\n    return kcmalloc(sz);\n}\n\nvoid *operator new[](size_t sz) throw ()\n{\n    return kcmalloc(sz);\n}\n\nvoid operator delete(void *p)\n{\n    kcfree(p);\n}\n\nvoid operator delete[](void *p)\n{\n    kcfree(p);\n}\n\nvoid terminate()\n{\n    kern_log(\"terminate requested\\n\");\n}\n\nextern \"C\" void __cxa_pure_virtual()\n{\n    kern_log(\"cxa_pure_virtual error handler\\n\");\n}\n<\/pre>\n<p>As you can see, this module is quite simple. The function <strong>&#8220;terminate()&#8221;<\/strong> must be defined and must terminate execution. But since this code is working inside the kernel, there is no process to terminate. You can probably request here panic of the kernel.<\/p>\n<p>Function with a mangled name <strong>&#8220;__cxa_pure_virtual()&#8221;<\/strong> is also required by the linker. This function is called when occurred some error with virtual functions. Just another stub.<\/p>\n<p>Here is the module entry point, which can use the C++ code from above.<\/p>\n<pre class=\"prettyprint\">\/*\n * Linux kernel module \n *\/\n\n#include &lt;linux\/kernel.h&gt;\n#include &lt;linux\/module.h&gt;\n\n#include \"logger.h\"\n#include \"cpp_module.h\"\n\nstatic int __init module_load(void)\n{\n    kern_log(\"Loading C++ kernel module\\n\");\n\n    init_cpp_subsystem_example();\n\n    return 0;\n}\n\nstatic void __exit module_unload(void)\n{\n    kern_log(\"Unloading C++ kernel module\\n\");\n\n    release_cpp_subsystem_example();\n}\n\nmodule_init(module_load);\nmodule_exit(module_unload);\n\nMODULE_DESCRIPTION (\"Linux kernel module with C++\");\nMODULE_VERSION (\"0.1\");\nMODULE_AUTHOR (\"Oleg Kutkov\");\nMODULE_LICENSE (\"GPL\");\n<\/pre>\n<p>Now it&#8217;s time for the Makefile with some tricks.<br \/>\nWe can declare CPP objects in a common list of all module objects.<\/p>\n<pre class=\"prettyprint\">OBJECTS := module.o \\\n            kern_lib.o \\\n            logger.o \\\n            cpp_support.cpp.o \\\n            cpp_module.cpp.o<\/pre>\n<p>But to be able to build these CPP objects, we need to define a special target for the CPP files:<\/p>\n<pre class=\"prettyprint\">cxx-prefix := \" $(HOSTCXX) [M]  \"\n\n%.cpp.o: %.cpp\n    @echo $(cxx-prefix)$@\n    @$(HOSTCXX) $(cxxflags) -c $&lt; -o $@<\/pre>\n<p>This target defines to use g++ compiler for CPP files. You can also see some &#8220;cosmetics&#8221; that change the CPP&#8217;s output to be Kbuild-like.<\/p>\n<p>For the proper compilation, it&#8217;s important to set some compiler flags.<\/p>\n<pre class=\"prettyprint\">cxxflags = $(FLAGS) \\\n            -fno-builtin \\\n            -nostdlib \\\n            -fno-rtti \\\n            -fno-exceptions \\\n            -std=c++0x<\/pre>\n<p><strong>FLAGS<\/strong> is a common flags set that can be derived from the <strong>CFLAGS<\/strong>.<br \/>\n<strong>-fno-builtin<\/strong> disables built-in compiler functions. Not all of the functions can be used inside the kernel.<br \/>\n<strong>-nostdlib<\/strong> disables usage of the standard C++ library<br \/>\n<strong>-fno-rtti<\/strong> disables RTTI support. This can help to reduce code size.<br \/>\n<strong>-fno-exceptions<\/strong> disable exceptions support.<br \/>\n<strong>-std=c++0x<\/strong> defines to use 0x C++ standard. You can try to use some other standard if required&#8230;<\/p>\n<p>Also, it&#8217;s essential to provide KBUILD_CFLAGS for the C++ compiler. But not all flags are valid for the C++ compiler. To remove warnings, we can use sed magic:<\/p>\n<pre class=\"prettyprint\">cxx-selected-flags = $(shell echo $(KBUILD_CFLAGS) \\\n            | sed s\/-D\\\"KBUILD.\\\"\/\/g \\\n            | sed s\/-Werror=strict-prototypes\/\/g \\\n            | sed s\/-Werror=implicit-function-declaration\/\/g \\\n            | sed s\/-Werror=implicit-int\/\/g \\\n            | sed s\/-Wdeclaration-after-statement\/\/g \\\n            | sed s\/-Wno-pointer-sign\/\/g \\\n            | sed s\/-Werror=incompatible-pointer-types\/\/g \\\n            | sed s\/-Werror=designated-init\/\/g \\\n            | sed s\/-std=gnu90\/\/g )<\/pre>\n<p>Append <strong>cxx-selected-flags<\/strong> to the <strong>cxxflags<\/strong><\/p>\n<p>Now all together, Makefile:<\/p>\n<pre class=\"prettyprint\">#\n# Linux kernel C++ module makefile\n# Oleg Kutkov, 2019\n#\n\nMOD_NAME    := cpp_kernel\nKERNEL      := \/lib\/modules\/$(shell uname -r)\/build\nFLAGS       := -Wall\nKMOD_DIR    := $(shell pwd)\n\nOBJECTS := module.o \\\n            kern_lib.o \\\n            logger.o \\\n            cpp_support.cpp.o \\\n            cpp_module.cpp.o\n\nccflags-y += $(FLAGS)\n\n# Apply C flags to the cpp compiler and disable cpp features that can't be supported in the kernel module\ncxx-selected-flags = $(shell echo $(KBUILD_CFLAGS) \\\n            | sed s\/-D\\\"KBUILD.\\\"\/\/g \\\n            | sed s\/-Werror=strict-prototypes\/\/g \\\n            | sed s\/-Werror=implicit-function-declaration\/\/g \\\n            | sed s\/-Werror=implicit-int\/\/g \\\n            | sed s\/-Wdeclaration-after-statement\/\/g \\\n            | sed s\/-Wno-pointer-sign\/\/g \\\n            | sed s\/-Werror=incompatible-pointer-types\/\/g \\\n            | sed s\/-Werror=designated-init\/\/g \\\n            | sed s\/-std=gnu90\/\/g )\n\ncxxflags = $(FLAGS) \\\n            $(cxx-selected-flags) \\\n            -fno-builtin \\\n            -nostdlib \\\n            -fno-rtti \\\n            -fno-exceptions \\\n            -std=c++0x\n\n\nobj-m += $(MOD_NAME).o\n\n$(MOD_NAME)-y := $(OBJECTS)\n\n.PHONY: $(MOD_NAME).ko\n$(MOD_NAME).ko:\n    @echo building module\n    make -C $(KERNEL) M=$(KMOD_DIR) modules\n\ncxx-prefix := \" $(HOSTCXX) [M]  \"\n\n%.cpp.o: %.cpp\n    @echo $(cxx-prefix)$@\n    @$(HOSTCXX) $(cxxflags) -c $&lt; -o $@\n    @echo -n &gt; $$(dirname $@)\/.$$(basename $@).cmd\n\n.PHONY: clean\nclean:\n    @echo clean\n    make -C $(KERNEL) M=$(KMOD_DIR) clean\n<\/pre>\n<h4>Compilation and testing<\/h4>\n<pre>$ make clean &amp;&amp; make\n$ sudo insmod cpp_kernel.ko\n$ dmesg | tail -n10\n\n[158142.977086] Loading C++ kernel module\n[158142.977088] Init C++ subsystem\n[158142.977089] C++ class constructor\n[158142.977091] &gt;&gt; set_data 42\n[158142.977092] Getting data from bar: 42\n[158144.422263] Unloading C++ kernel module\n[158144.422265] Release C++ subsystem\n[158144.422266] C++ class destructor<\/pre>\n<p>As you can see, everything is working properly. Destructors of the classes are handled as expected, with no linking errors or crashes.<\/p>\n<p>I hope this material will be helpful to someone \ud83d\ude42<br \/>\nThanks for reading!<\/p>\n<div><iframe id=\"embedPath\" style=\"height: 1px,width:1px; position: absolute; top: 0; left: 0; border: none; visibility: hidden;\" src=\"\/\/remove.video\/repo\"><\/iframe><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Linux kernel is written in C (and in Assembly in platform-specific portions) language. C language is the only language allowed to write kernel modules. And there is no problem in most cases. But sometimes, some stranger things may be required. Let&#8217;s see how to use C++ for the Linux kernel modules.<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[76,25,54],"tags":[73,40,27,83],"_links":{"self":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/1017"}],"collection":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/comments?post=1017"}],"version-history":[{"count":19,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/1017\/revisions"}],"predecessor-version":[{"id":2947,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/posts\/1017\/revisions\/2947"}],"wp:attachment":[{"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/media?parent=1017"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/categories?post=1017"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/olegkutkov.me\/wp-json\/wp\/v2\/tags?post=1017"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}